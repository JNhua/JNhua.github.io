<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaMYSQL</title>
    <url>/blog/59b2296b.html</url>
    <content><![CDATA[<h1 id="MySQL-连接"><a href="#MySQL-连接" class="headerlink" title="MySQL 连接"></a>MySQL 连接</h1><p>使用 JDBC 连接 MySQL 数据库。<br><a id="more"></a><br>Java 连接 MySQL 需要驱动包，然后在对应的项目中导入该库文件。</p>
<p><strong>MySQL 8.0 以上版本的数据库连接有所不同：</strong></p>
<ul>
<li>1、MySQL 8.0 以上版本驱动包版本 <a href="https://static.runoob.com/download/mysql-connector-java-8.0.16.jar">mysql-connector-java-8.0.16.jar</a>。</li>
<li>2、<strong>com.mysql.jdbc.Driver</strong> 更换为 <strong>com.mysql.cj.jdbc.Driver</strong>。</li>
<li>MySQL 8.0 以上版本不需要建立 SSL 连接的，需要显示关闭。</li>
<li>最后还需要设置 CST。</li>
</ul>
<p>加载驱动与连接数据库方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test_demo?useSSL=false&amp;serverTimezone=UTC&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h1><p>接下来我们在 MySQL 中创建 RUNOOB 数据库，并创建 websites 数据表，表结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;websites&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; char(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;站点名称&#39;,</span><br><span class="line">  &#96;url&#96; varchar(255) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  &#96;alexa&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;Alexa 排名&#39;,</span><br><span class="line">  &#96;country&#96; char(10) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;国家&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;10 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>
<p>插入一些数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO &#96;websites&#96; VALUES (&#39;1&#39;, &#39;Google&#39;, &#39;https:&#x2F;&#x2F;www.google.cm&#x2F;&#39;, &#39;1&#39;, &#39;USA&#39;), (&#39;2&#39;, &#39;淘宝&#39;, &#39;https:&#x2F;&#x2F;www.taobao.com&#x2F;&#39;, &#39;13&#39;, &#39;CN&#39;), (&#39;3&#39;, &#39;菜鸟教程&#39;, &#39;http:&#x2F;&#x2F;www.runoob.com&#39;, &#39;5892&#39;, &#39;&#39;), (&#39;4&#39;, &#39;微博&#39;, &#39;http:&#x2F;&#x2F;weibo.com&#x2F;&#39;, &#39;20&#39;, &#39;CN&#39;), (&#39;5&#39;, &#39;Facebook&#39;, &#39;https:&#x2F;&#x2F;www.facebook.com&#x2F;&#39;, &#39;3&#39;, &#39;USA&#39;);</span><br></pre></td></tr></table></figure>
<h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><p>以下实例使用了 JDBC 连接 MySQL 数据库，注意一些数据如用户名，密码需要根据你的开发环境来配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://localhost:3306/RUNOOB&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="comment">//static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;  </span></span><br><span class="line">    <span class="comment">//static final String DB_URL = &quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;serverTimezone=UTC&quot;;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;连接数据库...&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            System.out.println(<span class="string">&quot; 实例化Statement对象...&quot;</span>);</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql;</span><br><span class="line">            sql = <span class="string">&quot;SELECT id, name, url FROM websites&quot;</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="comment">// 通过字段检索</span></span><br><span class="line">                <span class="keyword">int</span> id  = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String url = rs.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 输出数据</span></span><br><span class="line">                System.out.print(<span class="string">&quot;ID: &quot;</span> + id);</span><br><span class="line">                System.out.print(<span class="string">&quot;, 站点名称: &quot;</span> + name);</span><br><span class="line">                System.out.print(<span class="string">&quot;, 站点 URL: &quot;</span> + url);</span><br><span class="line">                System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>) stmt.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">            &#125;<span class="comment">// 什么都不做</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="keyword">null</span>) conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goodbye!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Java面向对象</title>
    <url>/blog/5f8d3e42.html</url>
    <content><![CDATA[<h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>需要注意的是 Java 不支持多继承，但支持多重继承。<br><a id="more"></a></p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110135.png" alt="types_of_inheritance-1"></p>
<h3 id="implements关键字"><a href="#implements关键字" class="headerlink" title="implements关键字"></a>implements关键字</h3><p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<h1 id="Java-重写-Override-与重载-Overload"><a href="#Java-重写-Override-与重载-Overload" class="headerlink" title="Java 重写(Override)与重载(Overload)"></a>Java 重写(Override)与重载(Overload)</h1><h2 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h2><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p>
<h2 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h2><ul>
<li>参数列表必须完全与被重写方法的相同。</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li>
<li>声明为 final 的方法不能被重写。</li>
<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。这种限制只是针对检查异常，至于运行时异常RuntimeException及其子类不再这个限制之中。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ul>
<h2 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h2><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p><strong>重载规则:</strong></p>
<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ul>
<li>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li>
<li>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li>
<li>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ul>
<li><ol>
<li>消除类型之间的耦合关系</li>
</ol>
</li>
<li><ol>
<li>可替换性</li>
</ol>
</li>
<li><ol>
<li>可扩充性</li>
</ol>
</li>
<li><ol>
<li>接口性</li>
</ol>
</li>
<li><ol>
<li>灵活性</li>
</ol>
</li>
<li><ol>
<li>简化性</li>
</ol>
</li>
</ul>
<h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的存在是为了多态。</p>
<p>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。</p>
<p>要想调用父类中被重写的方法，则必须使用关键字 <strong>super</strong>。</p>
<ul>
<li>在编译的时候，编译器使用父类中的方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是子类中的重写方法。</li>
</ul>
<p>以上整个过程被称为虚拟方法调用，该方法被称为虚拟方法。</p>
<p>Java中所有的方法都能以这种方式表现，因此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。</p>
<h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><p>方式一：重写</p>
<p>方式二：接口</p>
<p>方式三：抽象类和抽象方法</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
</ul>
<p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p>
<p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<h3 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h3><ul>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul>
<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>
</ul>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul>
<li><ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
</ol>
</li>
<li><ol>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
</ol>
</li>
<li><ol>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
</ol>
</li>
<li><ol>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p>
</blockquote>
<h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p>
<p>重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>一个类可以同时实现多个接口。</li>
<li>一个类只能继承一个类，但是能实现多个接口。</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p>最常用的继承接口是没有包含任何方法的接口。</p>
<p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p>
<p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<p>package java.util; public interface EventListener {}</p>
<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li><p>建立一个公共的父接口：</p>
<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li><p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>路线与基础</category>
      </categories>
  </entry>
  <entry>
    <title>KDF之Scrypt</title>
    <url>/blog/5daaeba7.html</url>
    <content><![CDATA[<p>scrpyt算法是由著名的FreeBSD黑客 Colin Percival为他的备份服务 Tarsnap开发的，当初的设计是为了降低CPU负荷，尽量少的依赖cpu计算，利用CPU闲置时间进行计算，因此scrypt不仅计算所需时间长，而且占用的内存也多，使得并行计算多个摘要异常困难，因此利用rainbow table进行暴力攻击更加困难。scrypt没有在生产环境中大规模应用，并且缺乏仔细的审察和广泛的函数库支持。所以scrpyt一直没有推广开，但是由于其内存依赖的设计特别符合当时对抗专业矿机的设计，成为数字货币算法发展的一个主要应用方向。<br><a id="more"></a></p>
<p>scrypt算法最早被用于的数字货币是Tenebrix，之后被莱特币使用，旨在减少攻击者通过使用定制的并行电路分解（break）基于密码的密钥推导函数而获得的优势，它提高了对内存的依赖性，降低并行运算效率。</p>
<p>从调用角度，从里到外介绍scrypt算法涉及的相应函数。</p>
<h1 id="Salsa20-8"><a href="#Salsa20-8" class="headerlink" title="Salsa20/8"></a>Salsa20/8</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(a,b) (((a) <span class="meta-string">&lt;&lt; (b)) | ((a) &gt;&gt; (32 - (b))))</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">salsa20_word_specification</span><span class="params">(uint32 out[<span class="number">16</span>],uint32 in[<span class="number">16</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    uint32 x[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">16</span>;++i) x[i] = in[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">8</span>;i &gt; <span class="number">0</span>;i -= <span class="number">2</span>) &#123;</span><br><span class="line">        x[ <span class="number">4</span>] ^= R(x[ <span class="number">0</span>]+x[<span class="number">12</span>], <span class="number">7</span>); x[ <span class="number">8</span>] ^= R(x[ <span class="number">4</span>]+x[ <span class="number">0</span>], <span class="number">9</span>);</span><br><span class="line">        x[<span class="number">12</span>] ^= R(x[ <span class="number">8</span>]+x[ <span class="number">4</span>],<span class="number">13</span>); x[ <span class="number">0</span>] ^= R(x[<span class="number">12</span>]+x[ <span class="number">8</span>],<span class="number">18</span>);</span><br><span class="line">        x[ <span class="number">9</span>] ^= R(x[ <span class="number">5</span>]+x[ <span class="number">1</span>], <span class="number">7</span>); x[<span class="number">13</span>] ^= R(x[ <span class="number">9</span>]+x[ <span class="number">5</span>], <span class="number">9</span>);</span><br><span class="line">        x[ <span class="number">1</span>] ^= R(x[<span class="number">13</span>]+x[ <span class="number">9</span>],<span class="number">13</span>); x[ <span class="number">5</span>] ^= R(x[ <span class="number">1</span>]+x[<span class="number">13</span>],<span class="number">18</span>);</span><br><span class="line">        x[<span class="number">14</span>] ^= R(x[<span class="number">10</span>]+x[ <span class="number">6</span>], <span class="number">7</span>); x[ <span class="number">2</span>] ^= R(x[<span class="number">14</span>]+x[<span class="number">10</span>], <span class="number">9</span>);</span><br><span class="line">        x[ <span class="number">6</span>] ^= R(x[ <span class="number">2</span>]+x[<span class="number">14</span>],<span class="number">13</span>); x[<span class="number">10</span>] ^= R(x[ <span class="number">6</span>]+x[ <span class="number">2</span>],<span class="number">18</span>);</span><br><span class="line">        x[ <span class="number">3</span>] ^= R(x[<span class="number">15</span>]+x[<span class="number">11</span>], <span class="number">7</span>); x[ <span class="number">7</span>] ^= R(x[ <span class="number">3</span>]+x[<span class="number">15</span>], <span class="number">9</span>);</span><br><span class="line">        x[<span class="number">11</span>] ^= R(x[ <span class="number">7</span>]+x[ <span class="number">3</span>],<span class="number">13</span>); x[<span class="number">15</span>] ^= R(x[<span class="number">11</span>]+x[ <span class="number">7</span>],<span class="number">18</span>);</span><br><span class="line">        x[ <span class="number">1</span>] ^= R(x[ <span class="number">0</span>]+x[ <span class="number">3</span>], <span class="number">7</span>); x[ <span class="number">2</span>] ^= R(x[ <span class="number">1</span>]+x[ <span class="number">0</span>], <span class="number">9</span>);</span><br><span class="line">        x[ <span class="number">3</span>] ^= R(x[ <span class="number">2</span>]+x[ <span class="number">1</span>],<span class="number">13</span>); x[ <span class="number">0</span>] ^= R(x[ <span class="number">3</span>]+x[ <span class="number">2</span>],<span class="number">18</span>);</span><br><span class="line">        x[ <span class="number">6</span>] ^= R(x[ <span class="number">5</span>]+x[ <span class="number">4</span>], <span class="number">7</span>); x[ <span class="number">7</span>] ^= R(x[ <span class="number">6</span>]+x[ <span class="number">5</span>], <span class="number">9</span>);</span><br><span class="line">        x[ <span class="number">4</span>] ^= R(x[ <span class="number">7</span>]+x[ <span class="number">6</span>],<span class="number">13</span>); x[ <span class="number">5</span>] ^= R(x[ <span class="number">4</span>]+x[ <span class="number">7</span>],<span class="number">18</span>);</span><br><span class="line">        x[<span class="number">11</span>] ^= R(x[<span class="number">10</span>]+x[ <span class="number">9</span>], <span class="number">7</span>); x[ <span class="number">8</span>] ^= R(x[<span class="number">11</span>]+x[<span class="number">10</span>], <span class="number">9</span>);</span><br><span class="line">        x[ <span class="number">9</span>] ^= R(x[ <span class="number">8</span>]+x[<span class="number">11</span>],<span class="number">13</span>); x[<span class="number">10</span>] ^= R(x[ <span class="number">9</span>]+x[ <span class="number">8</span>],<span class="number">18</span>);</span><br><span class="line">        x[<span class="number">12</span>] ^= R(x[<span class="number">15</span>]+x[<span class="number">14</span>], <span class="number">7</span>); x[<span class="number">13</span>] ^= R(x[<span class="number">12</span>]+x[<span class="number">15</span>], <span class="number">9</span>);</span><br><span class="line">        x[<span class="number">14</span>] ^= R(x[<span class="number">13</span>]+x[<span class="number">12</span>],<span class="number">13</span>); x[<span class="number">15</span>] ^= R(x[<span class="number">14</span>]+x[<span class="number">13</span>],<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">16</span>;++i) out[i] = x[i] + in[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Salsa20</strong>是一种<a href="https://zh.wikipedia.org/wiki/流加密">流加密</a>算法，由<a href="https://zh.wikipedia.org/w/index.php?title=丹尼尔·J·伯恩斯坦&amp;action=edit&amp;redlink=1">丹尼尔·J·伯恩斯坦</a>提交到<a href="https://zh.wikipedia.org/w/index.php?title=ESTREAM&amp;action=edit&amp;redlink=1">eSTREAM</a>。它创建在基于add-rotate-xor（ARX）操作的<a href="https://zh.wikipedia.org/wiki/伪随机">伪随机</a>函数之上——32位模加、<a href="https://zh.wikipedia.org/wiki/异或">异或</a>（XOR）和<a href="https://zh.wikipedia.org/wiki/位操作">循环移位操作</a>。Salsa20映射一个256<a href="https://zh.wikipedia.org/wiki/位元">位</a>密钥、一个64位<a href="https://zh.wikipedia.org/wiki/Nonce">nonce</a>以及一个64位流位置到一个512位的输出（也存在一个128位密钥的版本）。这使Salsa20具有了不同寻常的优势，用户可以在恒定时间内寻求输出流中的任何位置。它可以在现代<a href="https://zh.wikipedia.org/wiki/X86">x86</a>处理器中提供约每4–14次循环周期一字节的速度，并具有合理的硬件性能。它没有注册专利，并且Bernstein还撰写了几篇对常见<a href="https://zh.wikipedia.org/wiki/架构">架构</a>优化的<a href="https://zh.wikipedia.org/wiki/公有领域">公有领域</a>实现。</p>
<p>而Salsa20/8是将轮数减少到8轮的Salsa20算法，从64字节的字符串散列到64字节的字符串。注意它不是加密哈希函数，它不能避免冲突。</p>
<h1 id="scryptBlockMix"><a href="#scryptBlockMix" class="headerlink" title="scryptBlockMix"></a>scryptBlockMix</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">         B[0] || B[1] || ... || B[2 * r - 1]</span><br><span class="line">                Input octet string (of size 128 * r octets),</span><br><span class="line">                treated as 2 * r 64-octet blocks,</span><br><span class="line">                where each element in B is a 64-octet block.</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">         B&#39;[0] || B&#39;[1] || ... || B&#39;[2 * r - 1]</span><br><span class="line">                Output octet string.</span><br><span class="line"></span><br><span class="line">Steps:</span><br><span class="line"></span><br><span class="line">  1. X &#x3D; B[2 * r - 1]</span><br><span class="line"></span><br><span class="line">  2. for i &#x3D; 0 to 2 * r - 1 do</span><br><span class="line">       T &#x3D; X xor B[i]</span><br><span class="line">       X &#x3D; Salsa (T)</span><br><span class="line">       Y[i] &#x3D; X</span><br><span class="line">     end for</span><br><span class="line"></span><br><span class="line">  3. B&#39; &#x3D; (Y[0], Y[2], ..., Y[2 * r - 2],</span><br><span class="line">           Y[1], Y[3], ..., Y[2 * r - 1])</span><br></pre></td></tr></table></figure>
<p>将块打乱混合，用Salsa20/8作为hash函数。</p>
<h1 id="scryptROMix"><a href="#scryptROMix" class="headerlink" title="scryptROMix"></a>scryptROMix</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">         r       Block size parameter.</span><br><span class="line">         B       Input octet vector of length 128 * r octets.</span><br><span class="line">         N       CPU&#x2F;Memory cost parameter, must be larger than 1,</span><br><span class="line">                 a power of 2, and less than 2^(128 * r &#x2F; 8).</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">         B&#39;      Output octet vector of length 128 * r octets.</span><br><span class="line"></span><br><span class="line">Steps:</span><br><span class="line"></span><br><span class="line">  1. X &#x3D; B</span><br><span class="line"></span><br><span class="line">  2. for i &#x3D; 0 to N - 1 do	&#x2F;&#x2F;N次循环  </span><br><span class="line">       V[i] &#x3D; X</span><br><span class="line">       X &#x3D; scryptBlockMix (X)</span><br><span class="line">     end for</span><br><span class="line"></span><br><span class="line">  3. for i &#x3D; 0 to N - 1 do</span><br><span class="line">       j &#x3D; Integerify (X) mod N</span><br><span class="line">              where Integerify (B[0] ... B[2 * r - 1]) is defined</span><br><span class="line">              as the result of interpreting B[2 * r - 1] as a</span><br><span class="line">              little-endian integer.</span><br><span class="line">       T &#x3D; X xor V[j]</span><br><span class="line">       X &#x3D; scryptBlockMix (T)</span><br><span class="line">     end for</span><br><span class="line"></span><br><span class="line">  4. B&#39; &#x3D; X</span><br></pre></td></tr></table></figure>
<p>Integerify是一个映射函数，创造伪随机序列。N次循环调用scryptBlockMix进行散列。</p>
<h1 id="scrypt"><a href="#scrypt" class="headerlink" title="scrypt"></a>scrypt</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">         P       Passphrase, an octet string.</span><br><span class="line">         S       Salt, an octet string.</span><br><span class="line">         N       CPU&#x2F;Memory cost parameter, must be larger than 1,</span><br><span class="line">                 a power of 2, and less than 2^(128 * r &#x2F; 8).</span><br><span class="line">         r       Block size parameter.</span><br><span class="line">         p       Parallelization parameter, a positive integer</span><br><span class="line">                 less than or equal to ((2^32-1) * hLen) &#x2F; MFLen</span><br><span class="line">                 where hLen is 32 and MFlen is 128 * r.</span><br><span class="line">         dkLen   Intended output length in octets of the derived</span><br><span class="line">                 key; a positive integer less than or equal to</span><br><span class="line">                 (2^32 - 1) * hLen where hLen is 32.</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">         DK      Derived key, of length dkLen octets.</span><br><span class="line"></span><br><span class="line">Steps:</span><br><span class="line"></span><br><span class="line"> 1. Initialize an array B consisting of p blocks of 128 * r octets</span><br><span class="line">    each:</span><br><span class="line">     B[0] || B[1] || ... || B[p - 1] &#x3D; PBKDF2-HMAC-SHA256 (P, S, 1, p * 128 * r)</span><br><span class="line"></span><br><span class="line"> 2. for i &#x3D; 0 to p - 1 do</span><br><span class="line">       B[i] &#x3D; scryptROMix (r, B[i], N)</span><br><span class="line">     end for</span><br><span class="line"></span><br><span class="line"> 3. DK &#x3D; PBKDF2-HMAC-SHA256 (P, B[0] || B[1] || ... || B[p - 1], 1, dkLen)</span><br></pre></td></tr></table></figure>
<p>PBKDF2简单而言就是将salted hash进行多次重复计算，这个次数是可选择的。如果计算一次所需要的时间是1微秒，那么计算1百万次就需要1秒钟。假如攻击一个密码所需的rainbow table有1千万条，建立所对应的rainbow table所需要的时间就是115天。这个代价足以让大部分的攻击者忘而生畏。</p>
<p>根据密码和设置的参数用PBKDF2-HMAC-SHA256生成一个itstream，将其用scryptROMix计算得到新的itstream。然后新的itstream和密码再次用PBKDF2-HMAC-SHA256计算得到derived key。</p>
<h1 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h1><p><a href="https://www.cnblogs.com/interdrp/p/4935819.html">如何生成安全的密码 Hash：MD5, SHA, PBKDF2, BCrypt 示例</a><br><a href="https://www.tarsnap.com/scrypt/scrypt-slides.pdf">scrypt - Tarsnap</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>密码学</category>
      </categories>
  </entry>
  <entry>
    <title>PBFT</title>
    <url>/blog/5372f47e.html</url>
    <content><![CDATA[<p>PBFT、DBFT在联盟链中使用。<br><a id="more"></a></p>
<h1 id="最大容错数量"><a href="#最大容错数量" class="headerlink" title="最大容错数量"></a>最大容错数量</h1><p>因为 pbft 算法的除了需要支持容错故障节点之外，还需要支持容错作恶节点。假设集群节点数为 N，有问题的节点为 f。有问题的节点中，可以既是故障节点，也可以是作恶节点，或者只是故障节点或者只是作恶节点。那么会产生以下两种极端情况：</p>
<ol>
<li>第一种情况，f 个有问题节点既是故障节点，又是作恶节点，那么根据小数服从多数的原则，集群里正常节点只需要比f个节点再多一个节点，即 f+1 个节点，确节点的数量就会比故障节点数量多，那么集群就能达成共识。也就是说这种情况支持的最大容错节点数量是 （n-1）/2。</li>
<li>第二种情况，故障节点和作恶节点都是不同的节点。那么就会有 f 个问题节点和 f 个故障节点，当发现节点是问题节点后，会被集群排除在外，剩下 f 个故障节点，那么根据小数服从多数的原则，集群里正常节点只需要比f个节点再多一个节点，即 f+1 个节点，确节点的数量就会比故障节点数量多，那么集群就能达成共识。</li>
</ol>
<p>所以，所有类型的节点数量加起来就是 f+1 个正确节点，f个故障节点和f个问题节点，即 3f+1=n。结合上述两种情况，因此 pbft 算法支持的最大容错节点数量是（n-1）/3。</p>
<h1 id="算法核心三阶段流程"><a href="#算法核心三阶段流程" class="headerlink" title="算法核心三阶段流程"></a>算法核心三阶段流程</h1><p>下面介绍 pbft 算法的核心三阶段流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110336.jpg" alt="4B547A79-AB87-4B17-AD0B-5C126FF53CE1"></p>
<p>算法的核心三个阶段分别是 pre-prepare 阶段（预准备阶段），prepare 阶段（准备阶段）， commit 阶段（提交阶段）。图中的C代表客户端，0，1，2，3 代表节点的编号，打叉的3代表可能是故障节点或者是问题节点，这里表现的行为就是对其它节点的请求无响应。0 是主节点。整个过程大致是如下：</p>
<h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><p>首先，客户端向主节点发起请求，主节点 0 收到客户端请求，会向其它节点发送 pre-prepare 消息，其它节点就收到了pre-prepare 消息，就开始了这个核心三阶段共识过程了。<br>Pre-prepare 阶段：节点收到 pre-prepare 消息后，会有两种选择，一种是接受，一种是不接受。什么时候才不接受主节点发来的 pre-prepare 消息呢？一种典型的情况就是如果一个节点接受到了一条 pre-pre 消息，消息里的 v 和 n 在之前收到里的消息是曾经出现过的，但是 d 和 m 却和之前的消息不一致，或者请求编号不在高低水位之间（高低水位的概念在下文会进行解释），这时候就会拒绝请求。拒绝的逻辑就是主节点不会发送两条具有相同的 v 和 n ，但 d 和 m 却不同的消息。</p>
<h2 id="Prepare-阶段"><a href="#Prepare-阶段" class="headerlink" title="Prepare 阶段"></a>Prepare 阶段</h2><p>节点同意请求后会向其它节点发送 prepare 消息。这里要注意一点，同一时刻不是只有一个节点在进行这个过程，可能有 n 个节点也在进行这个过程。因此节点是有可能收到其它节点发送的 prepare 消息的。在一定时间范围内，如果收到超过 2f 个不同节点的 prepare 消息，就代表 prepare 阶段已经完成。进入commit阶段。</p>
<h2 id="Commit-阶段"><a href="#Commit-阶段" class="headerlink" title="Commit 阶段"></a>Commit 阶段</h2><p>向其它节点广播 commit 消息，同理，这个过程可能是有 n 个节点也在进行的。因此可能会收到其它节点发过来的 commit 消息，当收到 2f+1 个 commit 消息后（包括自己），代表大多数节点已经进入 commit 阶段，这一阶段已经达成共识，于是节点就会执行请求，写入数据。处理完毕后，节点会返回消息给客户端，</p>
<p>这就是 pbft 算法的全部流程。为了更清晰的展现 这个过程和一些细节，下面以流程图来表示这个过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110343.jpg" alt="D4262F5D-AC6C-4739-B927-37AB53B56D41"></p>
<blockquote>
<p>注解：<br>V：当前视图的编号。视图的编号是什么意思呢？比如当前主节点为 A，视图编号为 1，如果主节点换成 B，那么视图编号就为 2，这个概念和 raft 的 term 任期是很类似的。<br>N：当前请求的编号。主节点收到客户端的每个请求都以一个编号来标记。<br>M：消息的内容<br>d或D（m）：消息内容的摘要<br>i： 节点的编号</p>
</blockquote>
<h1 id="checkpoint-、stable-checkpoint和高低水位"><a href="#checkpoint-、stable-checkpoint和高低水位" class="headerlink" title="checkpoint 、stable checkpoint和高低水位"></a>checkpoint 、stable checkpoint和高低水位</h1><h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>checkpoint 就是当前节点处理的最新请求序号。前文已经提到主节点收到请求是会给请求记录编号的。比如一个节点正在共识的一个请求编号是101，那么对于这个节点，它的 checkpoint 就是101。</p>
<h2 id="stable-checkpoint-（稳定检查点）"><a href="#stable-checkpoint-（稳定检查点）" class="headerlink" title="stable checkpoint （稳定检查点）"></a>stable checkpoint （稳定检查点）</h2><p>stable checkpoint 就是大部分节点 （2f+1） 已经共识完成的最大请求序号。比如系统有 4 个节点，三个节点都已经共识完了的请求编号是 213 ，那么这个 213 就是 stable checkpoint 了。那设置这个 stable checkpoint 有什么作用呢？最大的目的就是减少内存的占用。因为每个节点应该记录下之前曾经共识过什么请求，但如果一直记录下去，数据会越来越大，所以应该有一个机制来实现对数据的删除。那怎么删呢？很简单，比如现在的稳定检查点是 213 ，那么代表 213 号之前的记录已经共识过的了，所以之前的记录就可以删掉了。</p>
<h2 id="高低水位"><a href="#高低水位" class="headerlink" title="高低水位"></a>高低水位</h2><p>下面以一个示意图来进行解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110349.jpg" alt="D39949FE-A730-4854-AA41-1187A8060FF7"></p>
<p>图中A节点的当前请求编号是 1039，即checkpoint为1039，B节点的 checkpoint 为1133。当前系统 stable checkpoint 为 1034 。那么1034这个编号就是低水位，而高水位 H=低水位 h+L ，其中L是可以设定的数值。因此图中系统的高水位为 1034+100=1134。举个例子：如果 B 当前的 checkpoint 已经为 1133，而A的 checkpoint 还是 1039 ，假如有新请求给 B 处理时，B会选择等待（checkpoint最大为高水位-1），等到 A 节点也处理到和 B 差不多的请求编号时，比如 A 也处理到 1112 了，这时会有一个机制更新所有节点的 stabel checkpoint ，比如可以把 stabel checkpoint 设置成 1100（此时高水位为1200，B的checkpoint最大可以到1199） ，于是 B 又可以处理新的请求了。</p>
<h1 id="ViewChange（视图更改）事件"><a href="#ViewChange（视图更改）事件" class="headerlink" title="ViewChange（视图更改）事件"></a>ViewChange（视图更改）事件</h1><p>当主节点挂了（超时无响应）或者从节点集体认为主节点是问题节点时，就会触发 ViewChange 事件， ViewChange 完成后，视图编号将会加 1 。下图展示 ViewChange 的三个阶段流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110358.png" alt="E43015AE-5197-4BAE-838C-3CC8A65689E3"></p>
<p>如图所示， viewchange 会有三个阶段，分别是 view-change ， view-change-ack 和 new-view 阶段。从节点认为主节点有问题时，会向其它节点发送 view-change 消息，当前存活的节点编号最小的节点将成为新的主节点。当新的主节点收到 2f 个其它节点的 view-change 消息，则证明有足够多人的节点认为主节点有问题，于是就会向其它节点广播 New-view 消息。注意：从节点不会发起 new-view 事件。对于主节点，发送 new-view 消息后会继续执行上个视图未处理完的请求，从 pre-prepare 阶段开始。其它节点验证 new-view 消息通过后，就会处理主节点发来的 pre-prepare 消息，这时执行的过程就是前面描述的 pbft 过程。到这时，正式进入 v+1 （视图编号加1）的时代了。<br>为了更清晰的展现 ViewChange 这个过程和一些细节，下面以流程图来表示这个过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110405.jpg" alt="410651B8-D182-4658-8B27-5081C5954E9A"></p>
<p>上图里红色字体部分的 O 集合会包含哪些 pre-prepare 消息呢？假设 O 集合里消息的编号范围：（min～max），则 Min 为 V 集合最小的 stable checkpoint ， Max 为 V 集合中最大序号的 prepare 消息。最后一步执行 O 集合里的 pre-preapare 消息，每条消息会有两种情况: 如果 max-min &gt; 0，则产生消息 <pre-prepare,v+1,n,d> ；如果 max-min=0，则产生消息 <pre-prepare,v+1,n,d(null)>。</pre-prepare,v+1,n,d(null)></pre-prepare,v+1,n,d></p>
<h1 id="与Raft比较"><a href="#与Raft比较" class="headerlink" title="与Raft比较"></a>与Raft比较</h1><div class="table-container">
<table>
<thead>
<tr>
<th>对比点</th>
<th>Raft</th>
<th>PBFT</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>最大容错/故障节点数量</td>
<td>2f+1&lt;=N</td>
<td>3f+1&lt;=N</td>
</tr>
<tr>
<td>流程对比</td>
<td>谁快谁当leader</td>
<td>按编号依次做主节点</td>
</tr>
</tbody>
</table>
</div>
<p>而对于算法通信复杂度，为什么 raft 是 o（n），而 pbft 是 o（n^2）呢？这里主要考虑算法的共识过程。<br>对于 raft 算法，核心共识过程是日志复制这个过程，这个过程分两个阶段，一个是日志记录，一个是提交数据。两个过程都只需要领导者发送消息给跟随者节点，跟随者节点返回消息给领导者节点即可完成，跟随者节点之间是无需沟通的。所以如果集群总节点数为 n，对于日志记录阶段，通信次数为 n-1，对于提交数据阶段，通信次数也为 n-1，总通信次数为 2n-2，因此raft算法复杂度为O（n）。<br>对于 pbft 算法，核心过程有三个阶段，分别是 pre-prepare （预准备）阶段，prepare （准备）阶段和 commit （提交）阶段。对于 pre-prepare 阶段，主节点广播 pre-prepare 消息给其它节点即可，因此通信次数为 n-1 ；对于 prepare 阶段，每个节点如果同意请求后，都需要向其它节点再 广播 parepare 消息，所以总的通信次数为 n<em>(n-1），即 n^2-n ；对于 commit 阶段，每个节点如果达到 prepared 状态后，都需要向其它节点广播 commit 消息，所以总的通信次数也为 n</em>(n-1） ，即 n^2-n 。所以总通信次数为 （n-1）+（n^2-n）+（n^2-n） ，即 2n^2-n-1 ，因此pbft算法复杂度为 O（n^2） 。</p>
<h1 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h1><h2 id="为什么需要3阶段"><a href="#为什么需要3阶段" class="headerlink" title="为什么需要3阶段"></a>为什么需要3阶段</h2><h3 id="为什么不能只有前2个阶段消息"><a href="#为什么不能只有前2个阶段消息" class="headerlink" title="为什么不能只有前2个阶段消息"></a>为什么不能只有前2个阶段消息</h3><p>这个问题的等价问题是：为什么Pre-prepare和Prepare消息，不能让非拜占庭节点达成一致？</p>
<p>Pre-prepare消息的目的是，主节点为请求m，分配了视图v和序号n，让至少f+1个非拜占庭节点对这个分配组合<code>&lt;m, v, n&gt;</code>达成一致，并且不存在<code>&lt;m&#39;, v, n&gt;</code>，即不存在有2个消息使用同一个v和n的情况。</p>
<p><strong>Prepared状态可以证明非拜占庭节点在只有请求m使用<code>&lt;v, n&gt;</code>上达成一致</strong>。主节点本身是认可<code>&lt;m, v, n&gt;</code>的，所以副本只需要收集2f个Prepare消息，而不是2f+1个Prepare消息，就可以计算出至少f个副本节点是非拜占庭节点，它们认可m使用<code>&lt;v, n&gt;</code>，并且没有另外1个消息可以使用<code>&lt;v, n&gt;</code>。</p>
<p>既然1个<code>&lt;v, n&gt;</code>只能对应1个请求m了，达到Prepared状态后，副本i执行请求m，不就达成一致了么？</p>
<p>并不能。<strong>Prepared是一个局部视角，不是全局一致</strong>，即副本i看到了非拜占庭节点认可了<code>&lt;m, v, n&gt;</code>，但整个系统包含3f+1个节点，异步的系统中，存在丢包、延时、拜占庭节点故意向部分节点发送Prepare等拜占庭行文，<strong>副本i无法确定，其他副本也达到Prepared状态。如果少于f个副本成为Prepared状态，然后执行了请求m，系统就出现了不一致。</strong></p>
<p>所以，前2个阶段的消息，并不能让非拜占庭节点达成一致。</p>
<p>如果你了解2PC或者Paxos，我相信可以更容易理解上面的描述。2PC或Paxos，第一步只是用来锁定资源，第2步才是真正去Do Action。把Pre-prepare和Prepare理解为第一步，资源是<code>&lt;v, n&gt;</code>，只有第一步是达不成一致性的。</p>
<h3 id="2个不变性"><a href="#2个不变性" class="headerlink" title="2个不变性"></a>2个不变性</h3><p>PBFT的论文提到了2个不变性，这2个不变性，<strong>用来证明PBFT如何让非拜占庭节点达成一致性</strong>。</p>
<p><strong>第1个不变性</strong>，它是由Pre-prepare和Prepare消息所共同确保的不变性：非拜占庭节点在同一个view内对请求的序号达成共识。关于这个不变性，已经在“为什么不能只有前2个阶段消息”中论述过。</p>
<p>介绍第2个不变性之前，需要介绍几个定义。</p>
<ul>
<li>Prepared状态：副本i有Pre-prepare消息（与主节点通信），且收到2f个有效的Prepare消息。副本i达到Prepared状态，可以发送Commit消息，Commit消息的内容和Prepare消息内容相同，但消息类型和数字签名是不同的，所以可以区分。</li>
<li>committed-local：副本i已经是Prepared状态，并且收到了2f+1个Commit消息。</li>
<li>committed：至少f+1个非拜占庭节点已经是Prepared状态。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110421.png" alt="img"></p>
<p><strong>第2个不变性</strong>，如果副本i是committed-local，那么一定存在committed。</p>
<p>2f+1个Commit消息，去掉最多f个拜占庭节点伪造的消息，得出至少f+1个非拜占庭节点发送了Commit消息，即至少f+1个非拜占庭节点是Prepared状态。所以第2个不变性成立。</p>
<h3 id="为什么3个阶段消息可以达成一致性"><a href="#为什么3个阶段消息可以达成一致性" class="headerlink" title="为什么3个阶段消息可以达成一致性"></a>为什么3个阶段消息可以达成一致性</h3><p>committed意味着有f+1个非拜占庭节点可以执行请求，而committed-local意味着，副本i看到了有f+1个非拜占庭节点可以执行请求，f+1个非拜占庭节点执行请求，也就达成了，让非拜占庭节点一致。</p>
<p>虽然我前面使用了2PC和Paxos做类比，但不意味着PBFT的Commit阶段就相当于，2PC和Paxos的第2步。因为2PC和Paxos处理的CFT场景，不存在拜占庭节点，它们的主节点充当了统计功能，统计有多少节点完成了第一步。PBFT中节点是存在拜占庭节点的，主节点并不是可靠(信)的，不能依赖主节点统计是否有f+1个非拜占庭节点达成了Prepared，而是每个节点各自统计，committed-local让节点看到了，系统一定可以达成一致，才去执行请求。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/35847127">共识算法之pbft与raft</a></p>
<p><a href="https://lessisbetter.site/2020/03/15/why-pbft-needs-3-phase-message/">为什么PBFT需要3个阶段消息</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>共识协议</category>
      </categories>
  </entry>
  <entry>
    <title>Paxos</title>
    <url>/blog/c20c6b6.html</url>
    <content><![CDATA[<h1 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h1><p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。主要有三类节点：<br><a id="more"></a></p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110243.jpg" alt="4990FBD6-0AFD-4C25-9FD1-3E983330C9E1"></p>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p>
<h3 id="1-Prepare-阶段"><a href="#1-Prepare-阶段" class="headerlink" title="1. Prepare 阶段"></a>1. Prepare 阶段</h3><p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110250.png" alt="1709B826-3F8D-4AC6-B7D0-1CBBBBD22174"><br>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110258.jpg" alt="91D616AF-BB7C-47C1-A5A0-EA27E44D0F5D"><br>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110305.jpg" alt="3FD2C361-8DC9-42DB-8BF9-2A7AD589FF73"></p>
<h3 id="2-Accept-阶段"><a href="#2-Accept-阶段" class="headerlink" title="2. Accept 阶段"></a>2. Accept 阶段</h3><p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110313.png" alt="81ECBC9B-E58C-4C81-8820-E5393CCA45CA"></p>
<h3 id="3-Learn-阶段"><a href="#3-Learn-阶段" class="headerlink" title="3. Learn 阶段"></a>3. Learn 阶段</h3><p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110325.jpg" alt="4AA38D03-BC1D-4610-B6F8-6B0B8E1F0607"></p>
<h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><h3 id="1-正确性"><a href="#1-正确性" class="headerlink" title="1. 正确性"></a>1. 正确性</h3><p>指只有一个提议值会生效。因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p>
<h3 id="2-可终止性"><a href="#2-可终止性" class="headerlink" title="2. 可终止性"></a>2. 可终止性</h3><p>指最后总会有一个提议生效。Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_16038125/article/details/81059609">分布式-Paxos</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>共识协议</category>
      </categories>
  </entry>
  <entry>
    <title>Raft</title>
    <url>/blog/6d9ac026.html</url>
    <content><![CDATA[<p>Raft与Paxos在私链、分布式数据库中使用。<br><a id="more"></a></p>
<h1 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h1><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>启动时都是follower状态。<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110432.png" alt="5D9C4562-02AD-48F1-9273-3DC7D66DBCB8"></p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><h4 id="election"><a href="#election" class="headerlink" title="election"></a>election</h4><p>时间在150ms到300ms之间随机选取，如果到期没有发现leader的心跳出现，就把自己的状态转换为candidate，给自己投一票，并且请求其他结点开始投票。如果接受到请求的结点在这个任期内没有投过票，就给候选人投票，并且把自己的election timeout重置。<br>一旦候选人得到大部分票选，就成为leader。</p>
<h4 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h4><p>leader以心跳周期给followers发送Append entry，直到出现新的term的leader，回到follower状态。<br>如果follower在election timeout内没有收到心跳，以候选人开启新的term，选出新的leader。</p>
<h2 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h2><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110440.png" alt="3D62AE1A-FA35-42DD-967B-9D63D11A3AD6"><br>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term 3 展示了一种情况，就是说没有选举出 leader 就结束了，然后会发起新的选举，这是平票 split vote 的情况。</p>
<h3 id="split-vote"><a href="#split-vote" class="headerlink" title="split vote"></a>split vote</h3><p>同时有多个候选人，得到了相同票数，无法选出leader。等待超时，重新发起投票。</p>
<h1 id="log-replication"><a href="#log-replication" class="headerlink" title="log replication"></a>log replication</h1><h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><p>相同的初识状态 + 相同的输入 = 相同的结束状态。<br>在 raft 中，leader 将客户端请求（command）封装到一个个 log entry，将这些 log entries 复制（replicate）到所有 follower 节点，然后大家按相同顺序应用（apply）log entry 中的 command，则状态肯定是一致的。</p>
<h2 id="请求完整流程"><a href="#请求完整流程" class="headerlink" title="请求完整流程"></a>请求完整流程</h2><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从 leader 的视角来看会经历以下步骤：</p>
<ul>
<li>leader append log entry</li>
<li>leader issue AppendEntries RPC in parallel</li>
<li>leader wait for majority response</li>
<li>leader apply entry to state machine</li>
<li>leader reply to client</li>
<li>leader notify follower apply log</li>
</ul>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="选举安全"><a href="#选举安全" class="headerlink" title="选举安全"></a>选举安全</h2><p>在 raft 中，两点保证了这个属性：</p>
<ul>
<li>一个节点某一任期内最多只能投一票；</li>
<li>只有获得 majority 投票的节点才会成为 leader。<br>任一任期内最多一个 leader 被选出。</li>
</ul>
<h2 id="log-匹配"><a href="#log-匹配" class="headerlink" title="log 匹配"></a>log 匹配</h2><p>如果两个节点上的某个 log entry 的 log index 相同且 term 相同，那么在该 index 之前的所有 log entry 应该都是相同的。<br>首先，leader 在某一 term 的任一位置只会创建一个 log entry，且 log entry 是 append-only。其次，consistency check。leader 在 AppendEntries 中包含最新 log entry 之前的一个 log 的 term 和 index，如果 follower 在对应的 term index 找不到日志，那么就会告知 leader 不一致。<br>当出现了 leader 与 follower 不一致的情况，leader 强制 follower 复制自己的 log。</p>
<ul>
<li>leader 初始化 nextIndex[x] 为 leader 最后一个 log index + 1</li>
<li>AppendEntries 里 prevLogTerm prevLogIndex 来自 logs[nextIndex[x] - 1]</li>
<li>如果 follower 判断 prevLogIndex 位置的 log term 不等于 prevLogTerm，那么返回 False，否则返回 True</li>
<li>leader 收到 follower 的回复，如果返回值是 False，则 nextIndex[x] -= 1, 跳转到 第2步. </li>
<li>否则，同步 nextIndex[x] 后的所有 log entries</li>
</ul>
<h2 id="leader完整性"><a href="#leader完整性" class="headerlink" title="leader完整性"></a>leader完整性</h2><p>leader 完整性：如果一个 log entry 在某个任期被提交（committed），那么这条日志一定会出现在所有更高 term 的 leader 的日志里面。<br>raft 与其他协议（Viewstamped Replication、mongodb）不同，raft 始终保证 leader 包含最新的已提交的日志，因此 leader 不会从 follower catchup 日志，这也大大简化了系统的复杂度。</p>
<h1 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h1><h2 id="旧leader"><a href="#旧leader" class="headerlink" title="旧leader"></a>旧leader</h2><p>raft 保证 Election safety，即一个任期内最多只有一个 leader，但在网络分割（network partition）的情况下，可能会出现两个 leader，但两个 leader 所处的任期是不同的。<br>leader 如果收不到 majority 节点的消息，那么无法进行commit。如果网络恢复了，发现有更高term的leader，会转换到follower，并且把没有commit的entry回滚，同步到新的leader。</p>
<h2 id="状态机安全"><a href="#状态机安全" class="headerlink" title="状态机安全"></a>状态机安全</h2><p>如果节点将某一位置的 log entry 应用到了状态机，那么其他节点在同一位置不能应用不同的日志。简单点来说，所有节点在同一位置（index in log entries）应该应用同样的日志。<br>某个 leader 选举成功之后，不会直接提交前任 leader 时期的日志，而是通过提交当前任期的日志的时候 “顺手” 把之前的日志也提交了，具体怎么实现了，在 log matching 部分有详细介绍。那么问题来了，如果 leader 被选举后没有收到客户端的请求呢，论文中有提到，在任期开始的时候发立即尝试复制、提交一条空的 log。</p>
<h2 id="leader-crash"><a href="#leader-crash" class="headerlink" title="leader crash"></a>leader crash</h2><p><a href="https://www.cnblogs.com/mindwind/p/5231986.html">不同情况的图解</a></p>
<h1 id="为了避免问题的设计"><a href="#为了避免问题的设计" class="headerlink" title="为了避免问题的设计"></a>为了避免问题的设计</h1><ul>
<li>避免平票：randomized election timeouts ；</li>
<li>保证majority票：节点的数目都是奇数个；</li>
<li>保证高可用：不是强一致性，而是最终一致性，leader 会不断尝试给 follower 发 log entries，直到所有节点的 log entries 都相同；</li>
</ul>
<h1 id="容错数量"><a href="#容错数量" class="headerlink" title="容错数量"></a>容错数量</h1><p>raft 算法只支持容错故障节点，假设集群总节点数为n，故障节点为 f ，根据小数服从多数的原则，集群里正常节点只需要比 f 个节点再多一个节点，即 f+1 个节点，正确节点的数量就会比故障节点数量多，那么集群就能达成共识。因此 raft 算法支持的最大容错节点数量是（n-1）/2。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/xybaby/p/10124083.html">一文搞懂Raft算法</a><br><a href="http://thesecretlivesofdata.com/raft">Raft动画</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>共识协议</category>
      </categories>
  </entry>
  <entry>
    <title>Rust之PhantomData</title>
    <url>/blog/a3f13347.html</url>
    <content><![CDATA[<p><code>PhantomData&lt;T&gt;</code>是一个零大小类型的标记结构体。<br><a id="more"></a><br>作用：</p>
<ol>
<li>并不使用的类型；</li>
<li>型变；</li>
<li>标记拥有关系；</li>
<li>自动trait实现（send/sync）；</li>
</ol>
<h1 id="并不使用的类型"><a href="#并不使用的类型" class="headerlink" title="并不使用的类型"></a>并不使用的类型</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Slice</span></span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    start: *<span class="keyword">const</span> T,</span><br><span class="line">    end: *<span class="keyword">const</span> T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，因为’a在结构体中未使用，所以它是无界的。在结构定义中禁止无限生命周期和类型。</p>
<p>修改如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Iter</span></span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    ptr: *<span class="keyword">const</span> T,</span><br><span class="line">    end: *<span class="keyword">const</span> T,</span><br><span class="line">    _marker: marker::PhantomData&lt;&amp;<span class="symbol">&#x27;a</span> T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">RetryableSendCh</span></span>&lt;T, C: Sender&lt;T&gt;&gt; &#123;</span><br><span class="line">    ch: C,</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>,</span><br><span class="line">    marker: PhantomData&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="标记拥有关系"><a href="#标记拥有关系" class="headerlink" title="标记拥有关系"></a>标记拥有关系</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec</span></span>&lt;T&gt; &#123;</span><br><span class="line">    data: *<span class="keyword">const</span> T, <span class="comment">// *const for variance!</span></span><br><span class="line">    len: <span class="built_in">usize</span>,</span><br><span class="line">    cap: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原生指针不具有所有权语义，drop检查器将认为<code>Vec&lt;T&gt;</code>不具有类型T的任何值。这将反过来使得它不需要担心Vec在其析构函数中丢弃任何<code>T</code>。但是有可能<code>T</code>被提前释放。为了drop检查器认为vec一定拥有了<code>T</code>的数据，修改如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec</span></span>&lt;T&gt; &#123;</span><br><span class="line">    data: *<span class="keyword">const</span> T, <span class="comment">// *const for variance!</span></span><br><span class="line">    len: <span class="built_in">usize</span>,</span><br><span class="line">    cap: <span class="built_in">usize</span>,</span><br><span class="line">    _marker: marker::PhantomData&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h1><ul>
<li>不变</li>
</ul>
<p>如果不能将一个类型替换为另一个类型，那么这个类型就称之为：<strong>不变</strong>。</p>
<ul>
<li>逆变</li>
</ul>
<p>可以由其基类替换。</p>
<ul>
<li>协变</li>
</ul>
<p>可以由其派生类型替换。</p>
<h2 id="PhantomData模式表"><a href="#PhantomData模式表" class="headerlink" title="PhantomData模式表"></a><code>PhantomData</code>模式表</h2><p>这是一张<code>PhantomData</code>可以使用的所有方法的表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Phantom type</th>
<th><code>&#39;a</code></th>
<th><code>T</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PhantomData&lt;T&gt;</code></td>
<td>-</td>
<td>variant (with drop check)</td>
</tr>
<tr>
<td><code>PhantomData&lt;&amp;&#39;a T&gt;</code></td>
<td>variant</td>
<td>variant</td>
</tr>
<tr>
<td><code>PhantomData&lt;&amp;&#39;a mut T&gt;</code></td>
<td>variant</td>
<td>invariant</td>
</tr>
<tr>
<td><code>PhantomData&lt;*const T&gt;</code></td>
<td>-</td>
<td>variant</td>
</tr>
<tr>
<td><code>PhantomData&lt;*mut T&gt;</code></td>
<td>-</td>
<td>invariant</td>
</tr>
<tr>
<td><code>PhantomData&lt;fn(T)&gt;</code></td>
<td>-</td>
<td>contravariant (*)</td>
</tr>
<tr>
<td><code>PhantomData&lt;fn() -&gt; T&gt;</code></td>
<td>-</td>
<td>variant</td>
</tr>
<tr>
<td><code>PhantomData&lt;fn(T) -&gt; T&gt;</code></td>
<td>-</td>
<td>invariant</td>
</tr>
<tr>
<td><code>PhantomData&lt;Cell&lt;&amp;&#39;a ()&gt;&gt;</code></td>
<td>invariant</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>(*) 如果发生变性的冲突，这个是不变的。</p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust基础</category>
      </categories>
  </entry>
  <entry>
    <title>Rust之trait</title>
    <url>/blog/35f77f38.html</url>
    <content><![CDATA[<h1 id="行为上对类型的约束"><a href="#行为上对类型的约束" class="headerlink" title="行为上对类型的约束"></a>行为上对类型的约束</h1><a id="more"></a>
<p>trait是Rust对Ad-hoc（点对点/特别的/临时的）多态的支持。</p>
<h2 id="接口抽象"><a href="#接口抽象" class="headerlink" title="接口抽象"></a>接口抽象</h2><ul>
<li>接口中可以定义方法，并支持默认实现；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">NoiseMaker</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">make_noise</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">make_alot_of_noise</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.make_noise();</span><br><span class="line">        <span class="keyword">self</span>.make_noise();</span><br><span class="line">        <span class="keyword">self</span>.make_noise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口中不能实现另一个接口，但是接口之间可以继承；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">NoiseMaker</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">make_noise</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">LoudNoiseMaker</span></span>: NoiseMaker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">make_alot_of_noise</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.make_noise();</span><br><span class="line">        <span class="keyword">self</span>.make_noise();</span><br><span class="line">        <span class="keyword">self</span>.make_noise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> NoiseMaker <span class="keyword">for</span> SeaCreature &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">make_noise</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, &amp;<span class="keyword">self</span>.get_sound());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> LoudNoiseMaker <span class="keyword">for</span> SeaCreature &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同一个接口可以同时被多个类型实现，但不能被同一个类型实现多次；</li>
</ul>
<p>为不同的类型实现trait，属于一种函数重载，也是<code>Ad-hoc</code>多态。</p>
<h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Self</code>是每个<code>trait</code>都带有的隐式类型参数，代表实现当前<code>trait</code>的具体类型。实现时，未指明泛型，默认为<code>Self</code>类型。</p>
<p><code>Output</code>为关联类型。</p>
<h4 id="为u32类型实现Add-trait"><a href="#为u32类型实现Add-trait" class="headerlink" title="为u32类型实现Add trait"></a>为u32类型实现Add trait</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> Add <span class="keyword">for</span> <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">u32</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span> </span>(<span class="keyword">self</span>, other: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="keyword">self</span> + other &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关联类型的作用"><a href="#关联类型的作用" class="headerlink" title="关联类型的作用"></a>关联类型的作用</h4><p>关联类型在trait定义中指定占位符类型。trait 的实现者会针对特定的实现在这个类型的位置指定相应的具体类型。如此可以定义一个使用多种类型的 trait。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么不像下面这样写，使用泛型？</span></span><br><span class="line"><span class="comment">// pub trait Iterator&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">//    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>使用泛型的方式，则如例子中在实现trait的时候必须带上具体的类型，调用时也必须带上具体的类型。</p>
<h3 id="孤儿规则"><a href="#孤儿规则" class="headerlink" title="孤儿规则"></a>孤儿规则</h3><p>如果要实现某个trait，那么该trait和实现该trait的那个类型至少有一个要在当前crate中定义。</p>
<p>绕开这个限制的方法是使用 newtype 模式（newtype pattern）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span></span>(<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;);</span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> Wrapper &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.join(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，我们在 Vec 上实现 Display，而孤儿规则阻止我们直接这么做，因为 Display trait 和 Vec 都定义于我们的 crate 之外。我们可以创建一个包含 Vec 实例的 Wrapper 结构体，然后再实现。</p>
<h3 id="trait继承"><a href="#trait继承" class="headerlink" title="trait继承"></a>trait继承</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Page</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_page</span></span>(&amp;<span class="keyword">self</span>, p: <span class="built_in">i32</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Page Default: 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PerPage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_perpage</span></span>(&amp;<span class="keyword">self</span>, num: <span class="built_in">i32</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Per Page Default: 10&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Paginate</span></span>: Page + PerPage&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_skip_page</span></span>(&amp;<span class="keyword">self</span>, num: <span class="built_in">i32</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Skip Page : &#123;:?&#125;&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> &lt;T: Page + PerPage&gt;Paginate <span class="keyword">for</span> T&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPaginate</span></span>&#123; page: <span class="built_in">i32</span> &#125;</span><br><span class="line"><span class="keyword">impl</span> Page <span class="keyword">for</span> MyPaginate&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> PerPage <span class="keyword">for</span> MyPaginate&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> my_paginate = MyPaginate&#123;page: <span class="number">1</span>&#125;;</span><br><span class="line">	my_paginate.set_page(<span class="number">2</span>);</span><br><span class="line">	my_paginate.set_perpage(<span class="number">100</span>);</span><br><span class="line">	my_paginate.set_skip_page(<span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>impl &lt;T: Page + PerPage&gt;Paginate for T&#123;&#125;</code> 为拥有Page和PerPage行为的类型实现Paginate。</p>
<p>使用继承，可以不影响之前的代码，加入上面这一行就可以添加新的trait。</p>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>&lt;T: Add&lt;T, Output=T&gt;&gt;(a: T, b: T) -&gt; T&#123;</span><br><span class="line"><span class="comment">// where</span></span><br><span class="line">  <span class="comment">// T: Add&lt;T, Output=T&gt;</span></span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(sum(<span class="number">1u32</span>, <span class="number">2u32</span>), <span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(sum(<span class="number">1u64</span>, <span class="number">2u64</span>), <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>约束<code>sum</code>函数，只有实现了<code>Add</code>这个trait的类型才可以当做参数。</p>
<p><code>where</code>关键字，可以把泛型中的trait限定移到语句最后。</p>
<h2 id="抽象类型"><a href="#抽象类型" class="headerlink" title="抽象类型"></a>抽象类型</h2><h3 id="trait对象"><a href="#trait对象" class="headerlink" title="trait对象"></a>trait对象</h3><p>trait的类型大小在编译期间无法确定，所以trait对象必须使用指针。可以利用引用操作符<code>&amp;</code>或<code>Box&lt;T&gt;</code>来制造一个trait对象。trait对象的结构体包含一个可变data指针和一个可变虚表指针。</p>
<p>作参数时，trait限定是静态分发的，trait对象是动态分发的。</p>
<h3 id="impl-Trait"><a href="#impl-Trait" class="headerlink" title="impl Trait"></a>impl Trait</h3><p>静态分发的抽象类型impl Trait。目前只可以在输入的参数和返回值两个位置使用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_static</span></span>(s: <span class="keyword">impl</span> Fly + <span class="built_in">Debug</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">	s.fly()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">can_fly</span></span>(s: <span class="keyword">impl</span> Fly+<span class="built_in">Debug</span>) -&gt; <span class="keyword">impl</span> Fly &#123;</span><br><span class="line">    <span class="keyword">if</span> s.fly()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>impl Trait</code>只能用于单个参数指定抽象类型。</p>
<p><code>dyn Trait</code>是与<code>impl Trait</code>相对应的动态分发。</p>
<h2 id="标签trait"><a href="#标签trait" class="headerlink" title="标签trait"></a>标签trait</h2><p>5个重要的标签：Sized（编译器可确定大小），Unsize（动态大小），Copy（可以按位复制），Send（跨线程安全通信），Sync（线程间安全共享引用）。</p>
<h1 id="trait对象的生命周期"><a href="#trait对象的生命周期" class="headerlink" title="trait对象的生命周期"></a>trait对象的生命周期</h1><ul>
<li>trait对象的生命周期默认是’static；</li>
<li>如果实现trait的类型包含&amp;’a X 或者 &amp;’a mut X，则默认生命周期是’a；</li>
<li>如果实现trait的类型只有T: ‘a，则默认生命周期是’a；</li>
<li>如果实现trait的类型包含多个类似T:’a 的从句，则生命周期需要明确指定。</li>
</ul>
<h1 id="动态分发"><a href="#动态分发" class="headerlink" title="动态分发"></a>动态分发</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Duck</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pig</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Fly</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Fly <span class="keyword">for</span> Duck &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Fly <span class="keyword">for</span> Pig &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_static</span></span>&lt;F: Fly&gt;(s: F) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    s.fly()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(s: &amp;<span class="keyword">dyn</span> Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    s.fly()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fn fly_dyn(s: &amp;impl Fly) -&gt; bool &#123;</span></span><br><span class="line"><span class="comment">//    s.fly()</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pig = Pig;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_static::&lt;Pig&gt;(pig), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">let</span> duck = Duck;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_static::&lt;Duck&gt;(duck), <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 需要推断具体类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_dyn(&amp;Pig), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_dyn(&amp;Duck), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fly_static是静态分发，fly_dyn是动态分发。Trait对象拥有实例对象方法的指针（定义在该Trait中的），类似于C++的虚函数表。</p>
<p>内存细节：动态分发会稍慢，因为要推断类型，去查找真正的函数调用。</p>
<h1 id="完全限定语法"><a href="#完全限定语法" class="headerlink" title="完全限定语法"></a>完全限定语法</h1><h2 id="同名方法"><a href="#同名方法" class="headerlink" title="同名方法"></a>同名方法</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Trait</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, x: <span class="built_in">i32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Foo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Foo::foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Trait <span class="keyword">for</span> Foo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, x: <span class="built_in">i32</span>) &#123;</span><br><span class="line">        <span class="comment">//self.foo(); 　　　//１、出错点１ (&amp;*self).foo();　按照此方式或者Self::foo(self)调用ok</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Trait::foo &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a: Foo = Foo &#123;&#125;;</span><br><span class="line">    a.foo();</span><br><span class="line">    <span class="comment">//a.foo(3); //２、出错点２，此方式调用出错 Trait::foo(&amp;mut a, 3);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust在进行方法解析的时候试用的规则比较简单，编译器查看方法“ receiver”（<code>.</code> 之前的东西，在本例中为<code>self</code>，其类型为<code>＆mut Foo</code>），并检查它是否具有称为<code>foo</code>的方法。如果没有<code>foo</code>方法，则尝试借用或取消引用接收方后，再次检查是否有此方法。编译器会一直重复此过程，直到找到匹配的方法为止。 在此例中，编译器就会匹配到<code>fn foo(&amp;mut self, x: i32)</code>方法，但是没有足够的参数，所以按照<strong>出错点１的写法会出错</strong>，正确的方式是显示地调用。<br>默认会调用<code>Foo</code>类型的<code>foo</code>方法，那么如果要调用<code>trait</code>中的方法怎么办呢？用trait名显示调用即可<code>Trait::foo(&amp;mut a, 3);</code>。</p>
<h2 id="关联函数的完全限定语法"><a href="#关联函数的完全限定语法" class="headerlink" title="关联函数的完全限定语法"></a>关联函数的完全限定语法</h2><p>当不能判断由哪个类型实现的方法来调用，需要使用完全限定语法：</p>
<p><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust基础</category>
      </categories>
  </entry>
  <entry>
    <title>Rust之多线程入门</title>
    <url>/blog/78c491e.html</url>
    <content><![CDATA[<h1 id="线程基本使用"><a href="#线程基本使用" class="headerlink" title="线程基本使用"></a>线程基本使用</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p><code>thread::spawn</code>，<code>thread::Builder::spawn</code><br><a id="more"></a><br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">           <span class="built_in">println!</span>(<span class="string">&quot;number &#123;&#125; in spawn thread!&quot;</span>, i);</span><br><span class="line">           thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = Builder::new().name(thread_name).stack_size(size);</span><br><span class="line"><span class="keyword">let</span> child = builder.spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;in child:&#123;&#125;&quot;</span>, current().name().unwrap());</span><br><span class="line">&#125;).unwrap();</span><br></pre></td></tr></table></figure></p>
<h2 id="等待线程"><a href="#等待线程" class="headerlink" title="等待线程"></a>等待线程</h2><p><code>JoinHandler&lt;()&gt;.join().unwrap()</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">handle.join().unwrap();</span><br></pre></td></tr></table></figure>
<h2 id="move闭包"><a href="#move闭包" class="headerlink" title="move闭包"></a>move闭包</h2><p>以下情况需要使用<code>move</code>：不能判断子线程执行时间，而在子线程中引用了主线程变量。</p>
<h1 id="Send-Sync"><a href="#Send-Sync" class="headerlink" title="Send,Sync"></a>Send,Sync</h1><ul>
<li>Send：实现Send的类型可以安全的在线程间传递所有权。</li>
<li>Sync：实现Sync的类型可以安全的在线程间传递不可变借用。</li>
</ul>
<p><code>spawn</code>函数的源码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">&quot;rust1&quot;</span>, since = <span class="meta-string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; <span class="keyword">where</span></span><br><span class="line">    F: <span class="built_in">FnOnce</span>() -&gt; T, F: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>, T: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span></span><br><span class="line">&#123;</span><br><span class="line">    Builder::new().spawn(f).expect(<span class="string">&quot;failed to spawn thread&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其参数F和返回值类型T都加上了<code>Send + &#39;static</code>限定，Send表示闭包必须实现Send，这样才可以在线程间传递。而<code>&#39;static</code>表示T只能是非引用类型，因为使用引用类型则无法保证生命周期。</p>
<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Rust中一个实现消息传递并发的主要工具是通道。通道由两部分组成，一个是发送端，一个是接收端，发送端用来发送消息，接收端用来接收消息。发送者或者接收者任一被丢弃时就可以认为通道被关闭了。</p>
<p>通道介绍<br>（1）通过<code>mpsc::channel</code>，创建通道，<code>mpsc</code>是多个生产者，单个消费者；mpsc：Multi-producer, single-consumer FIFO queue communication primitives.<br>（2）通过<code>spmc::channel</code>，创建通道，spmc是一个生产者，多个消费者；<br>（3）创建通道后返回的是发送者和消费者，示例：<br><code>let (tx, rx) = mpsc::channel();     let (tx, rx) = spmc::channel();</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、发送者的send方法返回的是一个<code>Result&lt;T,E&gt;</code>，如果接收端已经被丢弃了，将没有发送值的目标，此时发送会返回错误。<code>send</code>会发生<code>move</code>。<br>2、接受者的recv返回值也是一个Result类型，当通道发送端关闭时，返回一个错误值。<br>3、接收端这里使用的recv方法，会阻塞到有一个消息到来。我们也可以使用try_recv()，不会阻塞，会立即返回。</p>
<h3 id="发送多个消息"><a href="#发送多个消息" class="headerlink" title="发送多个消息"></a>发送多个消息</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> recv <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, recv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"><span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line"><span class="keyword">let</span> tx2 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line"><span class="comment">// ... 分别在各自线程中进行发送</span></span><br><span class="line"><span class="comment">// 接受</span></span><br><span class="line"><span class="keyword">for</span> rec <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, rec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><h3 id="互斥锁Mutex-lt-T-gt"><a href="#互斥锁Mutex-lt-T-gt" class="headerlink" title="互斥锁Mutex&lt;T&gt;"></a>互斥锁<code>Mutex&lt;T&gt;</code></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Mutex::new(<span class="number">5</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = m.lock().unwrap();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;<span class="comment">//离开作用域时，自动释放</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）<code>Mutex&lt;T&gt;</code>是一个智能指针，更准确的说，<code>lock</code>调用返回一个叫做<code>MutexGuard</code>的智能指针；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">&quot;rust1&quot;</span>, since = <span class="meta-string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) -&gt; LockResult&lt;MutexGuard&lt;<span class="symbol">&#x27;_</span>, T&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.inner.raw_lock();</span><br><span class="line">            MutexGuard::new(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>（2）内部提供了<code>Drop</code>方法，实现当<code>MutexGuard</code>离开作用域时自动释放锁。</p>
<h3 id="Arc-lt-T-gt"><a href="#Arc-lt-T-gt" class="headerlink" title="Arc&lt;T&gt;"></a><code>Arc&lt;T&gt;</code></h3><p><code>Arc&lt;T&gt;</code>是一个类似于<code>Rc&lt;T&gt;</code>，但是可以安全的用于并发环境的类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let counter = Mutex::new(0);  // 所有权被移动到线程闭包中，只可用一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Arc&lt;Mutex&lt;T&gt;&gt;可以组合成内部可变的线程安全指针</span></span><br><span class="line"><span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));	<span class="comment">// 多线程共享</span></span><br></pre></td></tr></table></figure>
<h1 id="简单的WebServer"><a href="#简单的WebServer" class="headerlink" title="简单的WebServer"></a>简单的WebServer</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span></span> &#123;</span><br><span class="line">    id: <span class="built_in">usize</span>,</span><br><span class="line">    thread: <span class="built_in">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Worker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(id: <span class="built_in">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> thread = thread::spawn(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> message = receiver.lock().unwrap().recv().unwrap();</span><br><span class="line">            <span class="keyword">match</span> message &#123;</span><br><span class="line">                Message::NewJob(job) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;worker &#123;&#125; receive a job&quot;</span>, id);</span><br><span class="line">                    job();</span><br><span class="line">                &#125;,</span><br><span class="line">                Message::Terminate =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; receive terminate&quot;</span>, id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123; </span><br><span class="line">            id, </span><br><span class="line">            thread: <span class="literal">Some</span>(thread), </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span> &#123;</span><br><span class="line">    workers: <span class="built_in">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Message&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Job</span></span> = <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    NewJob(Job),</span><br><span class="line">    Terminate,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="built_in">usize</span>) -&gt; ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> workers = <span class="built_in">Vec</span>::with_capacity(size);</span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::channel();</span><br><span class="line">        <span class="keyword">let</span> receiver = Arc::new(Mutex::new(receiver)); <span class="comment">//线程安全</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadPool &#123; workers, sender &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">execute</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> job = <span class="built_in">Box</span>::new(f);</span><br><span class="line">        <span class="keyword">self</span>.sender.send(Message::NewJob(job)).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> ThreadPool &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//send terminate message to all workers</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="keyword">self</span>.sender.send(Message::Terminate).unwrap();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wait all workers terminate</span></span><br><span class="line">        <span class="keyword">for</span> worker <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="comment">//wait for worker thread terminate </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(thread) = worker.thread.take() &#123;</span><br><span class="line">                thread.join().unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mylib::ThreadPool;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;thread, time&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_client</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.read(&amp;<span class="keyword">mut</span> buffer).unwrap();</span><br><span class="line">    <span class="keyword">let</span> get = <span class="string">b&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> (status_line, filename) = <span class="keyword">if</span> buffer.starts_with(get) &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>, <span class="string">&quot;main.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(filename).unwrap();</span><br><span class="line">    <span class="keyword">let</span> response = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, status_line, contents);</span><br><span class="line"></span><br><span class="line">    stream.write(response.as_bytes()).unwrap();</span><br><span class="line">    stream.flush().unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> te = time::Duration::from_millis(<span class="number">10000</span>);</span><br><span class="line">    thread::sleep(te); <span class="comment">//睡眠一段时间，模拟处理时间很长</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; std::io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">&quot;127.0.0.1:8080&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> pool = ThreadPool::new(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> stream <span class="keyword">in</span> listener.incoming().take(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> stream = stream.unwrap();</span><br><span class="line">        <span class="comment">//thread pool</span></span><br><span class="line">        pool.execute(|| handle_client(stream));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust基础</category>
      </categories>
  </entry>
  <entry>
    <title>Rust之Unsafe</title>
    <url>/blog/22fa27d4.html</url>
    <content><![CDATA[<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><a id="more"></a>
<p>Rust会通过unsafe关键字切换到不安全的Rust。不安全的Rust具有以下超级力量：<br>（1）解引用裸指针<br>（2）调用不安全的函数或者方法<br>（3）访问或修改可变静态变量<br>（4）实现不安全的trait</p>
<p>注意：unsafe并不会关闭借用检查器或禁用任何其它的Rust安全检查规则，它只提供上述几个不被编译器检查内存安全的功能。unsafe也不意味着块中的代码一定就是不ok的，它只是表示由程序员来确保安全。</p>
<h1 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h1><p>裸指针是可变和不可变的，分别写作<code>*const T</code>和<code>*mut T</code>。此处的星号不是解引用运算符，而是类型名称的一部分。<br>裸指针：<br>（1）允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针<br>（2）不保证指向有效的内存<br>（3）允许为空<br>（4）不能实现任何自动清理功能</p>
<p>可以在安全代码中创建裸指针，只是不能在不安全块之外解引用裸指针。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//创建不可变和可变的裸指针可以在安全的代码中，只是不能在不安全代码块之外解引用裸指针</span></span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r2 is: &#123;&#125;&quot;</span>, *r2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> add = <span class="number">0x12345usize</span>;</span><br><span class="line">    <span class="keyword">let</span> _r = add <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="访问可变静态变量"><a href="#访问可变静态变量" class="headerlink" title="访问可变静态变量"></a>访问可变静态变量</h1><p>常量和静态变量的区别：<br>a、静态变量中的值有一个固定的内存地址（使用这个值总会访问相同的地址），常量则允许在任何被用到的时候复制其数据。<br>b、静态变量可以是可变的，虽然这可能是不安全的（所以要用unsafe）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="built_in">u32</span> = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_counter</span></span>(inc: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    add_counter(<span class="number">3</span>);</span><br><span class="line">    add_counter(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;counter: &#123;&#125;&quot;</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不安全的trait"><a href="#不安全的trait" class="headerlink" title="不安全的trait"></a>不安全的trait</h1><p>（1）当至少有一个方法中包含编译器不能验证的不变量时，该 trait 是不安全的；<br>（2）在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe。</p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust基础</category>
      </categories>
  </entry>
  <entry>
    <title>Rust之宏入门</title>
    <url>/blog/bf56e353.html</url>
    <content><![CDATA[<h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p>整体流程：[源代码]-&gt;分词-&gt;[Tokens词条流]-&gt;解析-&gt;[AST]-&gt;语法分析，宏扩展→[高级中间语言HIR]-&gt;类型检查-&gt;[中级中间语言MIR]-&gt;转换-&gt;[LLVM IR]-&gt;LLVM-&gt;[目标文件]-&gt;链接-&gt;[可执行程序]<br><a id="more"></a></p>
<p>详细过程如下：</p>
<ol>
<li>解析输入：将<code>.rs</code>文件作为输入并进行解析生成<code>AST</code>(抽象语法树)；</li>
<li>名称解析，宏扩展和属性配置：解析完毕后处理<code>AST</code>，处理<code>#[cfg]</code>节点解析路径，扩展宏；</li>
<li>转为HIR：名称解析完毕后将AST转换为<code>HIR</code>(高级中间表示)，HIR比AST处理的更多，但是他不负责解析Rust的语法，例如<code>((1+2)+3)</code>和<code>1+2+3</code>在AST中会保留括号，虽然两者的含义相同但是会被解析成不同的树，但是在HIR中括号节点将会被删除，这两个表达式会以相同的方式表达；</li>
<li>类型检查以及后续分析：处理HIR的重要步骤就是类型检查，例如使用<code>x.f</code>时如果我们不知道<code>x</code>的类型就无法判断访问的哪个<code>f</code>字段，类型检查会创建<code>TypeckTables</code>其中包括表达式的类型，方法的解析方式；</li>
<li>转为MIR以及后置处理：完成类型检查后，将HIR转为MIR(中级中间表示)进行借用检查以及优化；</li>
<li>转为LLVM IR和优化：LLVM进行优化，从而生成许多<code>.o</code>文件；</li>
<li>链接： 最后将那些<code>.o</code>文件链接在一起。</li>
</ol>
<p>Rust在预处理时，会加入以下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(prelude_import)]</span></span><br><span class="line"><span class="meta">#[prelude_import]</span></span><br><span class="line"><span class="keyword">use</span> std::prelude::v1::*;</span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> std;</span><br></pre></td></tr></table></figure>
<p>从而自动导入标准库。</p>
<h1 id="声明宏（Declarative-Macro）"><a href="#声明宏（Declarative-Macro）" class="headerlink" title="声明宏（Declarative Macro）"></a>声明宏（Declarative Macro）</h1><p>宏解析器将宏扩展的时机在解析过程中。</p>
<p>声明宏中可以捕获的类型：</p>
<ul>
<li>item，语言项，比如模块、声明、函数定义、类型定义、结构体定义、impl实现等。</li>
<li>block，代码块，由花括号限定的代码；</li>
<li>stmt，语句，一般是指以分号结尾的代码；</li>
<li>expr，表达式，会生成具体的值；</li>
<li>pat，模式；</li>
<li>ty，类型；</li>
<li>ident，标识符；</li>
<li>path，路径，比如foo、std::iter等；</li>
<li>meta，元信息，包含在#[…]或者#![…]属性内的信息；</li>
<li>tt，TokenTree的缩写，词条树；</li>
<li>vis，可见性，比如pub；</li>
<li>lifetime，生命周期参数。</li>
</ul>
<p>词法树的范围比表达式的范围广，比如匹配一个语句块时，就必须用tt。</p>
<p>重复匹配的模式是“$(…) sep rep”，具体的说明如下：</p>
<ul>
<li>$(…)，代表要把重复匹配的模式置于其中；</li>
<li>sep，代表分隔符，常用逗号、分号和=&gt;。这个分隔符可以依据具体的情况忽略。</li>
<li>rep，代表控制重复次数的标记，目前支持两种：* 和 +，代表“重复零次及以上”和“重复一次及以上”。</li>
</ul>
<p>展开宏：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo rustc -- -Z unstable-options --pretty=expanded</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustc -Z unstable-options --pretty=expanded main.rs</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> my_vec &#123; </span><br><span class="line">  <span class="comment">// x 为重复匹配到的表达式，“，”可以根据情况忽略</span></span><br><span class="line">    ($($x: expr), *) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">          <span class="comment">// 重复匹配到的值在这里访问</span></span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashmap实现"><a href="#hashmap实现" class="headerlink" title="hashmap实现"></a>hashmap实现</h2><h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> hashmap &#123;</span><br><span class="line">  <span class="comment">// 利用递归调用消去最后键值对的结尾逗号</span></span><br><span class="line">  <span class="comment">// 如果是末尾仍有逗号的，会转换成($($key:expr =&gt; $value:expr),*)</span></span><br><span class="line">    ($($key:expr =&gt; $value:expr,)*) =&gt;</span><br><span class="line">        &#123;  hashmap!($($key =&gt; $value),*) &#125;;</span><br><span class="line">    ($($key:expr =&gt; $value:expr),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> _map = ::std::collections::HashMap::new();</span><br><span class="line">            $(</span><br><span class="line">                _map.insert($key, $value);</span><br><span class="line">            )*</span><br><span class="line">           _map</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> map = hashmap!&#123;</span><br><span class="line">        <span class="string">&quot;a&quot;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;b&quot;</span> =&gt; <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;c&quot;</span> =&gt; <span class="number">3</span>, </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(map[<span class="string">&quot;a&quot;</span>], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一层转换为<code>hashmap ! (&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3)</code>。</p>
<h3 id="重复匹配规则"><a href="#重复匹配规则" class="headerlink" title="重复匹配规则"></a>重复匹配规则</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> hashmap &#123;</span><br><span class="line">    ($($key:expr =&gt; $value:expr),* $(,)*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> _map = ::std::collections::HashMap::new();</span><br><span class="line">            $(</span><br><span class="line">                _map.insert($key, $value);</span><br><span class="line">            )*</span><br><span class="line">            _map</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> map = hashmap!&#123;</span><br><span class="line">        <span class="string">&quot;a&quot;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;b&quot;</span> =&gt; <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;c&quot;</span> =&gt; <span class="number">3</span>, </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(map[<span class="string">&quot;a&quot;</span>], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预分配空间"><a href="#预分配空间" class="headerlink" title="预分配空间"></a>预分配空间</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> unit &#123;</span><br><span class="line">    ($($x:tt)*) =&gt; (());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">macro_rules!</span> count &#123;</span><br><span class="line">    ($($key:expr),*) =&gt; (&lt;[()]&gt;::len(&amp;[$(unit!($key)),*]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">macro_rules!</span> hashmap &#123;</span><br><span class="line">    ($($key:expr =&gt; $value:expr),* $(,)*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">let</span> _cap = count!($($key),*);</span><br><span class="line">           <span class="keyword">let</span> <span class="keyword">mut</span> _map </span><br><span class="line">               = ::std::collections::HashMap::with_capacity(_cap);</span><br><span class="line">           $(</span><br><span class="line">               _map.insert($key, $value);</span><br><span class="line">           )*</span><br><span class="line">           _map</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消除外部宏"><a href="#消除外部宏" class="headerlink" title="消除外部宏"></a>消除外部宏</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(trace_macros)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> hashmap &#123;</span><br><span class="line">    (@unit $($x:tt)*) =&gt; (());</span><br><span class="line">    (@count $($rest:expr),*) =&gt; </span><br><span class="line">        (&lt;[()]&gt;::len(&amp;[$(hashmap!(@unit $rest)),*]));</span><br><span class="line">    ($($key:expr =&gt; $value:expr),* $(,)*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> _cap = hashmap!(@count $($key),*);</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> _map = </span><br><span class="line">                ::std::collections::HashMap::with_capacity(_cap);</span><br><span class="line">           $(</span><br><span class="line">               _map.insert($key, $value);</span><br><span class="line">           )*</span><br><span class="line">           _map</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">   trace_macros!(<span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">let</span> map = hashmap!&#123;</span><br><span class="line">       <span class="string">&quot;a&quot;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">       <span class="string">&quot;b&quot;</span> =&gt; <span class="number">2</span>,</span><br><span class="line">       <span class="string">&quot;c&quot;</span> =&gt; <span class="number">3</span>, </span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">assert_eq!</span>(map[<span class="string">&quot;a&quot;</span>], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#![feature(trace_macros)]</code>在nightly版本下可以跟踪宏展开，在需要展开宏的地方使用<code>trace_macros!(true);</code>打开跟踪。</p>
<h2 id="导入-导出"><a href="#导入-导出" class="headerlink" title="导入/导出"></a>导入/导出</h2><p><code>#[macro_export]</code>表示下面的宏定义对其他包也是可见的。<code>#[macro_use]</code>可以导入宏。</p>
<p>在宏定义中使用<code>$crate</code>，可以在被导出时，让编译器根据上下文推断包名，避免依赖问题。</p>
<h1 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h1><p>过程宏的Cargo.toml中，设置lib类型：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc_macro</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义派生属性"><a href="#自定义派生属性" class="headerlink" title="自定义派生属性"></a>自定义派生属性</h2><p>derive属性，自动为结构体或枚举类型进行语法扩展。可以使用TDD（测试驱动开发）的方式来开发。</p>
<p>包结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-Cargo.toml</span><br><span class="line">|-src</span><br><span class="line">   	|- lib.rs</span><br><span class="line">|-tests</span><br><span class="line">	|- test.rs</span><br></pre></td></tr></table></figure>
<p>先写test.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> my_proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(A)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span>;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_derive_a</span></span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;hello from impl A&quot;</span>.to_string(), A.a());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> self::proc_macro::TokenStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义派生属性</span></span><br><span class="line"><span class="meta">#[proc_macro_derive(A)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">derive</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> _input = input.to_string();</span><br><span class="line">    <span class="built_in">assert!</span>(_input.contains(<span class="string">&quot;struct A;&quot;</span>));</span><br><span class="line">    r#<span class="string">&quot;</span></span><br><span class="line"><span class="string">        impl A &#123;</span></span><br><span class="line"><span class="string">            fn a(&amp;self) -&gt; String&#123;</span></span><br><span class="line"><span class="string">               format!(&quot;</span>hello from <span class="keyword">impl</span> A<span class="string">&quot;)</span></span><br><span class="line"><span class="string">           &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">   &quot;</span>#.parse().unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><p>可以说自定义派生属性是自定义属性的特例。例如条件编译属性<code>#[cfg()]</code>和测试属性<code>#[test]</code>都是自定义属性。</p>
<p>test.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> my_proc_macro::attr_with_args;</span><br><span class="line"><span class="meta">#[attr_with_args(<span class="meta-string">&quot;Hello, Rust!&quot;</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>()&#123;&#125;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_foo</span></span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(foo(), <span class="string">&quot;Hello, Rust!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> self::proc_macro::TokenStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">attr_with_args</span></span>(args: TokenStream, input: TokenStream)</span><br><span class="line">                      -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> args = args.to_string();</span><br><span class="line">    <span class="keyword">let</span> _input = input.to_string();</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;fn foo() -&gt; &amp;&#x27;static str &#123;% raw %&#125;&#123;&#123; &#123;&#125; &#125;&#125;&#123;% endraw %&#125;&quot;</span>, args)</span><br><span class="line">        .parse().unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在引号的括号要用<code>{{ {} }}</code>转义，最内部的<code>&#123;&#125;</code>是给<code>args</code>占位的。</p>
<h2 id="Bang宏-类函数宏"><a href="#Bang宏-类函数宏" class="headerlink" title="Bang宏/类函数宏"></a>Bang宏/类函数宏</h2><p>test.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(proc_macro_hygiene)]</span></span><br><span class="line"><span class="keyword">use</span> my_proc_macro::hashmap;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_hashmap</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> hm = hashmap!&#123; <span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>,&#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(hm[<span class="string">&quot;a&quot;</span>],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> hm = hashmap!&#123;<span class="string">&quot;a&quot;</span>=&gt;<span class="number">1</span>,<span class="string">&quot;b&quot;</span>=&gt;<span class="number">2</span>,<span class="string">&quot;c&quot;</span>=&gt;<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(hm[<span class="string">&quot;c&quot;</span>],<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hashmap</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="comment">// 转换input为字符串</span></span><br><span class="line">    <span class="keyword">let</span> _input = input.to_string();</span><br><span class="line">    <span class="comment">// 将input字符串结尾的逗号去掉，否则在下面迭代中将报错</span></span><br><span class="line">    <span class="keyword">let</span> input = _input.trim_end_matches(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="comment">// 用split将字符串分割为slice，然后用map去处理</span></span><br><span class="line">    <span class="comment">// 为了支持「&quot;a&quot; : 1」或 「&quot;a&quot; =&gt; 1」这样的语法</span></span><br><span class="line">    <span class="keyword">let</span> input: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = input.split(<span class="string">&quot;,&quot;</span>).map(|n| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> data = <span class="keyword">if</span> n.contains(<span class="string">&quot;:&quot;</span>) &#123;  n.split(<span class="string">&quot;:&quot;</span>) &#125;</span><br><span class="line">                       <span class="keyword">else</span> &#123; n.split(<span class="string">&quot; =&gt; &quot;</span>) &#125;;</span><br><span class="line">        <span class="keyword">let</span> (key, value) =</span><br><span class="line">           (data.next().unwrap(), data.next().unwrap());</span><br><span class="line">       <span class="built_in">format!</span>(<span class="string">&quot;hm.insert(&#123;&#125;, &#123;&#125;)&quot;</span>, key, value)</span><br><span class="line">    &#125;).collect();</span><br><span class="line">    <span class="keyword">let</span> count: <span class="built_in">usize</span> = input.len();</span><br><span class="line">    <span class="keyword">let</span> tokens = <span class="built_in">format!</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#123;% raw %&#125;&#123;&#123;</span></span><br><span class="line"><span class="string">        let mut hm =</span></span><br><span class="line"><span class="string">            ::std::collections::HashMap::with_capacity(&#123;&#125;);</span></span><br><span class="line"><span class="string">            &#123;&#125;</span></span><br><span class="line"><span class="string">            hm</span></span><br><span class="line"><span class="string">        &#125;&#125;&#123;% endraw %&#125;&quot;</span>, count,</span><br><span class="line">        input.iter().map(|n| <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;;&quot;</span>, n)).collect::&lt;<span class="built_in">String</span>&gt;()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// parse函数会将字符串转为Result&lt;TokenStream&gt;</span></span><br><span class="line">    tokens.parse().unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h2><p>使用<code>syn</code>,<code>quote</code>和<code>proc_macro</code>可以实现自定义派生属性功能。</p>
<p>以下代码实现了派生属性<code>New</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> &#123;</span><br><span class="line">    syn::&#123;Token, DeriveInput, parse_macro_input&#125;,</span><br><span class="line">    quote::*,</span><br><span class="line">    proc_macro2,</span><br><span class="line">    self::proc_macro::TokenStream,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(New)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">derive</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> ast = parse_macro_input!(input <span class="keyword">as</span> DeriveInput);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">match</span> ast.data &#123;</span><br><span class="line">        syn::Data::Struct(<span class="keyword">ref</span> s) =&gt; new_for_struct(&amp;ast, &amp;s.fields),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;doesn&#x27;t work with unions yet&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    result.into()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new_for_struct</span></span>(ast: &amp;syn::DeriveInput,fields: &amp;syn::Fields) -&gt; proc_macro2::TokenStream</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">match</span> *fields &#123;</span><br><span class="line">        syn::Fields::Named(<span class="keyword">ref</span> fields) =&gt; &#123;</span><br><span class="line">            new_impl(&amp;ast, <span class="literal">Some</span>(&amp;fields.named), <span class="literal">true</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        syn::Fields::Unit =&gt; &#123;</span><br><span class="line">            new_impl(&amp;ast, <span class="literal">None</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        syn::Fields::Unnamed(<span class="keyword">ref</span> fields) =&gt; &#123;</span><br><span class="line">            new_impl(&amp;ast, <span class="literal">Some</span>(&amp;fields.unnamed), <span class="literal">false</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new_impl</span></span>(ast: &amp;syn::DeriveInput,</span><br><span class="line">            fields: <span class="built_in">Option</span>&lt;&amp;syn::punctuated::Punctuated&lt;syn::Field, Token![,]&gt;&gt;,</span><br><span class="line">            named: <span class="built_in">bool</span>) -&gt; proc_macro2::TokenStream</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> struct_name = &amp;ast.ident;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> unit = fields.is_none();</span><br><span class="line">    <span class="keyword">let</span> empty = <span class="built_in">Default</span>::default();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fields: <span class="built_in">Vec</span>&lt;_&gt; = fields.unwrap_or(&amp;empty)</span><br><span class="line">        .iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .map(|(i, f)| FieldExt::new(f, i, named)).collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> args = fields.iter().map(|f| f.as_arg());</span><br><span class="line">    <span class="keyword">let</span> inits = fields.iter().map(|f| f.as_init());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> inits = <span class="keyword">if</span> unit &#123;</span><br><span class="line">        quote!()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> named &#123;</span><br><span class="line">        quote![ &#123; #(#inits),* &#125; ]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quote![ ( #(#inits),* ) ]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl();</span><br><span class="line">    <span class="keyword">let</span> (new, doc) = (</span><br><span class="line">        syn::Ident::new(<span class="string">&quot;new&quot;</span>, proc_macro2::Span::call_site()),</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;Constructs a new `&#123;&#125;`.&quot;</span>, struct_name)</span><br><span class="line">    );</span><br><span class="line">    quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> #impl_generics #struct_name #ty_generics #where_clause &#123;</span><br><span class="line">            <span class="meta">#[doc = #doc]</span></span><br><span class="line">            <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> #<span class="title">new</span></span>(#(#args),*) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">                #struct_name #inits</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FieldExt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    ty: &amp;<span class="symbol">&#x27;a</span> syn::Type,</span><br><span class="line">    ident: syn::Ident,</span><br><span class="line">    named: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; FieldExt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(field: &amp;<span class="symbol">&#x27;a</span> syn::Field, idx: <span class="built_in">usize</span>, named: <span class="built_in">bool</span>) -&gt; FieldExt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        FieldExt &#123;</span><br><span class="line">            ty: &amp;field.ty,</span><br><span class="line">            ident: <span class="keyword">if</span> named &#123;</span><br><span class="line">                field.ident.clone().unwrap()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                syn::Ident::new(&amp;<span class="built_in">format!</span>(<span class="string">&quot;f&#123;&#125;&quot;</span>, idx), proc_macro2::Span::call_site())</span><br><span class="line">            &#125;,</span><br><span class="line">            named: named,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_arg</span></span>(&amp;<span class="keyword">self</span>) -&gt; proc_macro2::TokenStream &#123;</span><br><span class="line">        <span class="keyword">let</span> f_name = &amp;<span class="keyword">self</span>.ident;</span><br><span class="line">        <span class="keyword">let</span> ty = &amp;<span class="keyword">self</span>.ty;</span><br><span class="line">        quote!(#f_name: #ty)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_init</span></span>(&amp;<span class="keyword">self</span>) -&gt; proc_macro2::TokenStream &#123;</span><br><span class="line">        <span class="keyword">let</span> f_name = &amp;<span class="keyword">self</span>.ident;</span><br><span class="line">        <span class="keyword">let</span> init =  quote!(#f_name);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.named &#123;</span><br><span class="line">            quote!(#f_name: #init)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quote!(#init)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_41698827/article/details/104055493">使用Rust开发编译系统(C以及Rust编译的过程)</a></p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust基础</category>
      </categories>
  </entry>
  <entry>
    <title>Rust包管理</title>
    <url>/blog/484acaf.html</url>
    <content><![CDATA[<h1 id="包管理（Cargo）"><a href="#包管理（Cargo）" class="headerlink" title="包管理（Cargo）"></a>包管理（Cargo）</h1><h2 id="cargo-命令创建包"><a href="#cargo-命令创建包" class="headerlink" title="cargo 命令创建包"></a>cargo 命令创建包</h2><p><code>cargo new xxx --lib</code> 创建一个名为xxx的包；<br><a id="more"></a><br><code>cargo new xxx</code> 或者 <code>cargo new xxx --bin</code> 创建一个名为xxx的可被编译为可执行文件的包。</p>
<h2 id="使用第三方包"><a href="#使用第三方包" class="headerlink" title="使用第三方包"></a>使用第三方包</h2><ol>
<li>在<code>Cargo.toml</code>中的<code>[dependencies]</code>下加入包的依赖；</li>
<li>在需要引入的文件头部加入<code>extern crate</code> 包名; 之后才可以<code>use</code> 包（<code>Rust 2015</code>）。在<code>2018</code>中，直接可以用<code>use xxx</code>。</li>
</ol>
<p>Note：<code>Cargo</code>默认把连字符替换为下划线。</p>
<h2 id="Cargo文件格式"><a href="#Cargo文件格式" class="headerlink" title="Cargo文件格式"></a>Cargo文件格式</h2><h3 id="package-表配置"><a href="#package-表配置" class="headerlink" title="[package]表配置"></a>[package]表配置</h3><p>描述的都是与包相关的元数据，比如包名，作者等。数组使用[]，多段文字使用”””。</p>
<p><code>build = &quot;buidl.rs&quot;</code> 指定构建脚本； <code>workspace = &quot;..&quot;</code> 指定工作空间为父目录。</p>
<h3 id="badges-表配置"><a href="#badges-表配置" class="headerlink" title="[badges]表配置"></a>[badges]表配置</h3><p>云端的持续集成服务。</p>
<h3 id="workspace-表配置"><a href="#workspace-表配置" class="headerlink" title="[workspace]表配置"></a>[workspace]表配置</h3><p><code>members = [&quot;bench&quot;, &quot;regex-capi&quot;]</code>    指定子包。</p>
<h3 id="dependencies-表配置"><a href="#dependencies-表配置" class="headerlink" title="[dependencies]表配置"></a>[dependencies]表配置</h3><p>配置依赖文件。</p>
<h3 id="features-表配置"><a href="#features-表配置" class="headerlink" title="[features]表配置"></a>[features]表配置</h3><p>条件编译功能相关。在代码中对应<code>#[cfg(featrue = &quot;xxx&quot;)]</code>。</p>
<h3 id="lib-表配置"><a href="#lib-表配置" class="headerlink" title="[lib]表配置"></a>[lib]表配置</h3><p>表示最终编译目标库的信息：name，crate-type， path， test， bench等。</p>
<h3 id="test-表配置"><a href="#test-表配置" class="headerlink" title="[ [test] ]表配置"></a>[ [test] ]表配置</h3><p>用两个中括号，表示数组。</p>
<h3 id="profile-表配置"><a href="#profile-表配置" class="headerlink" title="[profile]表配置"></a>[profile]表配置</h3><p>自定义rustc编译配置。</p>
<h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><p>如果存在与文件名同名的目录，则该目录下的模块都是该文件的子模块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110452.png" alt="1"></p>
<p><code>read_func.rs</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> static_kv;  <span class="comment">//pub关键字使得可以在main.rs中：use read_func::static_kv</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_kv</span> </span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">rw_mut_kv</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust会通过<code>mod</code>关键字去当前模块的子模块中寻找<code>static_kv</code>模块。模块名字可以被以下表述：1.模块名.rs；2.与模块名相同的文件夹，并且该文件夹包含<code>mod.rs</code>。</p>
<p><code>read_func/static_kv.rs</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::sync::RwLock;</span><br></pre></td></tr></table></figure>
<p><code>main.rs</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> read_func;</span><br><span class="line"><span class="keyword">use</span> crate::read_func::&#123;read_kv , rw_mut_kv&#125;;	<span class="comment">//因为之前声明了pub</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行mod引入模块。</p>
<p>第二行的<code>crate</code>可以用<code>self</code>代替，代表当前的<code>crate</code>，以<code>main.rs</code>为起点寻找当前相对路径下的<code>read_func</code>模块。如果是第三方包，就不需要写<code>crate</code>前缀。</p>
<h2 id="模块间的关系"><a href="#模块间的关系" class="headerlink" title="模块间的关系"></a>模块间的关系</h2><h3 id="模块嵌套"><a href="#模块嵌套" class="headerlink" title="模块嵌套"></a>模块嵌套</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;</span><br><span class="line">    <span class="keyword">mod</span> instrument &#123;</span><br><span class="line">        <span class="keyword">mod</span> woodwind &#123;</span><br><span class="line">            <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">                <span class="comment">// 函数体</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mod</span> voice &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树形结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crate</span><br><span class="line">└── sound</span><br><span class="line">    ├── instrument</span><br><span class="line">    │   └── woodwind</span><br><span class="line">    └── voice</span><br></pre></td></tr></table></figure>
<p>私有性规则有如下：</p>
<ul>
<li>所有项（函数、方法、结构体、枚举、模块和常量）默认是私有的。</li>
<li>可以使用 pub 关键字使项变为公有。</li>
<li>不允许使用定义于当前模块的子模块中的私有代码。</li>
<li>允许使用任何定义于父模块或当前模块中的代码。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> instrument &#123;    <span class="comment">//加上Pub后可用路径访问instrument</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;    <span class="comment">//加上pub后可以用该函数</span></span><br><span class="line">            <span class="comment">// 函数体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::sound::instrument::clarinet();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    sound::instrument::clarinet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <strong><em>super</em></strong> 开头来构建相对路径。这么做类似于文件系统中以 .. 开头：该路径从 <strong>父</strong> 模块开始而不是当前模块。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> instrument &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">        super::breathe_in();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">breathe_in</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clarinet</code>函数位于<code>instrument</code> 模块中，所以可以使用 <code>super</code> 进入 <code>instrument</code> 的父模块，也就是根 <code>crate</code>。从这里可以找到 <code>breathe_in</code>。使用<code>super</code>相对路径可以方便的进行扩展，而不用更改路径来调用。</p>
<p><code>sound</code>模块放入<code>sound.rs</code>文件中，调用方式不变。</p>
<h3 id="重新导出"><a href="#重新导出" class="headerlink" title="重新导出"></a>重新导出</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::sound::instrument;</span><br></pre></td></tr></table></figure>
<p>可以简化外部调用的导出路径（外部调用：<code>use xxx::instrument;</code>），也不需要对外暴露模块（<code>sound</code>）。</p>
<p>一般重新导出放在<code>lib.rs</code>中。<code>main.rs</code>结合<code>lib.rs</code>的形式，是二进制包的最佳实践。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> outer_mod &#123;</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">self</span>) <span class="function"><span class="keyword">fn</span> <span class="title">outer_mod_fn</span></span>() &#123;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> inner_mod &#123;</span><br><span class="line">        <span class="comment">// 在Rust 2018 edtion 模块系统必须使用use导入</span></span><br><span class="line">        <span class="keyword">use</span> crate::outer_mod::outer_mod_fn;</span><br><span class="line">        <span class="comment">// 对外层模块 `outer_mod` 可见</span></span><br><span class="line">        <span class="keyword">pub</span>(<span class="keyword">in</span> crate::outer_mod)  <span class="function"><span class="keyword">fn</span> <span class="title">outer_mod_visible_fn</span></span>() &#123;&#125;</span><br><span class="line">        <span class="comment">// 对整个crate可见</span></span><br><span class="line">        <span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="function"><span class="keyword">fn</span> <span class="title">crate_visible_fn</span></span>() &#123;&#125;</span><br><span class="line">        <span class="comment">// `outer_mod` 内部可见</span></span><br><span class="line">        <span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="function"><span class="keyword">fn</span> <span class="title">super_mod_visible_fn</span></span>() &#123;</span><br><span class="line">            <span class="comment">// 访问同一模块的函数</span></span><br><span class="line">            inner_mod_visible_fn();</span><br><span class="line">            <span class="comment">// 使用use导入了outer_mod</span></span><br><span class="line">            outer_mod_fn();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仅在`inner_mod`可见</span></span><br><span class="line">        <span class="keyword">pub</span>(<span class="keyword">self</span>) <span class="function"><span class="keyword">fn</span> <span class="title">inner_mod_visible_fn</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() &#123;</span><br><span class="line">        inner_mod::outer_mod_visible_fn();</span><br><span class="line">        inner_mod::crate_visible_fn();</span><br><span class="line">        inner_mod::super_mod_visible_fn();</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 不能使用inner_mod 的私有函数</span></span><br><span class="line">        <span class="comment">// inner_mod::inner_mod_visible_fn();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">bar</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 该函数对整个crate可见</span></span><br><span class="line">    outer_mod::inner_mod::crate_visible_fn();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 该函数只对outer_mod可见</span></span><br><span class="line">    <span class="comment">// outer_mod::inner_mod::super_mod_visible_fn();</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 该函数只对outer_mod可见</span></span><br><span class="line">    <span class="comment">// outer_mod::inner_mod::outer_mod_visible_fn();</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 通过foo函数调用内部细节</span></span><br><span class="line">    outer_mod::foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; bar() &#125;</span><br></pre></td></tr></table></figure>
<p>关于pub：</p>
<ul>
<li>如果不显示使用pub，则函数或者模块可见性默认为私有的；</li>
<li>pub，可以对外暴露公共接口；</li>
<li>pub(crate)，对整个crate可见；</li>
<li>pub(in Path)，其中Path是模块路径，表示可以通过此Path路径来限定可见范围；</li>
<li>pub(self) / pub(in self)，只限当前模块可见；</li>
<li>pub(super) / pub(in super)，当前模块和父模块中可见。</li>
</ul>
<p><em>Note</em>：trait中关联类型和Enum中变体的可见性，会随着trait和Enum的可见性而变化。但是结构体中的字段需要单独使用pub来改变可见性。</p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust基础</category>
      </categories>
  </entry>
  <entry>
    <title>Rust模式</title>
    <url>/blog/3164e534.html</url>
    <content><![CDATA[<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>模式由如下内容组成：<br><a id="more"></a><br>（1）字面值<br>（2）解构的数组、枚举、结构体或者元组<br>（3）变量<br>（4）通配符<br>（5）占位符</p>
<p>可能用到模式的位置：</p>
<ul>
<li>match</li>
<li>if let</li>
<li>while let</li>
<li>for</li>
<li>let </li>
<li>函数参数</li>
</ul>
<h1 id="反驳"><a href="#反驳" class="headerlink" title="反驳"></a>反驳</h1><p>模式有两种：refutable（可反驳的）和 irrefutable（不可反驳的）。能匹配任何传递的可能值的模式被称为是不可反驳的。对值进行匹配可能会失败的模式被称为可反驳的。</p>
<p>不可反驳的：函数、let语句、for循环。原因：因为通过不匹配的值程序无法进行有意义的工作。</p>
<p>if let和while let表达式被限制为只能接受可反驳的模式，因为它们的定义就是为了处理有可能失败的条件。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><ul>
<li><p>匹配字面值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配命名变量</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> y = <span class="number">10</span>;  <span class="comment">//1处</span></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="literal">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">    <span class="literal">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y), <span class="comment">//此处的y和上面1处的y不一样，此处是引入的变量y覆盖之前的y</span></span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个模式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;j&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;early ASCII letter&quot;</span>),</span><br><span class="line">    <span class="string">&#x27;k&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;late ASCII letter&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><ul>
<li><p>结构体</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> Point &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">   <span class="comment">//let Point &#123; x, y &#125; = p;   //创建了同名的变量，可以简写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举</p>
</li>
<li><p>元组</p>
</li>
</ul>
<h2 id="忽略"><a href="#忽略" class="headerlink" title="忽略"></a>忽略</h2><ul>
<li>使用<code>_</code>忽略整个值或部分值；</li>
<li>用<code>..</code>忽略剩余值，必须是无歧义的（一般只用一个）。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>匹配守卫：匹配守卫是一个指定于match分支模式之后的额外的if条件，它必须满足才能选择此分支。</p>
</li>
<li><p>绑定：<code>@</code>运算符允许我们在创建一个存放值的变量，并且测试这个变量的值是否匹配模式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;  <span class="comment">//创建id_variable 存放id的值，同时测试值是否在3到7的范围</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)</span><br><span class="line">    &#125;,</span><br><span class="line">  _ =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust基础</category>
      </categories>
  </entry>
  <entry>
    <title>Spring_MongDB</title>
    <url>/blog/bdd23c8d.html</url>
    <content><![CDATA[<h1 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h1><h2 id="a-set"><a href="#a-set" class="headerlink" title="a. set"></a>a. set</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = <span class="keyword">new</span> Query(Criteria.where(<span class="string">&quot;_id&quot;</span>).is(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">Update update = <span class="keyword">new</span> Update().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;munan&quot;</span>);</span><br><span class="line">mongoTemplate.updateFirst(query, update, COLLECTION_NAME);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>set</code>：修改指定属性为指定数据；<br><code>updateFirst</code>：修改根据query查找到的第一个实体对象。</p>
<h2 id="b-数字相关"><a href="#b-数字相关" class="headerlink" title="b. 数字相关"></a>b. 数字相关</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字增加或者减少</span></span><br><span class="line">Update newCount = <span class="keyword">new</span> Update().inc(<span class="string">&quot;count&quot;</span>, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较修改</span></span><br><span class="line">Update max = <span class="keyword">new</span> Update().max(<span class="string">&quot;num&quot;</span>, <span class="number">10</span>);	<span class="comment">// 更新为num和10中较大的数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘除</span></span><br><span class="line">Update multi = <span class="keyword">new</span> Update().multiply(<span class="string">&quot;num&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="c-日期"><a href="#c-日期" class="headerlink" title="c. 日期"></a>c. 日期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Update date = <span class="keyword">new</span> Update().currentData(<span class="string">&quot;date&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="2-field"><a href="#2-field" class="headerlink" title="2. field"></a>2. field</h1><h2 id="a-rename"><a href="#a-rename" class="headerlink" title="a. rename"></a>a. rename</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Update update = <span class="keyword">new</span> Update().rename(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;new_name&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果<code>name</code>属性不存在，则不会发生更新。</p>
<h2 id="b-增加"><a href="#b-增加" class="headerlink" title="b. 增加"></a>b. 增加</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Update update = <span class="keyword">new</span> Update().set(<span class="string">&quot;new_field&quot;</span>, <span class="string">&quot;new_field&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>新增一个字段，使用set可以完成。</p>
<p>当对一个不存在的文档进行更新field时候，可以用<code>setOnInsert</code>，若文档已经存在，则不会更新。</p>
<h1 id="3-Array-List-Set"><a href="#3-Array-List-Set" class="headerlink" title="3. Array/List/Set"></a>3. Array/List/Set</h1><p>在mongodb中都转换为数组。</p>
<h2 id="a-添加"><a href="#a-添加" class="headerlink" title="a. 添加"></a>a. 添加</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Update update = <span class="keyword">new</span> Update().addToset(<span class="string">&quot;new_element&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">update = <span class="keyword">new</span> Update().push(<span class="string">&quot;new_element&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>addToSet</code>：不可以对已经存在的字段进行插入，即将数组当作Set类型处理；在后面加上each()，能够批量添加；</p>
<p><code>push</code>：允许重复。</p>
<h2 id="b-删除"><a href="#b-删除" class="headerlink" title="b. 删除"></a>b. 删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Update update = <span class="keyword">new</span> Update().pull(<span class="string">&quot;del&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="c-修改"><a href="#c-修改" class="headerlink" title="c. 修改"></a>c. 修改</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Update update = <span class="keyword">new</span> Update().set(<span class="string">&quot;array.1&quot;</span>, <span class="number">10L</span>);</span><br></pre></td></tr></table></figure>
<p>对数组array的index为1的元素修改为<code>long</code> 10。</p>
<h1 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h1><h2 id="a-使用同一个Update"><a href="#a-使用同一个Update" class="headerlink" title="a. 使用同一个Update"></a>a. 使用同一个Update</h2><p>需要确保该Update内没有冲突的更新实体对象，即同一个update不能对实体的同一个属性进行多次修改。</p>
<h2 id="b-使用同一个Criteria"><a href="#b-使用同一个Criteria" class="headerlink" title="b.  使用同一个Criteria"></a>b.  使用同一个Criteria</h2><p>对同一个Criteria附加chain的操作时，要注意and()等会改变原先Criteria，即在操作中是深拷贝参数的。在拼接Criteria时尽量使用new Criteria().xxx()。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>clion远程调试rust</title>
    <url>/blog/75283104.html</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>在CLion下远程调试Rust代码。<br><a id="more"></a></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>本地Mac OS，远程Ubuntu。</li>
<li>IDE：CLion2019.3.4</li>
</ul>
<h1 id="机器设置"><a href="#机器设置" class="headerlink" title="机器设置"></a>机器设置</h1><h2 id="远程端"><a href="#远程端" class="headerlink" title="远程端"></a>远程端</h2><p>需要打开端口ssh的TCP 22，gdbserver的TCP 2345。</p>
<p>需要安装rust与gdb。</p>
<h2 id="本地端"><a href="#本地端" class="headerlink" title="本地端"></a>本地端</h2><p>安装好Clion，rust插件与rust。</p>
<h3 id="CLion配置"><a href="#CLion配置" class="headerlink" title="CLion配置"></a>CLion配置</h3><ol>
<li>Tools -&gt; Deployment -&gt; Configuration</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105330.png" alt="image-20200907102258454"></p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105403.png" alt="image-20200907102510024"></p>
<ol>
<li>在Mapppings中添加映射。<ol>
<li>添加代码文件夹的映射；</li>
<li>添加本地target_remote 到 远程target的映射，为了让Linux的target文件与本地Mac OS的target文件区分开。所以，还需要在Excluded Paths中，把本地的target文件夹排除掉。</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105417.png" alt="image-20200907103320500"></p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105426.png" alt="image-20200907103404223"></p>
<ol>
<li>上传代码文件，在项目的根目录点击右键，然后上传</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105437.png" alt="image-20200907103748150"></p>
<h2 id="在远程端编译"><a href="#在远程端编译" class="headerlink" title="在远程端编译"></a>在远程端编译</h2><ul>
<li><code>cargo build</code>生成target文件夹。</li>
<li>开启gdbserver，例如：<code>gdbserver 0.0.0.0:2345 ./target/debug/cita-executor</code>。</li>
<li>本地同步远程端，把target文件夹下载到本地的target_remote文件夹。<ul>
<li><strong>Tools→Deployment→Browse Remote Host</strong>，找到target文件夹，右键选择Dowanload from here。</li>
</ul>
</li>
</ul>
<h2 id="调试设置"><a href="#调试设置" class="headerlink" title="调试设置"></a>调试设置</h2><p>添加GDB Remote Debug，就可以本地测试啦。</p>
]]></content>
      <categories>
        <category>编程</category>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title>garbage_collection</title>
    <url>/blog/1e17edb.html</url>
    <content><![CDATA[<h1 id="垃圾回收条件"><a href="#垃圾回收条件" class="headerlink" title="垃圾回收条件"></a>垃圾回收条件</h1><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>Minor GC/Young GC的触发条件：新生代内存区满，而又有新进入的新生代对象。此时会将没有被引用的垃圾新生代对象都回收掉。<br><a id="more"></a></p>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>当一个新生代对象在多次躲过垃圾回收，则会被转移到老年代。如果老年代也满了，也会触发垃圾回收。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>垃圾回收针对的是堆中的新生代、老年代，方法区（永久代），不会针对虚拟机栈中的栈帧。方法一旦执行完毕，栈帧出栈，局部变量直接就被清理掉了。</p>
<h1 id="JVM内存相关核心参数"><a href="#JVM内存相关核心参数" class="headerlink" title="JVM内存相关核心参数"></a>JVM内存相关核心参数</h1><p><strong>-Xms</strong>：Java堆内存的大小</p>
<p><strong>-Xmx</strong>：Java堆内存的最大大小</p>
<p><strong>-Xmn</strong>：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了</p>
<p><strong>-XX:PermSize</strong>：永久代大小</p>
<p><strong>-XX:MaxPermSize</strong>：永久代最大大小</p>
<p><strong>-Xss</strong>：每个线程的栈内存大小</p>
<blockquote>
<p>永久代在1.8中已经移除，替换为元空间，使用本地内存，突破了<strong>-XX:MaxPermSize</strong>的限制。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105731.jpg" alt="jvm_memory"></p>
<p>应用框架设置JVM参数：Spring Boot其实就是启动的时候可以加上JVM参数，Tomcat就是在bin目录下的catalina.sh中可以加入JVM参数。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>go基础语法</title>
    <url>/blog/f700becf.html</url>
    <content><![CDATA[<h1 id="语言结构"><a href="#语言结构" class="headerlink" title="语言结构"></a>语言结构</h1><ul>
<li>包声明<a id="more"></a></li>
<li>引入包</li>
<li>函数</li>
<li>变量</li>
<li>语句 &amp; 表达式</li>
<li>注释</li>
</ul>
<p><strong>注意</strong>：<code>&#123;</code>不能单独放在一行。go编译器会按行为语句加分隔符，如果<code>&#123;</code>单独一行，上一行末尾会被分隔。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量：<code>var v_name v_type</code><br>根据值自行判定类型： <code>var v_name  = value</code><br>省略var，但是左侧必须有待新声明的变量：<code>v_name := value</code> 。只能使用在函数体内。<br>在相同代码块中，不可以重复声明同名变量，只能重新赋值。</p>
<h2 id="多个变量"><a href="#多个变量" class="headerlink" title="多个变量"></a>多个变量</h2><p>同时定义多个变量：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b = b,a</span><br></pre></td></tr></table></figure><br>可以用组的方式：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    x,y <span class="keyword">int</span></span><br><span class="line">    a,s=<span class="number">100</span>,<span class="string">&quot;abc&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>不曾使用的常量不会编译错误</li>
<li>右值不能超过常量类型取值范围</li>
<li>右值也可以是某些编译器能够计算出结果的表达式</li>
<li>在常量组中如果不指定类型和初始化值，则与上一行非空常量右值相同</li>
<li>在预处理阶段展开，不分配内存，不能内存寻址来取值</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>除常量、别名类型以及未命名类型外，Go强制要求使用显式类型转换。<br>如果转换的目标是指针、单向通道或没有返回值的函数类型，那么必须使用括号，以避免造成语法分解错误。</p>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>即便指定了基础类型，也只表明它们有相同底层数据结构，两者间不存在任何关系，属完全不同的两种类型。除操作符外，自定义类型不会继承基础类型的其他信息（包括方法）。不能视作别名，不能隐式转换，不能直接用于比较表达式。</p>
<h3 id="未命名类型"><a href="#未命名类型" class="headerlink" title="未命名类型"></a>未命名类型</h3><p>与有明确标识符的bool、int、string等类型相比，数组、切片、字典、通道等类型与具体元素类型或长度等属性有关，故称作未命名类型（unnamed type）。当然，可用type为其提供具体名称，将其改变为命名类型（named type）。<br>具有相同声明的未命名类型被视作同一类型。</p>
<ul>
<li>具有相同基类型的指针。</li>
<li>具有相同元素类型和长度的数组（array）。</li>
<li>具有相同元素类型的切片（slice）。</li>
<li>具有相同键值类型的字典（map）。</li>
<li>具有相同数据类型及操作方向的通道（channel）。</li>
<li>具有相同字段序列（字段名、字段类型、标签，以及字段顺序）的结构体（struct）。</li>
<li>具有相同签名（参数和返回值列表，不包括参数名）的函数（func）。</li>
<li>具有相同方法集（方法名、方法签名，不包括顺序）的接口（interface）。<br>容易被忽视的是struct tag，它也属于类型组成部分，而不仅仅是元数据描述。<br>同样，函数的参数顺序也属签名组成部分。</li>
</ul>
<p>未命名类型转换规则：</p>
<ul>
<li>所属类型相同。</li>
<li>基础类型相同，且其中一个是未命名类型。</li>
<li>数据类型相同，将双向通道赋值给单向通道，且其中一个为未命名类型。</li>
<li>将默认值nil赋值给切片、字典、通道、指针、函数或接口。</li>
<li>对象实现了目标接口。</li>
</ul>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位清除（AND NOT）和位亦或（XOR）是不同的。它将右操作数对应二进制位都为1的重置为0（有些类似位图），以达到一次清除多个标记位的目的。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">0</span>b0101&amp;^<span class="number">0</span>b0011</span><br><span class="line"><span class="comment">// x=0100</span></span><br></pre></td></tr></table></figure></p>
<h3 id="、—"><a href="#、—" class="headerlink" title="++、—"></a>++、—</h3><p>自增、自减不再是运算符。只能作为独立语句，不能用于表达式，不能前置。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针类型支持相等运算符，但不能做加减法运算和类型转换。<br>指针没有专门指向成员的“-&gt;”运算符，统一使用“.”选择表达式。</p>
<h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>相邻的空case不构成多条件匹配。无须显式执行break语句，case执行完毕后自动中断。如须贯通后续case（源码顺序），须执行fallthrough，但不再匹配后续条件表达式。注意，fallthrough必须放在case块结尾，可使用break语句阻止。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>使用<code>iota</code>关键字实现枚举。如果中断<code>iota</code>自增，需要显示恢复。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    _,_ = <span class="literal">iota</span>*<span class="number">10</span>    <span class="comment">//0*10</span></span><br><span class="line">    a               <span class="comment">//1*10</span></span><br><span class="line">    b               <span class="comment">//2*10</span></span><br><span class="line">    c = <span class="number">100</span></span><br><span class="line">    d               <span class="comment">//100</span></span><br><span class="line">    e = <span class="literal">iota</span>        <span class="comment">//5*10</span></span><br></pre></td></tr></table></figure></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h2><p>变参本质上就是一个切片。只能接收一到多个同类型参数，且必须放在列表尾部。</p>
<h2 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h2><p>命名返回值和参数一样，可当作函数局部变量使用，最后由return隐式返回。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>,err error)</span></span> &#123; </span><br><span class="line">   <span class="keyword">if</span> y==<span class="number">0</span>&#123; </span><br><span class="line">       err=errors.New(<span class="string">&quot;division by zero&quot;</span>) </span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   z=x/y</span><br><span class="line">   <span class="keyword">return</span>         <span class="comment">// 相当于&quot;return z,err&quot; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这些特殊的“局部变量”会被不同层级的同名变量遮蔽。好在编译器能检查到此类状况，只要改为显式return返回即可。<br>除遮蔽外，我们还必须对全部返回值命名，否则编译器会搞不清状况。如果返回值类型能明确表明其含义，就尽量不要对其命名。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是匿名函数和引用的环境变量指针的组合体。<br>正因为闭包通过指针引用环境变量，那么可能会导致其生命周期延长，甚至被分配到堆内存。另外，还有所谓“延迟求值”的特性。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h2 id="延迟调用defer"><a href="#延迟调用defer" class="headerlink" title="延迟调用defer"></a>延迟调用defer</h2><p>注意，延迟调用注册的是调用，必须提供执行所需参数（哪怕为空）。参数值在注册时被复制并缓存起来。如对状态敏感，可改用指针或闭包。<br>延迟调用可修改当前函数命名返回值，但其自身返回值被抛弃。<br>多个延迟注册按FILO次序执行。<br>相比直接用CALL汇编指令调用函数，延迟调用则须花费更大代价。这其中包括注册、调用等操作，还有额外的缓存开销。</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">   s:= <span class="string">&quot;abcdefg&quot;</span> </span><br><span class="line">   s1:=s[:<span class="number">3</span>]          <span class="comment">// 从头开始，仅指定结束索引位置</span></span><br><span class="line">   s2:=s[<span class="number">1</span>:<span class="number">4</span>]         <span class="comment">// 指定开始和结束位置，返回[start,end) </span></span><br><span class="line">   s3:=s[<span class="number">2</span>:]          <span class="comment">// 指定开始位置，返回后面全部内容</span></span><br><span class="line">   <span class="built_in">println</span>(s1,s2,s3) </span><br><span class="line">    <span class="comment">//  reflect.StringHeader和string头结构相同</span></span><br><span class="line">    <span class="comment">//  unsafe.Pointer用于指针类型转换</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, (*reflect.StringHeader)(unsafe.Pointer(&amp;s))) </span><br><span class="line">   fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, (*reflect.StringHeader)(unsafe.Pointer(&amp;s1))) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abc bcd cdefg</span><br><span class="line">  </span><br><span class="line">&amp;StringHeader&#123;Data:0xfb838,Len:7&#125; </span><br><span class="line">&amp;StringHeader&#123;Data:0xfb838,Len:3&#125;</span><br></pre></td></tr></table></figure><br>使用for遍历字符串时，分byte和rune两种方式。rune:返回（数组索引号，Unicode字符）。</p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>要修改字符串，须将其转换为可变类型（[]rune或[]byte），待完成后再转换回来。但不管如何转换，都须重新分配内存，并复制数据。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>初始化<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">   <span class="keyword">var</span> a[<span class="number">4</span>]<span class="keyword">int</span>    <span class="comment">// 元素自动初始化为零</span></span><br><span class="line">   b:= [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">5</span>&#125;    <span class="comment">// 未提供初始值的元素自动初始化为0</span></span><br><span class="line">   c:= [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">3</span>:<span class="number">10</span>&#125;     <span class="comment">// 可指定索引位置初始化</span></span><br><span class="line">   d:= [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;        <span class="comment">// 编译器按初始化值数量确定数组长度</span></span><br><span class="line">   e:= [...]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">3</span>:<span class="number">100</span>&#125;      <span class="comment">// 支持索引初始化，但注意数组长度与此有关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于结构等复合类型，可省略元素初始化类型标签。<br>在定义多维数组时，仅第一维度允许使用“…”。<br>内置函数len和cap都返回第一维度长度。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>定义：<code>var identifier []type</code> 或者 <code>var slice1 []type = make([]type, len)</code><br>初始化：<code>s :=[] int &#123;1,2,3 &#125;</code>  或者 <code>s := arr[startIndex:endIndex]</code><br>属性cap表示切片所引用数组片段的真实长度，len用于限定可读的写元素数量。另外，数组必须addressable，否则会引发错误。比如数组是map的value值，仅仅是一个值，没有地址。<br>新建切片对象依旧指向原底层数组，也就是说修改对所有关联切片可见。</p>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>向切片尾部（slice[len]）添加数据，返回新的切片对象。不会修改原slice属性，但是数据被追加到原底层数组。如超出cap限制，则为新切片对象重新分配数组。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>在两个切片对象间复制数据，允许指向同一底层数组，允许目标区间重叠。最终所复制长度以较短的切片长度（len）为准。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">   s:= []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; </span><br><span class="line">   s1:=s[<span class="number">5</span>:<span class="number">8</span>] </span><br><span class="line">   n:=<span class="built_in">copy</span>(s[<span class="number">4</span>:],s1)      <span class="comment">// 在同一底层数组的不同区间复制</span></span><br><span class="line">   s2:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">6</span>)      <span class="comment">// 在不同数组间复制</span></span><br><span class="line">   n=<span class="built_in">copy</span>(s2,s) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果切片长时间引用大数组中很小的片段，那么建议新建独立切片，复制出所需数据，以便原数组内存可被及时回收。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>map： <code>var v_name map[key_type]data_type</code> 或者 <code>v_name = make(map[key_type]data_type)</code>或者<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m:=<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;        <span class="comment">// 值为匿名结构类型</span></span><br><span class="line">       x <span class="keyword">int</span></span><br><span class="line">&#125;&#123; </span><br><span class="line">   <span class="number">1</span>:  &#123;x:<span class="number">100</span>&#125;,          </span><br><span class="line">   <span class="number">2</span>:  &#123;x:<span class="number">200</span>&#125;, </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>运行时会对字典并发操作做出检测。如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典执行并发操作（读、写、删除），否则会导致进程崩溃。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>所谓匿名字段（anonymous field），是指没有名字，仅有类型的字段，也被称作嵌入字段或嵌入类型。<br>从编译器角度看，这只是隐式地以类型名作为字段名字。可直接引用匿名字段的成员，但初始化时须当作独立字段。<br>如嵌入其他包中的类型，则隐式字段名字不包括包名。<br>不仅仅是结构体，除接口指针和多级指针以外的任何命名类型都可作为匿名字段。<br>因未命名类型没有名字标识，自然无法作为匿名字段。<br>不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同。</p>
<h3 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h3><p>字段标签（tag）并不是注释，而是用来对字段进行描述的元数据。尽管它不属于数据成员，但却是类型的组成部分。<br>在运行期，可用反射获取标签信息。它常被用作格式校验，数据库关系映射等。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(type_name <span class="keyword">type</span>)</span> <span class="title">function_name</span><span class="params">(variable_name variable_data_type)</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">   <span class="comment">/* 函数体*/</span>&#125;</span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c1 Circle</span><br><span class="line">  c1.radius = <span class="number">10.00</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;圆的面积 = &quot;</span>, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">getArea</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="comment">//c.radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法同样不支持重载（overload）。如方法内部并不引用实例，可省略参数名，仅保留类型。<br>方法可看作特殊的函数，那么receiver的类型自然可以是基础类型或指针类型。这会关系到调用时对象实例是否被复制。<br>可使用实例值或指针调用方法，编译器会根据方法receiver类型自动在基础类型和指针类型间转换。<br>不能用多级指针调用方法。<br>指针类型的receiver必须是合法指针（包括nil），或能获取实例地址。</p>
<h2 id="如何选择方法的receiver类型？"><a href="#如何选择方法的receiver类型？" class="headerlink" title="如何选择方法的receiver类型？"></a>如何选择方法的receiver类型？</h2><ul>
<li>要修改实例状态，用<code>*T</code>。</li>
<li>无须修改状态的小对象或固定值，建议用T。</li>
<li>大对象建议用<code>*T</code>，以减少复制成本。</li>
<li>引用类型、字符串、函数等指针包装对象，直接用T。</li>
<li>若包含Mutex等同步字段，用<code>*T</code>，避免因复制造成锁操作无效。</li>
<li>其他无法确定的情况，都用<code>*T</code>。<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用<code>error.New(“xxx”)</code>生成错误信息。</li>
</ul>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p><code>goroutine</code>：go 函数名( 参数列表 )<br>通道：<br><code>ch &lt;- v</code>    // 把 v 发送到通道 ch<br><code>v := &lt;-ch</code>  // 从 ch 接收数据<br>           // 并把值赋给 v<br>声明通道： <code>ch := make(chan int)</code></p>
<h1 id="context上下文"><a href="#context上下文" class="headerlink" title="context上下文"></a>context上下文</h1><p>context 包在与 API 和慢处理交互时可以派上用场，特别是在生产级的 Web 服务中。在这些场景中，您可能想要通知所有的 goroutine 停止运行并返回。<br><a href="https://studygolang.com/articles/13866?fr=sidebar">https://studygolang.com/articles/13866?fr=sidebar</a></p>
]]></content>
      <categories>
        <category>go</category>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>go for循环的一个问题</title>
    <url>/blog/4d1a6fbb.html</url>
    <content><![CDATA[<p>在写go的for循环时，遇到了一个神奇的问题，记录一下。<br><a id="more"></a></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>有如下代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>] <span class="keyword">string</span>)</span><br><span class="line">	r := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">string</span>)</span><br><span class="line">	m[<span class="number">1</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">	m[<span class="number">2</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, entry := <span class="keyword">range</span> m &#123;</span><br><span class="line">		r[k] = &amp;entry</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, entry := <span class="keyword">range</span> r&#123;</span><br><span class="line">		<span class="built_in">println</span>(*entry)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>打印结果会是什么呢？多跑几次试试。</p>
<p>打印结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>如果是rust或者C++，java的代码，例如rust：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> m: HashMap&lt;<span class="built_in">u8</span>, <span class="built_in">String</span>&gt; = HashMap::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> r: HashMap&lt;<span class="built_in">u8</span>, <span class="built_in">Box</span>&lt;<span class="built_in">String</span>&gt;&gt; = HashMap::new();</span><br><span class="line">    m.insert(<span class="number">1</span>, <span class="built_in">String</span>::from(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    m.insert(<span class="number">2</span>, <span class="built_in">String</span>::from(<span class="string">&quot;2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> m &#123;</span><br><span class="line">        r.insert(key, <span class="built_in">Box</span>::from(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (_, v) <span class="keyword">in</span> r&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的结果应该是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">// 或者 2 1</span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新的变量，在赋值的过程中就发生了拷贝，所以我们遍历的切片已经不是原始的切片变量了。</p>
<p>而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的变量存储切片中的元素，<strong>循环中使用的这个变量 entry 会在每一次迭代被重新赋值而覆盖，在赋值时也发生了拷贝</strong>。</p>
<p>因为在循环中获取返回变量的地址都完全相同，所以会发生神奇的现象。所以如果我们想要访问元素所在的地址，不应该直接获取 range 返回的变量地址，而应该使用 <code>&amp;m[key]</code> 这种形式。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>hash</title>
    <url>/blog/d1b862b8.html</url>
    <content><![CDATA[<h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>以SHA256算法为例。<br><a id="more"></a><br>SHA256是SHA-2下细分出的一种算法。<br>SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，属于SHA算法之一，是SHA-1的后继者。<br>对于任意长度的消息，SHA256都会产生一个256bit长的哈希值，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常用一个长度为64的十六进制字符串来表示。</p>
<h2 id="信息预处理"><a href="#信息预处理" class="headerlink" title="信息预处理"></a>信息预处理</h2><h3 id="STEP1：附加填充比特"><a href="#STEP1：附加填充比特" class="headerlink" title="STEP1：附加填充比特"></a>STEP1：附加填充比特</h3><p>在报文末尾进行填充，使报文长度在对512取模以后的余数是448<br>填充是这样进行的：先补第一个比特为1，然后都补0，直到长度满足对512取模后余数是448。<br>需要注意的是，信息必须进行填充，也就是说，即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512个比特。<br>因此，填充是至少补一位，最多补512位。<br>例：以信息“abc”为例显示补位的过程。<br>a,b,c对应的ASCII码分别是97,98,99<br>于是原始信息的二进制编码为：01100001 01100010 01100011<br>补位第一步，首先补一个“1” ： 0110000101100010 01100011 1<br>补位第二步,补423个“0”：01100001 01100010 01100011 10000000 00000000 … 00000000</p>
<blockquote>
<p>为什么是448?<br>因为在第一步的预处理后，第二步会再附加上一个64bit的数据，用来表示原始报文的长度信息。而448+64=512，正好拼成了一个完整的结构。</p>
</blockquote>
<h3 id="STEP2：附加长度值"><a href="#STEP2：附加长度值" class="headerlink" title="STEP2：附加长度值"></a>STEP2：附加长度值</h3><p>附加长度值就是将原始数据（第一步填充前的消息）的长度信息补到已经进行了填充操作的消息后面。<br>SHA256用一个64位的数据来表示原始消息的长度。<br>因此，通过SHA256计算的消息长度必须要小于2^64，当然绝大多数情况这足够大了。<br>长度信息的编码方式为64-bit big-endian integer。<br>回到刚刚的例子，消息“abc”，3个字符，占用24个bit，末尾加上00000000 00000018。</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>逻辑位运算。<br><img src="evernotecid://09243391-321F-42E2-BB9A-CDBE8BED8C36/appyinxiangcom/18710579/ENResource/p2442" alt="4c945b7bf1b7ec1e62acbaa9112c32d3.png"></p>
<h2 id="计算消息摘要"><a href="#计算消息摘要" class="headerlink" title="计算消息摘要"></a>计算消息摘要</h2><p>首先：将消息分解成512-bit大小的块(break message into 512-bit chunks)<br><img src="evernotecid://09243391-321F-42E2-BB9A-CDBE8BED8C36/appyinxiangcom/18710579/ENNote/p472?hash=6c08ee2b2b16c69cf6e75e98b61ea1df" alt="6c08ee2b2b16c69cf6e75e98b61ea1df.png"><br>假设消息M可以被分解为n个块，于是整个算法需要做的就是完成n次迭代，n次迭代的结果就是最终的哈希值，即256bit的数字摘要。<br>一个256-bit的摘要的初始值H0，经过第一个数据块进行运算，得到H1，即完成了第一次迭代。<br>H1经过第二个数据块得到H2，……，依次处理，最后得到Hn，Hn即为最终的256-bit消息摘要。<br>将每次迭代进行的映射用$ Map(H<em>{i-1}) = H</em>{i} $表示，于是迭代可以更形象的展示为：<br><img src="evernotecid://09243391-321F-42E2-BB9A-CDBE8BED8C36/appyinxiangcom/18710579/ENNote/p472?hash=25ec4d1e8c4301a43e1960501075bb9b" alt="25ec4d1e8c4301a43e1960501075bb9b.png"></p>
<blockquote>
<p>8个哈希初值：这些初值是对自然数中前8个质数（2,3,5,7,11,13,17,19）的平方根的小数部分取前32bit而来。<br>64个常量：和8个哈希初值类似，这些常量是对自然数中前64个质数(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…)的立方根的小数部分取前32bit而来。</p>
</blockquote>
<p>图中256-bit的Hi被描述8个小块，这是因为SHA256算法中的最小运算单元称为“字”（Word），一个字是32位。<br>此外，第一次迭代中，映射的初值设置为前面介绍的8个哈希初值，如下图所示：<br><img src="evernotecid://09243391-321F-42E2-BB9A-CDBE8BED8C36/appyinxiangcom/18710579/ENNote/p472?hash=1a0df915b0c4d9439a5265c0fd59d242" alt="1a0df915b0c4d9439a5265c0fd59d242.png"></p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><h4 id="STEP1：构造64个字（word）"><a href="#STEP1：构造64个字（word）" class="headerlink" title="STEP1：构造64个字（word）"></a>STEP1：构造64个字（word）</h4><p>break chunk into sixteen 32-bit big-endian words w[0], …, w[15]<br>对于每一块，将块分解为16个32-bit的big-endian的字，记为w[0], …, w[15]<br>也就是说，前16个字直接由消息的第i个块分解得到<br>其余的字由如下迭代公式得到：<br><img src="evernotecid://09243391-321F-42E2-BB9A-CDBE8BED8C36/appyinxiangcom/18710579/ENResource/p2450" alt="f2098805de36b73a980268f69a5a3462.png"></p>
<h4 id="STEP2：进行64次循环"><a href="#STEP2：进行64次循环" class="headerlink" title="STEP2：进行64次循环"></a>STEP2：进行64次循环</h4><p>映射 $ Map(H<em>{i-1}) = H</em>{i} $ 包含了64次加密循环<br>即进行64次加密循环即可完成一次迭代<br>每次加密循环可以由下图描述：<br><img src="evernotecid://09243391-321F-42E2-BB9A-CDBE8BED8C36/appyinxiangcom/18710579/ENNote/p472?hash=2b6b5ad6ec73e40907818601a7ee9a13" alt="2b6b5ad6ec73e40907818601a7ee9a13.png"><br>图中，ABCDEFGH这8个字（word）在按照一定的规则进行更新，其中<br>深蓝色方块是事先定义好的非线性逻辑函数，上文已经做过铺垫<br>红色田字方块代表 mod $ 2^{32} $ addition，即将两个数字加在一起，如果结果大于$ 2^{32}$ ，你必须除以 $ 2^{32} $并找到余数。<br>ABCDEFGH一开始的初始值分别为$ H<em>{i-1}(0),H</em>{i-1}(1),…,H<em>{i-1}(7) $<br>Kt是第t个密钥，对应我们上文提到的64个常量。<br>Wt是本区块产生第t个word。原消息被切成固定长度512-bit的区块，对每一个区块，产生64个word，通过重复运行循环n次对ABCDEFGH这八个字循环加密。<br>最后一次循环所产生的八个字合起来即是第i个块对应到的散列字符串$ H</em>{i} $</p>
<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Note: All variables are unsigned 32 bits and wrap modulo 232 when calculating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initialize variables</span><br><span class="line">(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):</span><br><span class="line">h0 := 0x6a09e667</span><br><span class="line">h1 := 0xbb67ae85</span><br><span class="line">h2 := 0x3c6ef372</span><br><span class="line">h3 := 0xa54ff53a</span><br><span class="line">h4 := 0x510e527f</span><br><span class="line">h5 := 0x9b05688c</span><br><span class="line">h6 := 0x1f83d9ab</span><br><span class="line">h7 := 0x5be0cd19</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initialize table of round constants</span><br><span class="line">(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):</span><br><span class="line">k[0..63] :=</span><br><span class="line">   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,</span><br><span class="line">   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,</span><br><span class="line">   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,</span><br><span class="line">   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,</span><br><span class="line">   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,</span><br><span class="line">   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,</span><br><span class="line">   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,</span><br><span class="line">   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pre-processing:</span><br><span class="line">append the bit <span class="string">&#x27;1&#x27;</span> to the message</span><br><span class="line">append k bits <span class="string">&#x27;0&#x27;</span>, <span class="built_in">where</span> k is the minimum number &gt;= 0 such that the resulting message</span><br><span class="line">    length (<span class="keyword">in</span> bits) is congruent to 448(mod 512)</span><br><span class="line">append length of message (before pre-processing), <span class="keyword">in</span> bits, as 64-bit big-endian <span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process the message <span class="keyword">in</span> successive 512-bit chunks:</span><br><span class="line"><span class="built_in">break</span> message into 512-bit chunks</span><br><span class="line"><span class="keyword">for</span> each chunk</span><br><span class="line">    <span class="built_in">break</span> chunk into sixteen 32-bit big-endian words w[0..15]</span><br><span class="line"></span><br><span class="line">    Extend the sixteen 32-bit words into sixty-four 32-bit words:</span><br><span class="line">    <span class="keyword">for</span> i from 16 to 63</span><br><span class="line">        s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor(w[i-15] rightshift 3)</span><br><span class="line">        s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor(w[i-2] rightshift 10)</span><br><span class="line">        w[i] := w[i-16] + s0 + w[i-7] + s1</span><br><span class="line"></span><br><span class="line">    Initialize <span class="built_in">hash</span> value <span class="keyword">for</span> this chunk:</span><br><span class="line">    a := h0</span><br><span class="line">    b := h1</span><br><span class="line">    c := h2</span><br><span class="line">    d := h3</span><br><span class="line">    e := h4</span><br><span class="line">    f := h5</span><br><span class="line">    g := h6</span><br><span class="line">    h := h7</span><br><span class="line"></span><br><span class="line">    Main loop:</span><br><span class="line">    <span class="keyword">for</span> i from 0 to 63</span><br><span class="line">        s0 := (a rightrotate 2) xor (a rightrotate 13) xor(a rightrotate 22)</span><br><span class="line">        maj := (a and b) xor (a and c) xor(b and c)</span><br><span class="line">        t2 := s0 + maj</span><br><span class="line">        s1 := (e rightrotate 6) xor (e rightrotate 11) xor(e rightrotate 25)</span><br><span class="line">        ch := (e and f) xor ((not e) and g)</span><br><span class="line">        t1 := h + s1 + ch + k[i] + w[i]</span><br><span class="line">        h := g</span><br><span class="line">        g := f</span><br><span class="line">        f := e</span><br><span class="line">        e := d + t1</span><br><span class="line">        d := c</span><br><span class="line">        c := b</span><br><span class="line">        b := a</span><br><span class="line">        a := t1 + t2</span><br><span class="line"></span><br><span class="line">    Add this chunk<span class="string">&#x27;s hash to result so far:</span></span><br><span class="line"><span class="string">    h0 := h0 + a</span></span><br><span class="line"><span class="string">    h1 := h1 + b</span></span><br><span class="line"><span class="string">    h2 := h2 + c</span></span><br><span class="line"><span class="string">    h3 := h3 + d</span></span><br><span class="line"><span class="string">    h4 := h4 + e</span></span><br><span class="line"><span class="string">    h5 := h5 + f</span></span><br><span class="line"><span class="string">    h6 := h6 + g</span></span><br><span class="line"><span class="string">    h7 := h7 + h</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Produce the final hash value (big-endian):</span></span><br><span class="line"><span class="string">digest = hash = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u011583927/article/details/80905740">SHA256算法原理详解</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>密码学</category>
      </categories>
  </entry>
  <entry>
    <title>keystore</title>
    <url>/blog/2475f3a5.html</url>
    <content><![CDATA[<h1 id="Keystore简介"><a href="#Keystore简介" class="headerlink" title="Keystore简介"></a>Keystore简介</h1><p>以太坊的每个外部账户都是由一对密钥定义的。<br><a id="more"></a><br>keystore 文件（存储在<code>~/.ethereum/keystore</code>Linux或<code>C:\Users\&lt;User&gt;\Appdata\Roaming\Ethereum\keystore</code>Windows上）是用于签署交易的以太网私钥的加密版本。私钥通常用你创建帐户时设置的密码进行加密。如果你丢失了这个文件，你就丢失了私钥。当然，忘了密码也意味着你进不去这个账户了。如果丢了文件又忘了密码，那么恭喜你，心大的你只能看看账户里的余额，喝酒消愁了。</p>
<p>这个文件是<strong>安全性</strong>（攻击者需要密钥库文件<em>和</em> 密码来窃取您的资金）和<strong>可用性</strong>之间的完美折衷（您只需要密钥库文件<em>和</em> 密码来使用您的钱）。为了让您发送一些以太网，大多数以太坊客户端会要求您输入密码（与您创建帐户时使用的密码）相同，以便解密您的以太坊私钥。解密后，客户端程序可以使用私钥来签署您的交易，并让您移动您的资金。</p>
<h1 id="Keystore文件内容"><a href="#Keystore文件内容" class="headerlink" title="Keystore文件内容"></a>Keystore文件内容</h1><p>文件来源<a href="https://github.com/hashcat/hashcat/issues/1228">此处</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat~ &#x2F; .ethereum &#x2F; keystore &#x2F; UTC  -  &lt;created_date_time&gt;  -  008aeeda4d805471df9b2a5b0f38a0c3bcba786b </span><br><span class="line">&#123; </span><br><span class="line">    “crypto”：&#123; </span><br><span class="line">        “cipher”：“aes-128-ctr”，</span><br><span class="line">        “cipherparams”：&#123; </span><br><span class="line">            “iv”：“83dbcc02d8ccb40e466191a123791e0e” </span><br><span class="line">        &#125;，</span><br><span class="line">        “ciphertext”：“d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c”，</span><br><span class="line">        “kdf”：“scrypt”，</span><br><span class="line">        “kdfparams”：&#123; </span><br><span class="line">            “dklen”：32，</span><br><span class="line">            “n”：262144，</span><br><span class="line">            “r”：1，</span><br><span class="line">            “p”：8，</span><br><span class="line">            “salt”：“ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19“ </span><br><span class="line">        &#125;，</span><br><span class="line">        “mac”：“2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097” </span><br><span class="line">    &#125;，</span><br><span class="line">    “id”：“d57df606-1b86-447a-a60e-18a539f9d92e”，</span><br><span class="line">    “version”：3 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个粗略的JSON文件，包含许多参数。</p>
<h1 id="分析文件内容"><a href="#分析文件内容" class="headerlink" title="分析文件内容"></a>分析文件内容</h1><ul>
<li><p>第一行字符串（008aeeda4d805471df9b2a5b0f38a0c3bcba786b ）是<strong>address</strong> 。</p>
</li>
<li><p><strong>crypto</strong>下的参数解析：</p>
<ul>
<li><strong>cipher</strong>：对称<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES算法</a>的名称；</li>
<li><strong>cipherparams</strong>：上面“密码”算法所需的参数；</li>
<li><strong>ciphertext</strong>：使用上面的“密码”算法加密的以太网私钥；</li>
<li><strong>kdf</strong>：一个<a href="https://en.wikipedia.org/wiki/Key_derivation_function">密钥派生函数，</a>用于让您使用密码加密密钥库文件；</li>
<li><strong>kdfparams</strong>：上述“kdf”算法所需的参数；</li>
<li><strong>mac</strong>：用于验证密码的<a href="https://en.wikipedia.org/wiki/Message_authentication_code">代码</a> ；在密码输错时可以给出一个反馈。</li>
</ul>
</li>
<li><strong>version</strong>: Keystore文件的版本，目前为第3版，也称为V3 KeyStore。</li>
<li><strong>id</strong> : uuid；例子中，V=4,T=a，表示uuid v4版本（基于随机数）；</li>
</ul>
<p>让我们看看它们如何协同工作，在密码短语下保护keystore文件。</p>
<h2 id="1-加密私钥"><a href="#1-加密私钥" class="headerlink" title="1.加密私钥"></a>1.加密私钥</h2><p>如前所述，以太坊帐户是用于对交易进行加密签名的私钥 - 公钥对。为了确保私钥不像普通文件一样存储在文件中（即可以访问该文件的任何人可读），使用强对称算法（<strong>密码</strong>）对其进行加密至关重要。</p>
<p>这些对称算法使用密钥来加密某些数据。结果数据是加密的，可以使用相同的方法和相同的密钥进行解密 - 因此名称为“对称”。对于本文，我们将此对称密钥称为<strong>解密密钥，</strong>因为它将用于解密我们的以太坊私钥。</p>
<p>这就是<strong>cipher</strong>，<strong>cipherparams</strong>和<strong>ciphertext</strong>对应的：</p>
<ul>
<li><strong>cipher</strong>是用于加密以太坊私钥的对称算法。默认为<code>aes-128-ctr</code>,128代表位。又名“128位密钥”或“256位密钥”。数字越高，越安全。</li>
<li><strong>cipherparams</strong>是<em>aes-128-ctr</em>算法所需的参数。这里，唯一的参数是<em>iv</em>。<ul>
<li><strong>iv</strong>：aes-128-ctr加密算法需要的初始化向量，大小必须符合密码的要求。如果没有提供，则通过crypto.getRandomBytes生成随机数。这里是128bit。</li>
</ul>
</li>
<li><strong>ciphertext</strong>是<em>aes-128-ctr</em>函数的加密输出也是之后的输入。</li>
</ul>
<p>具体的加密流程如下：</p>
<ol>
<li>生成一个随机数作为盐 | 给定一个盐值，对密码进行加密（kdf）生成派生秘钥（即<strong>解密密钥</strong>）；</li>
<li>然后从派生秘钥中截取16位字符作为派生密码；</li>
<li>再生成一个16位的随机数作为向量iv；</li>
<li>然后拿着生成的派生密码，向量，私钥进行加密得到密文ciphertext；</li>
<li>最后拿着生成的密文，和派生秘钥做hash处理作为校验码mac；</li>
<li>将相关参数和密文保存到JSON文件keystore中。</li>
</ol>
<p>所以，您需要先得到<strong>解密密钥</strong>。实际上，记住你设置的密码即可，下小节讲解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110012.png" alt="2"></p>
<h2 id="2-用密码保护它"><a href="#2-用密码保护它" class="headerlink" title="2.用密码保护它"></a>2.用密码保护它</h2><p>为了确保轻松解锁您的帐户，您无需记住非常长且非用户友好的<strong>解密密钥</strong>。相反，以太坊开发人员选择了基于密码短语的保护 - 也就是说，您只需要输入密码来得到<strong>解密密钥</strong>。</p>
<p>为了能够实现这一点，以太坊使用<a href="https://en.wikipedia.org/wiki/Key_derivation_function">密钥派生函数</a>，在给定密码和参数列表的情况下计算<strong>解密密钥</strong>。</p>
<p><strong>kdf</strong>和<strong>kdfparams</strong>：</p>
<ul>
<li><p><strong>kdf</strong>是用于从密码短语计算（或“衍生”）<strong>解密密钥</strong>的密钥派生函数。这里，<strong>kdf</strong>的值是<em>scrypt</em> <strong>。</strong></p>
</li>
<li><p><strong>kdfparams</strong>是<a href="/blog/5daaeba7.html" title="*scrypt*">*scrypt*</a>函数所需的参数。这里，<em>dklen</em>，<em>n</em>，<em>r</em>，<em>p</em>和<em>salt</em>是<strong>kdf</strong>函数的参数。</p>
<ul>
<li><code>dklen：32</code>，- 派生密钥长度（以字节为单位）。对于某些密码设置，这必须匹配那些块大小。小于等于(2^32 - 1) * 32的正整数。</li>
<li><code>n：262144</code>，- 迭代计数。geth的默认值为262144。 n 和 r 决定了占用的内存区域大小和哈希迭代次数（占用的内存大小为 128⋅n⋅r bytes，迭代次数为 2⋅n⋅r），可以修改的参数是 n。把 n 值定在 65536，这样可以兼容大部分低端配置的手机。必须大于1，是2的幂且小于2^(128 * r / 8)。</li>
<li><code>r：8</code>，- 底层散列的块大小，默认为8。决定了连续读大小（sequential read size），通常不应该修改。</li>
<li><code>p：1</code> - 并行化因素。默认为1。小于等于((2^32-1) <em> 32) / (128 </em> r)的正整数。</li>
<li><code>salt</code> - kdf的随机盐。大小必须符合KDF（密钥派生函数）的要求。如果没有提供，则通过crypto.getRandomBytes生成随机数。</li>
</ul>
<blockquote>
<p>减少/覆盖scrypt设置为1024 <em> 8 </em> 1能更快破解？<br>不可以。更改  N  将改变迭代计数，这将改变散列。即使您的字典中包含明文，它也不会破解散列。</p>
<p>另外，来计算一下默认参数下，并行计算需要多少内存：</p>
<p>1：（128 * 8）* 262144 = 1024 * 262144 = 268,435,456字节= 256MB<br>2：64（AMD卡）* 64（[RX Vega 64具有64个CU]<br>  (<a href="https://www.techpowerup.com/gpudb/2871/radeon-rx-vega-64）=">https://www.techpowerup.com/gpudb/2871/radeon-rx-vega-64）=</a> 4,096个并行计算<br>3：256MB * 4,096 = 1,048,576 MB RAM = <em>Vega 64需要<strong>1,024</strong> GB RAM</em></p>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>所以，如果我忘记了Eth钱包的密码，那么可能需要几年时间才能破解？！？！</li>
<li>对。<br>//n的值越大，加密级别越高，当然消耗的内存越大。</li>
</ul>
</blockquote>
<p>在这里，使用<strong>kdfparams</strong>参数调整<em>scrypt</em>函数并将其<strong>输入</strong>密码，您将获得我们的<strong>解密密钥</strong>作为密钥派生函数的输出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110022.png" alt="3"></p>
<h2 id="3-确保您的密码是正确的"><a href="#3-确保您的密码是正确的" class="headerlink" title="3.确保您的密码是正确的"></a>3.确保您的密码是正确的</h2><p>我们已经描述了从密钥库文件和密码短语中确定我们的以太网私钥所需的一切。但是，如果用于解锁帐户的密码错误，会发生什么？</p>
<p>从我们到目前为止所看到的，所有操作（派生和解密）都将成功，但最后计算的以太坊私钥将不正确 - 这首先违背了使用密钥文件的要点！</p>
<p>我们需要保证键入的密码以解锁帐户是正确的，它与最初创建密钥库文件时输入的密码相同（记得<code>geth account new</code>吗？）。</p>
<p>这是密钥库文件中的<strong>mac</strong>值发挥作用的地方。在执行密钥派生函数之后，处理其结果（<strong>解密密钥</strong>）和<strong>密文</strong>并与<strong>mac</strong>进行比较（其作用类似于批准的印章）。如果结果与<strong>mac</strong>相同，则密码是正确的，并且解密可以开始。</p>
<p>在与<strong>mac</strong>进行比较之前，将<strong>解密密钥</strong>（仅第二个最左边的16个字节）和<strong>密文</strong>进行连接和散列（SHA3-256）。更多信息<a href="https://github.com/hashcat/hashcat/issues/1228">在这里</a>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110029.png" alt="4"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先，您输入了密码，该密码被<strong>kdf</strong>密钥派生函数用来计算出<strong>解密密钥</strong>。然后，将新计算的<strong>解密密钥</strong>与<strong>密文</strong>一起处理，并与<strong>mac</strong>进行比较，以确保密码是正确的。最后，使用<strong>解密密钥</strong>通过<strong>密码</strong>对称解密函数<strong>解密密文</strong>。</p>
<p>瞧！解密的结果是您的以太网私钥。您可以在这里查看整个过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110041.png" alt="5"></p>
<p>从图中可以看出，你的密码作为唯一的输入，你的以太网私钥作为唯一的输出。创建新的以太坊帐户时生成的keystore文件中提供了所需的其他信息。</p>
<p>出于这个原因，请确保您的密码是强大的（<em>并且您以某种方式记住它们！</em>）以保证窃取您的密钥库文件的攻击者无法轻松得到您的私钥。</p>
<h1 id="Refer"><a href="#Refer" class="headerlink" title="Refer."></a>Refer.</h1><p>[1]. <a href="https://medium.com/@julien.maffre/what-is-an-ethereum-keystore-file-86c8c5917b97">What is an Ethereum keystore file?</a></p>
<p>[2]. <a href="https://github.com/hashcat/hashcat/issues/1228">Ethereum KDF - Scrypt</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>密码学</category>
      </categories>
  </entry>
  <entry>
    <title>socket</title>
    <url>/blog/5e568bb.html</url>
    <content><![CDATA[<h1 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h1><a id="more"></a>
<p>套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。</p>
<p>当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。</p>
<p>java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。</p>
<p>以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：</p>
<ul>
<li>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</li>
<li>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li>
<li>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</li>
<li>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li>
<li>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</li>
</ul>
<p>连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。</p>
<p>TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 socket。</p>
<h1 id="ServerSocket-类的方法"><a href="#ServerSocket-类的方法" class="headerlink" title="ServerSocket 类的方法"></a>ServerSocket 类的方法</h1><p>服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。</p>
<p>ServerSocket 类有四个构造方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public ServerSocket(int port) throws IOException</strong> 创建绑定到特定端口的服务器套接字。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public ServerSocket(int port, int backlog) throws IOException</strong> 利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public ServerSocket(int port, int backlog, InetAddress address) throws IOException</strong> 使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public ServerSocket() throws IOException</strong> 创建非绑定服务器套接字。</td>
</tr>
</tbody>
</table>
</div>
<p>创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。</p>
<p>这里有一些 ServerSocket 类的常用方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public int getLocalPort()</strong>  返回此套接字在其上侦听的端口。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public Socket accept() throws IOException</strong> 侦听并接受到此套接字的连接。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public void setSoTimeout(int timeout)</strong>  通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public void bind(SocketAddress host, int backlog)</strong> 将 ServerSocket 绑定到特定地址（IP 地址和端口号）。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Socket-类的方法"><a href="#Socket-类的方法" class="headerlink" title="Socket 类的方法"></a>Socket 类的方法</h1><p>java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。</p>
<p>Socket 类有五个构造方法.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public Socket(String host, int port) throws UnknownHostException, IOException.</strong> 创建一个流套接字并将其连接到指定主机上的指定端口号。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public Socket(InetAddress host, int port) throws IOException</strong> 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.</strong> 创建一个套接字并将其连接到指定远程主机上的指定远程端口。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.</strong> 创建一个套接字并将其连接到指定远程地址上的指定远程端口。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public Socket()</strong> 通过系统默认类型的 SocketImpl 创建未连接套接字</td>
</tr>
</tbody>
</table>
</div>
<p>当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。</p>
<p>下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public void connect(SocketAddress host, int timeout) throws IOException</strong> 将此套接字连接到服务器，并指定一个超时值。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public InetAddress getInetAddress()</strong>  返回套接字连接的地址。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public int getPort()</strong> 返回此套接字连接到的远程端口。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public int getLocalPort()</strong> 返回此套接字绑定到的本地端口。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public SocketAddress getRemoteSocketAddress()</strong> 返回此套接字连接的端点的地址，如果未连接则返回 null。</td>
</tr>
<tr>
<td>6</td>
<td><strong>public InputStream getInputStream() throws IOException</strong> 返回此套接字的输入流。</td>
</tr>
<tr>
<td>7</td>
<td><strong>public OutputStream getOutputStream() throws IOException</strong> 返回此套接字的输出流。</td>
</tr>
<tr>
<td>8</td>
<td><strong>public void close() throws IOException</strong> 关闭此套接字。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h1 id="InetAddress-类的方法"><a href="#InetAddress-类的方法" class="headerlink" title="InetAddress 类的方法"></a>InetAddress 类的方法</h1><p>这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>static InetAddress getByAddress(byte[] addr)</strong> 在给定原始 IP 地址的情况下，返回 InetAddress 对象。</td>
</tr>
<tr>
<td>2</td>
<td><strong>static InetAddress getByAddress(String host, byte[] addr)</strong> 根据提供的主机名和 IP 地址创建 InetAddress。</td>
</tr>
<tr>
<td>3</td>
<td><strong>static InetAddress getByName(String host)</strong> 在给定主机名的情况下确定主机的 IP 地址。</td>
</tr>
<tr>
<td>4</td>
<td><strong>String getHostAddress()</strong>  返回 IP 地址字符串（以文本表现形式）。</td>
</tr>
<tr>
<td>5</td>
<td><strong>String getHostName()</strong>   获取此 IP 地址的主机名。</td>
</tr>
<tr>
<td>6</td>
<td><strong>static InetAddress getLocalHost()</strong> 返回本地主机。</td>
</tr>
<tr>
<td>7</td>
<td><strong>String toString()</strong> 将此 IP 地址转换为 String。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Socket-服务端实例"><a href="#Socket-服务端实例" class="headerlink" title="Socket 服务端实例"></a>Socket 服务端实例</h1><p>如下的GreetingServer 程序是一个服务器端应用程序，使用 Socket 来监听一个指定的端口。</p>
<p>GreetingServer.java 文件代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 GreetingServer.java</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingServer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">GreetingServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">      serverSocket.setSoTimeout(<span class="number">10000</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">try</span></span><br><span class="line">         &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待远程连接，端口号为：&quot;</span> + serverSocket.getLocalPort() + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">            Socket server = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;远程主机地址：&quot;</span> + server.getRemoteSocketAddress());</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(server.getInputStream());</span><br><span class="line">            System.out.println(in.readUTF());</span><br><span class="line">            DataOutputStream out = <span class="keyword">new</span> DataOutputStream(server.getOutputStream());</span><br><span class="line">            out.writeUTF(<span class="string">&quot;谢谢连接我：&quot;</span> + server.getLocalSocketAddress() + <span class="string">&quot;\nGoodbye!&quot;</span>);</span><br><span class="line">            server.close();</span><br><span class="line">         &#125;<span class="keyword">catch</span>(SocketTimeoutException s)</span><br><span class="line">         &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Socket timed out!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">         &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         Thread t = <span class="keyword">new</span> GreetingServer(port);</span><br><span class="line">         t.run();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">      &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Socket-客户端实例"><a href="#Socket-客户端实例" class="headerlink" title="Socket 客户端实例"></a>Socket 客户端实例</h1><p>如下的 GreetingClient 是一个客户端程序，该程序通过 socket 连接到服务器并发送一个请求，然后等待一个响应。</p>
<p>GreetingClient.java 文件代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 GreetingClient.java</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      String serverName = args[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;连接到主机：&quot;</span> + serverName + <span class="string">&quot; ，端口号：&quot;</span> + port);</span><br><span class="line">         Socket client = <span class="keyword">new</span> Socket(serverName, port);</span><br><span class="line">         System.out.println(<span class="string">&quot;远程主机地址：&quot;</span> + client.getRemoteSocketAddress());</span><br><span class="line">         OutputStream outToServer = client.getOutputStream();</span><br><span class="line">         DataOutputStream out = <span class="keyword">new</span> DataOutputStream(outToServer);</span><br><span class="line"> </span><br><span class="line">         out.writeUTF(<span class="string">&quot;Hello from &quot;</span> + client.getLocalSocketAddress());</span><br><span class="line">         InputStream inFromServer = client.getInputStream();</span><br><span class="line">         DataInputStream in = <span class="keyword">new</span> DataInputStream(inFromServer);</span><br><span class="line">         System.out.println(<span class="string">&quot;服务器响应： &quot;</span> + in.readUTF());</span><br><span class="line">         client.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">      &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>路线与基础</category>
      </categories>
  </entry>
  <entry>
    <title>static</title>
    <url>/blog/80c02825.html</url>
    <content><![CDATA[<h1 id="修饰用法"><a href="#修饰用法" class="headerlink" title="修饰用法"></a>修饰用法</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>一般用来修饰成员变量或函数，可以在没有创建对象的情况下来进行调用。<br><a id="more"></a></p>
<h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>普通类是不允许声明为静态的，只有内部类才可以。</p>
<h2 id="修饰函数-方法"><a href="#修饰函数-方法" class="headerlink" title="修饰函数/方法"></a>修饰函数/方法</h2><p>修饰方法的时候，其实跟类一样，可以直接通过类名来进行调用。</p>
<h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p>被static修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被static修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。</p>
<h2 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h2><p>静态代码块在类第一次被载入时执行，类初始化的顺序如下：</p>
<p>父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类普通变量、父类普通代码块、父类构造函数、子类普通变量、子类普通代码块、子类构造函数。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）</p>
<p>2、静态方法中不可以使用this或者super关键字。</p>
<p>3、主函数是静态的</p>
<h1 id="静态方法访问限制"><a href="#静态方法访问限制" class="headerlink" title="静态方法访问限制"></a>静态方法访问限制</h1><p>静态方法和静态变量是属于某一个类，而不属于类的对象。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>静态方法是属于类的，动态方法属于实例对象。静态成员在类“加载”（实际上是准备阶段）的时候就会分配内存，可以通过类名直接去访问，非静态成员（变量和方法）属于类的对象，所以只有该对象初始化之后才存在，然后通过类的对象去访问。</p>
<p>也就是说如果我们在静态方法中调用非静态成员变量会超前，可能会调用了一个还未初始化的变量。因此编译器会报错。</p>
<h1 id="内部类实例化与static"><a href="#内部类实例化与static" class="headerlink" title="内部类实例化与static"></a>内部类实例化与static</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>先讲一下new命令在jvm中的底层实现。</p>
<ul>
<li>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。</li>
<li>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<br>内存分配过程通常采用两种分配方式（“指针碰撞”、“空闲列表”）选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定（在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。）。</li>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>接下来 ,虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
<li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——<code>＜init＞</code>方法还没有执行，所有的字段都还为零。所以一般来说（由字节码中是否跟随invokespecial指令所定），执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ul>
<h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ...args)</span></span>&#123;</span><br><span class="line">        InnerClass xx = <span class="keyword">new</span> StaticTest().<span class="function">new <span class="title">InnerClass</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="comment">//InnerClass xx = new StaticTest.InnerClass();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello :: &quot;</span>+xx.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>非静态内部类需要在<code>StaticTest</code>实例化获得<strong>对象</strong>之后，才被加载到堆内存中。</del></p>
<p>调用非静态内部类实例化对象时：1.加载外部类；2.外部类构造；3.非静态内部类加载；4.非静态内部类构造。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ...args)</span></span>&#123;</span><br><span class="line"><span class="comment">//      InnerClass xx = new StaticTest().new InnerClass();</span></span><br><span class="line">        InnerClass xx = <span class="keyword">new</span> InnerClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello :: &quot;</span>+xx.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>先加载<code>main</code>方法，运行<code>main</code>方法前，第一步<code>StaticTest</code>的加载，在加载过程中，已经扫描到静态内部类（类变量），在准备阶段分配内存并赋默认值，存到方法区（方法区是概念区域，具体空间可以是在堆上）中。<code>new</code>方法的执行，已经到了执行阶段。所以在<code>main</code>（静态）方法中，可以直接用<code>new</code>实例化<code>InnerClass</code>静态内部类，实际上只是在栈帧的局部变量里保存了静态内部类的引用。</del></p>
<p>静态内部类被主动调用时，才会去加载。示例代码会先加载外部类的原因是<code>main</code>函数在外部类中，若<code>main</code>在另外一个类中，<code>StaticTest</code>可以不被加载。静态内部类可以被实例化，且实例化的对象不同，但是不会常驻内存。</p>
<h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><p>静态成员属于类，普通成员属于类的实例对象。</p>
<p>通过反编译内部类对应的 <code>class</code> 文件，可以看出内部类在构造方法中，传入了外部类的引用 <code>this$0</code>，内部类在访问外部类的成员或方法时，都需要传递该参数 <code>this.this$0</code>，只有静态内部类例外。这也可看出为什么静态内部类在实例化时不需要外部类实例化，而其他内部类在实例化时必须先实例化外部类了。<br>换句话说：<strong>静态内部类不持有外部类对象的引用，而其他内部类都会持有</strong>。</p>
<p>内部类虽然和外部类写在同一个文件中，但是编译完成后会生成各自的 <code>class</code> 文件，编译过程中：</p>
<ul>
<li>编译器自动为非静态内部类添加一个成员变量，这个成员变量的类型和外部类的类型相同，这个成员变量就是指向外部类对象的引用</li>
<li>编译器自动为非静态内部类的构造方法添加一个参数，参数的类型是外部类的类型，这个参数为内部类中添加的成员变量赋值</li>
<li>在调用非静态内部类的构造函数初始化内部类对象时，会默认传入外部类的引用</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>路线与基础</category>
      </categories>
  </entry>
  <entry>
    <title>wallet</title>
    <url>/blog/7c68921f.html</url>
    <content><![CDATA[<p>钱包的定义：存储加密数字货币的软件程序；<br><a id="more"></a><br>关键：安全方便地生成、保存和备份/恢复密钥。</p>
<h1 id="钱包发展历史"><a href="#钱包发展历史" class="headerlink" title="钱包发展历史"></a>钱包发展历史</h1><h2 id="非确定性（随机）钱包"><a href="#非确定性（随机）钱包" class="headerlink" title="非确定性（随机）钱包"></a>非确定性（随机）钱包</h2><ol>
<li>钱包生成私钥，私钥之间没有任何关系，都是独立的；</li>
<li>安全性，资产不放到一个篮子里；</li>
<li>带来了麻烦，私钥都要保存、备份，导入导出也麻烦。</li>
</ol>
<h2 id="确定性（种子）钱包"><a href="#确定性（种子）钱包" class="headerlink" title="确定性（种子）钱包"></a>确定性（种子）钱包</h2><ol>
<li>引入了种子的概念；</li>
<li>解决了非确定钱包存储和备份的麻烦，一个种子搞定；</li>
<li>一个种子能恢复所有的私钥。</li>
</ol>
<h2 id="分层确定性钱包（HD钱包）"><a href="#分层确定性钱包（HD钱包）" class="headerlink" title="分层确定性钱包（HD钱包）"></a>分层确定性钱包（HD钱包）</h2><ol>
<li>HD钱包（BIP-32）的全文：hierarchical Deterministic ；</li>
<li>私钥的衍生结构是树状结构，父密钥可以衍生一系列子密钥；子密钥又可以衍生孙密钥，无限衍生；</li>
<li>引入了助记词概念（BIP-39），只要记住助记词就行了。</li>
</ol>
<h3 id="生成助记词"><a href="#生成助记词" class="headerlink" title="生成助记词"></a>生成助记词</h3><p>使用BIP-39中定义的标准化过程，钱包自动生成助记词。钱包从一个熵源开始，添加一个校验和，然后将熵映射到一个单词列表:</p>
<ol>
<li>创建128到256位的随机序列（熵）。</li>
<li>通过获取SHA256哈希的第一（熵长度/ 32）位来创建随机序列的校验和。</li>
<li>将校验和添加到随机序列的末尾。</li>
<li>将序列分成11位的部分。</li>
<li>将每个11位值映射到来自2048个单词的预定义字典中的单词。</li>
<li>助记词是单词序列。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">熵（bits）</th>
<th style="text-align:center">Checksum（bits）</th>
<th style="text-align:center">熵+Checksum（bits）</th>
<th style="text-align:center">助记词长度（words）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">128</td>
<td style="text-align:center">4</td>
<td style="text-align:center">132</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">160</td>
<td style="text-align:center">5</td>
<td style="text-align:center">165</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">192</td>
<td style="text-align:center">6</td>
<td style="text-align:center">198</td>
<td style="text-align:center">18</td>
</tr>
<tr>
<td style="text-align:center">224</td>
<td style="text-align:center">7</td>
<td style="text-align:center">231</td>
<td style="text-align:center">21</td>
</tr>
<tr>
<td style="text-align:center">256</td>
<td style="text-align:center">8</td>
<td style="text-align:center">264</td>
<td style="text-align:center">24</td>
</tr>
</tbody>
</table>
</div>
<h1 id="备份方式"><a href="#备份方式" class="headerlink" title="备份方式"></a>备份方式</h1><p>除了私钥和之前提到的助记词方式，还有<a href="/blog/2475f3a5.html" title="keystore">keystore</a>文件的方式。</p>
<h1 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h1><p><a href="https://www.jianshu.com/p/9c5af78453f4">《精通以太坊》-钱包</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>eth</category>
      </categories>
  </entry>
  <entry>
    <title>交易</title>
    <url>/blog/d998082e.html</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>下图是以太坊交易数据结构，根据用途，我将其划分为四部分。<br><a id="more"></a><br><img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1050" alt="405a77a461ccd9c3c423461bc0815c08.png"><br>开头是一个 uint64 类型的数字，称之为随机数。用于撤销交易、防止双花和修改以太坊账户的 Nonce 值（细节在讲解交易执行流程时讲解）。<br>第二部分是关于交易执行限制的设置，gasLimit 为愿意供以太坊虚拟机运行的燃料上限。 gasPrice 是愿意支付的燃料单价。gasPrcie * gasLimit 则为愿意为这笔交易支付的最高手续费。<br>我从程序执行逻辑上可以这样解释第三部分。是交易发送者输入以太坊虚拟机执行此交易的初始信息： 虚拟机操作对象（接收方 To）、从交易发送方转移到操作对象的资产（Value），以及虚拟机运行时入参(input)。其中 To 为空时，意味着虚拟机无可操作对象，此时虚拟机将利用 input 内容部署一个新合约。<br>第四部分是交易发送方对交易的签名结果，可以利用交易内容和签名结果反向推导出签名者，即交易发送方地址。<br>四部分内容的组合，解决了交易安全问题、实现了智能合约的互动方式以及提供了灵活可调整的交易手续费。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将交易对象定义为一个对外可访问的Transation对象和内嵌的对外部包不可见的txdata 。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">	data txdata</span><br><span class="line">	<span class="comment">// caches</span></span><br><span class="line">	hash atomic.Value</span><br><span class="line">	size atomic.Value</span><br><span class="line">	from atomic.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">	AccountNonce <span class="keyword">uint64</span>     </span><br><span class="line">	Price        *big.Int  </span><br><span class="line">	GasLimit     <span class="keyword">uint64</span>     </span><br><span class="line">	Recipient    *common.Address </span><br><span class="line">	Amount       *big.Int</span><br><span class="line">	Payload      []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Signature values</span></span><br><span class="line">	V *big.Int</span><br><span class="line">	R *big.Int</span><br><span class="line">	S *big.Int</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is only used when marshaling to JSON.</span></span><br><span class="line">	Hash *common.Hash <span class="string">`json:&quot;hash&quot; rlp:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><p>算法归类：<br><img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1051" alt="3287dddb9d106ac28f2c2e3f46c47b63.png"></p>
<h2 id="比特币与以太坊的区别"><a href="#比特币与以太坊的区别" class="headerlink" title="比特币与以太坊的区别"></a>比特币与以太坊的区别</h2><h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>比特币在 BIP66 中对签名数据格式采用严格的 DER 编码格式，其签名数据格式如下：<br><code>0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]</code></p>
<h3 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h3><p>对比比特币签名，以太坊的签名格式是r+s+v。 r 和 s 是 ECDSA 签名的原始输出，而末尾的一个字节为 recovery id 值，但在以太坊中用V表示，v 值为 1 或者 0。recovery id 简称 recid，表示从内容和签名中成功恢复出公钥时需要查找的次数（因为根据r值在椭圆曲线中查找符合要求的坐标点可能有多个），但在比特币下最多需要查找两次。这样在签名校验恢复公钥时，不需要遍历查找，一次便可找准公钥，加速签名校验速度。</p>
<h4 id="签名流程"><a href="#签名流程" class="headerlink" title="签名流程"></a>签名流程</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sign</span><span class="params">(hash []<span class="keyword">byte</span>, prv *ecdsa.PrivateKey)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hash) != <span class="number">32</span> &#123;<span class="comment">//❶</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;hash is required to be exactly 32 bytes (%d)&quot;</span>, <span class="built_in">len</span>(hash))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> prv.Curve != btcec.S256() &#123;<span class="comment">//❷</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;private key curve is not secp256k1&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//❸</span></span><br><span class="line">	sig, err := btcec.SignCompact(btcec.S256(), (*btcec.PrivateKey)(prv), hash, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Convert to Ethereum signature format with &#x27;recovery id&#x27; v at the end.</span></span><br><span class="line">	v := sig[<span class="number">0</span>] - <span class="number">27</span> <span class="comment">//❹</span></span><br><span class="line">	<span class="built_in">copy</span>(sig, sig[<span class="number">1</span>:])<span class="comment">//❺</span></span><br><span class="line">	sig[<span class="number">64</span>] = v</span><br><span class="line">	<span class="keyword">return</span> sig, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❶ 首先，签名是针对 32 字节的 byte，实际上是对应待签名内容的哈希值，以太坊中哈希值common.Hash长度固定为 32。比如对交易签名时传入的是交易哈希crypto.Sign(tx.Hash()[:], prv)。<br>❷ 确保私钥的曲线算法是比特币的 secp256k1。目的是控制所有签名均通过 secp256k1 算法计算。<br>❸ 调用比特币的签名函数，传入 secp256k1 、私钥和签名内容, 并说明并非压缩的私钥。此时 SignCompact 函数返还一定格式的签名。其格式为：<code>[27 + recid] [R] [S]</code><br>❹ 以太坊将比特币中记录的 recovery id 提取出。减去 27 的原因是，比特币中第一个字节的值等于27+recid，因此 recid= sig[0]-27。<br>❺ 以太坊签名格式是[R] [S] [V]，和比特币不同。因此需要进行调换，将 R 和 S 值放到前面，将 recid 放到最后。</p>
<h3 id="交易数据签名"><a href="#交易数据签名" class="headerlink" title="交易数据签名"></a>交易数据签名</h3><p>❶ 交易签名时，需要提供一个签名器 (Signer) 和私钥(PrivateKey)。需要 Singer 是因为在 EIP155 修复简单重复攻击漏洞后，需要保持旧区块链的签名方式不变，但又需要提供新版本的签名方式。因此通过接口实现新旧签名方式，根据区块高度创建不同的签名器。<br>❷ 重点介绍 EIP155 改进提案中所实现的新哈希算法，主要目的是获取交易用于签名的哈希值 TxSignHash。和旧方式相比，哈希计算中混入了链 ID 和两个空值。注意这个哈希值 TxSignHash 在 EIP155 中并不等同于交易哈希值。<br>❸ 内部利用私钥使用 secp256k1 加密算法对TxSignHash签名，获得签名结果sig。<br>❹ 执行交易WithSignature方法，将签名结果解析成三段R、S、V，拷贝交易对象并赋值签名结果。最终返回一笔新的已签名交易。<br><img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1052" alt="120f4b26c82dc98598ad4c2a9f086afd.png"><br>上图中还有一个关键数据，则 Signer 是如何生成 R 、S、V 值的。从前面的签名算法过程，可以知道 R 和 S 是 ECDSA 签名的原始输出，V 值是 recid，其值是 0 或者 1。但是在交易签名时，V 值不再是 recid, 而是 <code>recid+ chainID*2+ 35</code>。</p>
<h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>关键点在于调用校验签名函数时，第三个参数 sig 送入的是 <code>sig[:len(sig)-1]</code>去掉了末尾的一个字节。这是因为函数VerifySignature要求 sig参数必须是<code>[R] [S]</code>格式，因此需要去除末尾的<code>[V]</code>。</p>
<h1 id="交易回执receipt"><a href="#交易回执receipt" class="headerlink" title="交易回执receipt"></a>交易回执receipt</h1><p>回执信息分为三部分：共识信息、交易信息、区块信息。下面分别介绍各类信息。<br><img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1053" alt="0cadc48e6258467e7ca4ee8837b2823c.png"></p>
<h2 id="交易回执内容介绍"><a href="#交易回执内容介绍" class="headerlink" title="交易回执内容介绍"></a>交易回执内容介绍</h2><h3 id="交易回执共识信息"><a href="#交易回执共识信息" class="headerlink" title="交易回执共识信息"></a>交易回执共识信息</h3><p>共识意味在在校验区块合法性时，这部分信息也参与校验。这些信息参与校验的原因是确保交易必须在区块中的固定顺序中执行，且记录了交易执行后的状态信息。这样可强化交易顺序。</p>
<ul>
<li>Status： 成功与否，1表示成功，0表示失败。注意在高度1035301前，并非1或0，而是 StateRoot，表示此交易执行完毕后的以太坊状态。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> root []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">if</span> config.IsByzantium(header.Number) &#123;</span><br><span class="line"> statedb.Finalise(<span class="literal">true</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">receipt := types.NewReceipt(root, failed, *usedGas)</span><br></pre></td></tr></table></figure></li>
<li>CumulativeGasUsed： 区块中已执行的交易累计消耗的Gas，包含当前交易。</li>
<li>Logs: 当前交易执行所产生的智能合约事件列表。</li>
<li>Bloom：是从 Logs 中提取的事件布隆过滤器，用于快速检测某主题的事件是否存在于Logs中。</li>
</ul>
<p>这些信息是如何参与共识校验的呢？实际上参与校验的仅仅是回执哈希，而回执哈希计算只包含这些信息。<br>首先，在校验时获取整个区块回执信息的默克尔树的根哈希值。再判断此哈希值是否同区块头定义内容相同。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receiptSha := types.DeriveSha(receipts)</span><br><span class="line"><span class="keyword">if</span> receiptSha != header.ReceiptHash &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid receipt root hash (remote: %x local: %x)&quot;</span>,</span><br><span class="line">   header.ReceiptHash, receiptSha)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而函数types.DeriveSha中生成根哈希值，是将列表元素（这里是交易回执）的RLP编码信息构成默克树，最终获得列表的哈希值。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeriveSha</span><span class="params">(list DerivableList)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">   keybuf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">   trie := <span class="built_in">new</span>(trie.Trie)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &amp;lt; list.Len(); i++ &#123;</span><br><span class="line">      keybuf.Reset()</span><br><span class="line">      rlp.Encode(keybuf, <span class="keyword">uint</span>(i))</span><br><span class="line">      trie.Update(keybuf.Bytes(), list.GetRlp(i))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> trie.Hash()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Receipts)</span> <span class="title">GetRlp</span><span class="params">(i <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">   bytes, err := rlp.EncodeToBytes(r[i])</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>继续往下看，交易回执实现了 RLP 编码接口。在方法EncodeRLP中是构建了一个私有的receiptRLP。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Receipt)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rlp.Encode(w, </span><br><span class="line">        &amp;amp;receiptRLP&#123;r.statusEncoding(), r.CumulativeGasUsed, r.Bloom, r.Logs&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从代码中可以看出 receiptRLP 仅仅包含上面提到的参与共识校验的内容。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> receiptRLP <span class="keyword">struct</span> &#123;</span><br><span class="line">   PostStateOrStatus []<span class="keyword">byte</span></span><br><span class="line">   CumulativeGasUsed <span class="keyword">uint64</span></span><br><span class="line">   Bloom             Bloom</span><br><span class="line">   Logs              []*Log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="交易回执交易信息"><a href="#交易回执交易信息" class="headerlink" title="交易回执交易信息"></a>交易回执交易信息</h3><p>这部分信息记录的是关于回执所对应的交易信息，有：</p>
<ul>
<li>TxHash ： 交易回执所对应的交易哈希。</li>
<li>ContractAddress： 当这笔交易是部署新合约时，记录新合约的地址。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> msg.To() == <span class="literal">nil</span> &#123;</span><br><span class="line"> receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>GasUsed: 这笔交易执行所消耗的Gas燃料。</li>
</ul>
<p>这些信息不参与共识的原因是这三项信息已经在其他地方校验。</p>
<ul>
<li>TxHash: 区块有校验交易集的正确性。</li>
<li>ContractAddress： 如果是新合约，实际上已经提交到以太坊状态 State 中。</li>
<li>GasUsed： 已属于CumulativeGasUsed的一部分。<h3 id="交易回执区块信息"><a href="#交易回执区块信息" class="headerlink" title="交易回执区块信息"></a>交易回执区块信息</h3>这部分信息完全是为了方便外部读取交易回执，不但知道交易执行情况，还能方便的指定该交易属于哪个区块中第几笔交易。</li>
<li>BlockHash: 交易所在区块哈希。</li>
<li>BlockNumber: 交易所在区块高度.</li>
<li>TransactionIndex： 交易在区块中的序号。</li>
</ul>
<p>这三项信息，主要是在数据库 Leveldb 中读取交易回执时，实时指定。</p>
<h2 id="交易回执构造"><a href="#交易回执构造" class="headerlink" title="交易回执构造"></a>交易回执构造</h2><p>交易回执是在以太坊虚拟机处理完交易后，根据结果整理出的交易执行结果信息。反映了交易执行前后以太坊变化以及交易执行状态。<br>构造细节，已经在前面提及，不再细说。这里给出的完整的交易回执构造代码。</p>
<h2 id="交易回执存储"><a href="#交易回执存储" class="headerlink" title="交易回执存储"></a>交易回执存储</h2><p>交易回执作为交易执行中间产物，为了方便快速获取某笔交易的执行明细。以太坊中有跟随区块存储时实时存储交易回执。但为了降低存储量，只存储了必要内容。<br>首先，在存储时，将交易回执对象转换为精简内容。<br>精简内容是专门为存储定义的一个结构ReceiptForStorage。存储时将交易回执集进行RLP编码存储。<br>所以看存储了哪些内容，只需要看 ReceiptForStorage的 EncodeRLP方法。<br>根据EncodeRLP方法实现，可以得出在存储时仅仅存储了部分内容，且 Logs 内容同样进行了特殊处理LogForStorage。<br><img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1054" alt="e834d2a3965e2123455256d94195e8b9.png"></p>
<h2 id="交易回执示例"><a href="#交易回执示例" class="headerlink" title="交易回执示例"></a>交易回执示例</h2><p>上面讲完交易回执内容与构造和存储，下面我从etherscan上查找三中不同类型的交易回执数据，供大家找找感觉。</p>
<h3 id="一笔包含日志的交易回执"><a href="#一笔包含日志的交易回执" class="headerlink" title="一笔包含日志的交易回执"></a>一笔包含日志的交易回执</h3><p>交易 0x01e180……0a4021 执行成功，且包含了两个事件日志。<img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1055" alt="7fd11394764f9bb948f41ab2e6fce668.png"></p>
<h3 id="一笔成功部署合约的交易回执"><a href="#一笔成功部署合约的交易回执" class="headerlink" title="一笔成功部署合约的交易回执"></a>一笔成功部署合约的交易回执</h3><p>如果是部署合约的交易，可以看到 contractAddress 有值。<img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1056" alt="d57752b9fb4c7d93d4627b6fc2e7829c.png"></p>
<h3 id="一笔含-StateRoot的交易回执"><a href="#一笔含-StateRoot的交易回执" class="headerlink" title="一笔含 StateRoot的交易回执"></a>一笔含 StateRoot的交易回执</h3><p>和其他交易回执内容不同，在高度1035301 前的交易并无 status 字段，而是 root 字段。是在后续改进中去除 root 采用 status 的。<img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1057" alt="4070260725da26b8192ffef9d5fa6f2b.png"></p>
<h3 id="一笔交易失败的交易回执"><a href="#一笔交易失败的交易回执" class="headerlink" title="一笔交易失败的交易回执"></a>一笔交易失败的交易回执</h3><p>如果是失败的交易，则 status为0。<img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1058" alt="6f48e8e2a8c44ab8c5a4ff5238a20e77.png"></p>
<h1 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h1><h2 id="关键流程"><a href="#关键流程" class="headerlink" title="关键流程"></a>关键流程</h2><p><img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1059" alt="6f08e89d73958dcfbb2eb80499105e1f.png"><br>区分本地交易和远程交易。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1060" alt="beee3c1028c74c403a37bad3a875edc7.png"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li>Locals: 定义了一组视为local交易的账户地址。任何来自此清单的交易均被视为 local 交易。</li>
<li>NoLocals: 是否禁止local交易处理。默认为 fasle,允许 local 交易。如果禁止，则来自 local 的交易均视为 remote 交易处理。</li>
<li>Journal： 存储local交易记录的文件名，默认是 ./transactions.rlp。</li>
<li>Rejournal：定期将local交易存储文件中的时间间隔。默认为每小时一次。</li>
<li>PriceLimit： remote交易进入交易池的最低 Price 要求。此设置对 local 交易无效。默认值1。</li>
<li>PriceBump：替换交易时所要求的价格上调涨幅比例最低要求。任何低于要求的替换交易均被拒绝。</li>
<li>AccountSlots： 当交易池中可执行交易（是已在等待矿工打包的交易）量超标时，允许每个账户可以保留在交易池最低交易数。默认值是 16 笔。</li>
<li>GlobalSlots： 交易池中所允许的可执行交易量上限，高于上限时将释放部分交易。默认是 4096 笔交易。</li>
<li>AccountQueue：交易池中单个账户非可执行交易上限，默认是64笔。</li>
<li>GlobalQueue： 交易池中所有非可执行交易上限，默认1024 笔。</li>
<li>Lifetime： 允许 remote 的非可执行交易可在交易池存活的最长时间。交易池每分钟检查一次，一旦发现有超期的remote 账户，则移除该账户下的所有非可执行交易。默认为3小时。</li>
</ul>
<h3 id="链状态"><a href="#链状态" class="headerlink" title="链状态"></a>链状态</h3><p>所有进入交易池的交易均需要被校验，最基本的是校验账户余额是否足够支付交易执行。或者 交易 nonce 是否合法。在交易池中维护的最新的区块StateDB。当交易池接收到新区块信号时，将立即重置 statedb。核心是将交易池中已经不符合要求的交易删除并更新整理交易。</p>
<h3 id="本地交易"><a href="#本地交易" class="headerlink" title="本地交易"></a>本地交易</h3><p>在交易池中将交易标记为 local 的有多种用途：</p>
<ul>
<li>在本地磁盘存储已发送的交易。这样，本地交易不会丢失，重启节点时可以重新加载到交易池，实时广播出去。</li>
<li>可以作为外部程序和以太坊沟通的一个渠道。外部程序只需要监听文件内容变化，则可以获得交易清单。</li>
<li>local交易可优先于 remote 交易。对交易量的限制等操作，不影响 local 下的账户和交易。</li>
</ul>
<p>只有属于 local 账户的交易才会被记录。如果仅仅是这样的话，journal 文件是否会跟随本地交易而无限增长？答案是否定的，虽然无法实时从journal中移除交易。但是支持定期更新journal文件。<br>journal 并不是保存所有的本地交易以及历史，他仅仅是存储当前交易池中存在的本地交易。因此交易池会定期对 journal 文件执行 rotate，将交易池中的本地交易写入journal文件，并丢弃旧数据。</p>
<h3 id="新交易信号"><a href="#新交易信号" class="headerlink" title="新交易信号"></a>新交易信号</h3><p>交易池支持外部订阅新交易事件信号。任何订阅此事件的子模块，在交易池出现新的可执行交易时，均可实时接受到此事件通知，并获得新交易信息。<br>需要注意的是并非所有进入交易池的交易均被通知外部，而是只有交易从非可执行状态变成可执行状态后才会发送信号。</p>
<h2 id="交易存储"><a href="#交易存储" class="headerlink" title="交易存储"></a>交易存储</h2><p>下图是交易池对本地待处理交易的磁盘存储管理流程，涉及加载、实时写入和定期更新维护。<br><img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1062" alt="93349fcc8c80c02921de276bc62ccec4.png"></p>
<h3 id="加载已存储交易"><a href="#加载已存储交易" class="headerlink" title="加载已存储交易"></a>加载已存储交易</h3><p>在交易池首次启动 journal 时，将主动将该文件已存储的交易加载到交易池。<br>交易并非单笔直接载入交易池，而是采用批量提交模式，每 1024 笔交易提交一次。</p>
<h3 id="存储交易"><a href="#存储交易" class="headerlink" title="存储交易"></a>存储交易</h3><p>当交易池新交易来自于本地账户时，如果已开启记录本地交易，则将此交易加入journal。到交易池时，将实时存储到 journal 文件中。<br>而 journal.insert则将交易实时写入文件流中，相当于实时存储到磁盘。而在写入时，是将交易进行RLP编码。</p>
<h3 id="journal定期更新"><a href="#journal定期更新" class="headerlink" title="journal定期更新"></a>journal定期更新</h3><p>journal 的目的是长期存储本地尚未完成的交易，以便交易不丢失。而文件内容属于交易的RLP编码内容，不便于实时清空已完成或已无效的交易。因此以太坊采取的是定期将交易池待处理交易更新到 journal 文件中。<br>首先，在首次加载文件中的交易到交易池后，利用交易池的检查功能，将已完成或者已完成的交易拒绝在交易池外。在加载完成后，交易池中的交易仅仅是本地账户待处理的交易，因此在加载完成后，立即将交易池中的所有本地交易覆盖journal文件。</p>
<h2 id="交易入队"><a href="#交易入队" class="headerlink" title="交易入队"></a>交易入队</h2><h3 id="校验交易合法性"><a href="#校验交易合法性" class="headerlink" title="校验交易合法性"></a>校验交易合法性</h3><ul>
<li>首先是防止DOS攻击，不允许交易数据超过32KB。</li>
<li>接着不允许交易的转账金额为负数，实际上这次判断难以命中，原因是从外部接收的交易数据属RLP编码，是无法处理负数的。当然这里做一次校验，更加保险。</li>
<li>区块中的GAS量是每笔交易执行消耗GAS之和，故不可能一笔交易的GAS上限超过区块GAS限制。</li>
<li>每笔交易都需要携带交易签名信息，并从签名中解析出签名者地址。只有合法的签名才能成功解析出签名者。一旦解析失败拒绝此交易。</li>
<li>既然知道是交易发送者(签名者)，那么该发送者也可能是来自于交易池所标记的local账户。因此当交易不是local交易时，还进一步检查是否属于local账户。如果不是local交易，那么交易的GasPrice 也必须不小于交易池设定的最低GasPrice。</li>
<li>交易池中不允许出现交易的Nonce 小于此账户当前Nonce的交易。</li>
<li>检查该账户余额，只有账户资产充足时，才允许交易继续，否则在虚拟机中执行交易，交易也必将失败。</li>
<li>检查gasLimit。<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3>以太坊将交易按状态分为两部分：可执行交易和非可执行交易。分别记录在pending容器中和 queue 容器中。<br><img src="evernotecid://336C97AE-E025-4943-9348-E855206F392C/appyinxiangcom/18710579/ENResource/p1061" alt="9d9a4d4ba6366797ddae340512ff01b0.png"><br>如上图所示，交易池先采用一个 txLookup (内部为map）跟踪所有交易。同时将交易根据本地优先，价格优先原则将交易划分为两部分 queue 和 pending。而这两部交易则按账户分别跟踪。</li>
</ul>
<p>在进入交易队列前，将判断所有交易队列 all 是否已经达到上限。如果到了上限，则需要从交易池或者当前交易中移除优先级最低交易。<br>交易是有根据 from 分组管理，且一个 from 由分非可执行交易队列（queue）和可执行交易队列（pending）。新交易默认是要在非可执行队列中等待指示，但是一种情况时，如果该 from 的可执行队列中存在一个相同 nonce 的交易时，需要进一步识别是否能替换。只要价格(gasPrice)高于原交易，则允许替换。一旦可以替换，则替换掉旧交易，移除旧交易，并将交易同步存储到 all 交易内存池中。<br>检查完是否需要替换 pending 交易后，则将交易存入非可执行队列。同样，在进入非可执行队列之前，也要检查是否需要替换掉相同 nonce 的交易。<br>最后，如果交易属于本地交易还需要额外关照。如果交易属于本地交易，但是本地账户集中不存在此 from 时，更新本地账户集，避免交易无法被存储。另外，如果已开启存储本地交易，则实时存储本地交易。</p>
<h2 id="容量内存限制"><a href="#容量内存限制" class="headerlink" title="容量内存限制"></a>容量内存限制</h2><h3 id="删除旧交易"><a href="#删除旧交易" class="headerlink" title="删除旧交易"></a>删除旧交易</h3><p>当新区块来到时，很有可能包含交易内存池中一些账户的交易。一旦存在，则意味着账户的 nonce 和账户余额被存在变动。而只有高于当前新 nonce 交易才能被执行，且账户余额不足以支撑交易执行时，交易也将执行失败。<br>因此，在新区块来到后，删除所有低于新nonce的交易。 再根据账户可用余额，来移除交易开销（<code>amount+gasLimit*gasPrice</code>）高于此余额的交易。</p>
<h3 id="转移交易或释放"><a href="#转移交易或释放" class="headerlink" title="转移交易或释放"></a>转移交易或释放</h3><p>在非可执行队列中的交易有哪些可以转移到可执行队列呢？因为交易 nonce 的缘故，如果queue队列中存在低于 pending 队列的最小nonce的交易，则可直接转移到pending中。<br>转移后，该账户的交易可能超过所允许的排队交易笔数，如果超过则直接移除超过上限部分的交易。当然这仅仅针对remote交易。</p>
<h3 id="检查pending数量"><a href="#检查pending数量" class="headerlink" title="检查pending数量"></a>检查pending数量</h3><p>如果超过上限，则分两种策略移除超限部分。<br>优先从超上限(pool.config.AccountSlots)的账户中移除交易。在移除交易时，并非将某个账户的交易全部删除，而是每个账户轮流删除一笔交易，直到低于交易上限。同时，还存在一个特殊删除策略，并非直接轮流每个账户，而是通过一个动态阀值控制，阀值控制遍历顺序，存在一定的随机性。<br>如果仍然还超限，则继续采用直接遍历方式，删除交易，直到低于限制。</p>
<h3 id="检查queue数量"><a href="#检查queue数量" class="headerlink" title="检查queue数量"></a>检查queue数量</h3><p>删除交易的策略完成根据每个账户pending交易的时间处理，依次删除长时间存在于pending的账户交易。在交易进入pending 时会更新账户级的心跳时间，代表账户最后pending交易活动时间。时间越晚，说明交易越新。</p>
<h1 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h1><p><a href="https://learnblockchain.cn/2019/06/03/eth-txpool">以太坊交易流程及交易池 TXpool 分析</a>  </p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>eth</category>
      </categories>
  </entry>
  <entry>
    <title>协程模型</title>
    <url>/blog/e26a8b4f.html</url>
    <content><![CDATA[<h1 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h1><h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p>早起基于操作系统提供的线程的概念来实现并发编程，一个连接一个线程。在连接数目渐渐增多的时候，可扩展性很差，因为操作系统本身并不擅长处理大量的线程：任何一个线程的创建都需要设计到栈空间的分配、线程私有资源的创建和维护；同时大量的线程在操作系统层面被调度的时候，也很难保证调度策略的公平和有效。这也是C10K问题的由来。<br><a id="more"></a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><p>通过在内核层面的IO多路复用角度触发，通过引入epoll等技术来允许一个单一的用户线程的IO调用可以管理海量的网络连接而完美地解决了传统的select调用层面的问题。<br>这个方案解决了一个线程处理海量网络IO的问题，但是对和网络无关的并发任务并没有多少帮助。同时，这种方案下的异步代码损失了可读性。</p>
<h3 id="用户态线程-Green-Thread"><a href="#用户态线程-Green-Thread" class="headerlink" title="用户态线程/Green Thread"></a>用户态线程/Green Thread</h3><p>将逻辑线程的管理逻辑都放在操作系统的用户态来管理，而操作系统层面对这些机制一无所知。 运行在用户态的线程管理程序（往往是比较底层的基础库或者组件）自己负责这些线程状态的管理和调度。</p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>通过引入一个逻辑上抽象的概念来简化编程模型。某种程度上说，可以将一个协程看作是一段可以以非阻塞的方式高效执行的代码；而多个协程之间可以通过特定关键字或者语句的方式进行组合，以便程序员可以直接写出看起来是同步执行而实际上底层却是被异步调度执行的代码。这种方案既解决了程序员在异步编程上的心智负担，又解决了C10K问题。</p>
<h1 id="Go的有栈协程"><a href="#Go的有栈协程" class="headerlink" title="Go的有栈协程"></a>Go的有栈协程</h1><p>go语言被设计为天生支持协程，在代码中使用 go 关键字就能启动一个goroutinue，也就是协程。go的runtime两大主要职责：一个是垃圾回收，另一个就是调度协程。 go的协程调度模型可以称作GMP模型，其中：</p>
<ul>
<li>G 表示 goroutinue，也就是协程</li>
<li>M 表示 os thread</li>
<li>P 表示调度上下文，每个M必须要先获取一个P，才能够开始执行G。</li>
</ul>
<p>最初的调度模型中没有P的概念，在1.1版本后，go的调度器中引入了P，这么做主要是为了提升调度的性能，尽力的保证每个可运行的G都能够尽快运行。调度机制主要特点如下：</p>
<ul>
<li>每个P都有一个可运行的G队列</li>
<li>另外有一个全局的可以运行G队列</li>
<li>M获取到P后，从P的运行队列中获取G来运行</li>
<li>如果P本地的运行队列为空，则尝试从全局队列中获取G来运行</li>
<li>如果全局的运行队列也为空，则尝试从其他P的运行队列中获取G</li>
</ul>
<p>每个G运行的时间是由调度器来控制的，不会出现让某个G一直运行，而让其他G长时间的等待。如果M在运行G的时候发生了阻塞，比如block在某个系统调用，M则也会被阻塞住，P的本地队列会调度到其他M上执行。<br>P的数量可以通过GOMAXPROCS函数来设置，因为每个M对应一个P，因此这个函数也可以认为是设置了go程序最大的线程数量。（注意，M是可以大于P的，例如：一个M阻塞住了，那么正在运行的M数目还是和P的数目一样，这样总的M数目就大于P了。）</p>
<p>go语言中，协程的实现与操作系统多线程非常相似，依托于操作系统的多线程，在Runtime实现了一个协作式的调度器。go的系统调用是对底层系统调用的一个封装，被执行时，会将协程的上下文保存到堆栈中。</p>
<h1 id="Rust的协程"><a href="#Rust的协程" class="headerlink" title="Rust的协程"></a>Rust的协程</h1><p>Rust早期也是支持一个与go协程类似的绿色线程。在0.7以后，绿色线程就被删除了。因为Rust中Native thread与协程运行库的API很难统一。</p>
<h2 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h2><p>Rust的无栈协程将协程上下文放到Generator生成的状态机中，保存在全局栈中，而不必为每个协程分配一个动态大小的栈。<br>无栈协程不需要与CPU相关的代码来分配栈内存，有了更好的跨平台能力。</p>
<h2 id="await和async"><a href="#await和async" class="headerlink" title="await和async"></a>await和async</h2><p>在Rust1.36稳定版中加入了两个新的关键字：await和async。<br>引入这两个关键字使得Rust异步代码能够像同步顺序代码一样书写，避免手写poll方法的繁琐。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://skyscribe.github.io/post/2019/12/07/rust-asynchronous-model-and-features/">Rust语言的异步编程模型和协程支持</a><br><a href="https://segmentfault.com/a/1190000024462355">无栈协程 | Rust学习笔记</a><br><a href="https://www.jianshu.com/p/a609a2d8e998">go和rust的协程模型</a></p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>异步</category>
      </categories>
  </entry>
  <entry>
    <title>内存模型</title>
    <url>/blog/e6493c73.html</url>
    <content><![CDATA[<h1 id="Java程序执行流程"><a href="#Java程序执行流程" class="headerlink" title="Java程序执行流程"></a>Java程序执行流程</h1><p>程序执行流程见下图：<br><a id="more"></a><br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105824.png" alt="execute"></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105833.gif" alt="jvmdebug"></p>
<p>Java 源码编译由以下三个过程组成：</p>
<ul>
<li>分析和输入到符号表</li>
<li>注解处理</li>
<li>语义分析和生成 class 文件</li>
</ul>
<p>最后生成的 class 文件由以下部分组成：</p>
<ul>
<li>结构信息。包括 class 文件格式版本号及各部分的数量与大小的信息。</li>
<li>元数据。对应于 Java 源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池。</li>
<li>方法信息。对应 Java 源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息。</li>
</ul>
<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="类加载的生命周期（JVM执行class字节码）"><a href="#类加载的生命周期（JVM执行class字节码）" class="headerlink" title="类加载的生命周期（JVM执行class字节码）"></a>类加载的生命周期（JVM执行class字节码）</h2><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105839.png" alt="lifetime"></p>
<h3 id="加载（loading）"><a href="#加载（loading）" class="headerlink" title="加载（loading）"></a>加载（loading）</h3><p>”加载“是”类加载机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：</p>
<p>（1）通过一个类的全限定名来获取其定义的二进制字节流</p>
<p>（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</p>
<p>（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。</p>
<p><strong>注意此时会扫描到我们的代码中是否有静态变量或者是静态方法等等这些静态数据结构，还未分配内存。（不包括静态内部类）</strong></p>
<h3 id="验证（verification）"><a href="#验证（verification）" class="headerlink" title="验证（verification）"></a>验证（verification）</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="准备（preparation）"><a href="#准备（preparation）" class="headerlink" title="准备（preparation）"></a>准备（preparation）</h3><p><strong>准备阶段主要为类变量分配内存并设置默认初始值</strong>。这些内存都在方法区分配。注意此时就会为我们的类变量也就是静态变量分配内存，但是普通成员变量还没。此时会为类变量初始化，赋予对应数据类型的零值。但是，如果类变量被声明为<code>final</code>，则此时就被赋予程序员要求的值。</p>
<h3 id="解析（resolution）"><a href="#解析（resolution）" class="headerlink" title="解析（resolution）"></a>解析（resolution）</h3><p>解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。引用方式：继承、实现接口、域变量、方法定义、方法中定义的本地变量。</p>
<p>符号引用：一个 java 文件会编译成一个class文件。在编译时，java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</p>
<p>直接引用：直接指向目标的指针（指向方法区，Class 对象）、指向相对偏移量（指向堆区，Class 实例对象）或指向能间接定位到目标的句柄。</p>
<h3 id="初始化（initialization）"><a href="#初始化（initialization）" class="headerlink" title="初始化（initialization）"></a>初始化（initialization）</h3><p>这是类加载机制的最后一步，在这个阶段，java程序代码才开始真正执行。我们知道，在准备阶段已经为类变量赋过一次值。在初始化阶段，程序员可以根据自己的需求来赋值了。<strong>初始化时候才会为我们的普通成员变量赋值。</strong>static变量<em>自定义</em>赋值和代码块也在这时候执行。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>双亲委派机制：假设应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载。但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。</p>
<p>防止“.class”文件不被反编译得到源代码：编译时，加密，加载时使用自定义的类加载器来解密文件。</p>
<blockquote>
<p>委托机制的优点是能够提高软件系统的安全性。因为在此机制下，用户自定义的类加载器不可能加载应该由父加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父加载器加载的可靠代码。例如，java.lang.Object类总是由根类加载器加载，其他任何用户自定义的类加载器都不可能加载含有恶意代码的java.lang.Object类。</p>
</blockquote>
<h2 id="实例：Tomcat的类加载器"><a href="#实例：Tomcat的类加载器" class="headerlink" title="实例：Tomcat的类加载器"></a>实例：Tomcat的类加载器</h2><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105848.jpg" alt="tomcat"></p>
<p>Tomcat自定义了Common、Catalina、Shared等类加载器，其实就是用来加载Tomcat自己的一些核心基础类库的。</p>
<p>然后Tomcat为每个部署在里面的Web应用都有一个对应的WebApp类加载器，负责加载我们部署的这个Web应用的类</p>
<p>至于Jsp类加载器，则是给每个JSP都准备了一个Jsp类加载器。</p>
<p>而且大家一定要记得，Tomcat是打破了双亲委派机制的</p>
<p>每个WebApp负责加载自己对应的那个Web应用的class文件，也就是我们写好的某个系统打包好的war包中的所有class文件，不会传导给上层类加载器去加载。</p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>运行时数据区，是常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105855.png" alt="memory"></p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105902.png" alt="memory2"></p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。方法区中包含的都是在整个程序中永远唯一的元素。<strong>主要是用来存放已被虚拟机加载的类相关信息</strong>，包括类信息、运行时常量池、字符串常量池。类信息又包括了类的版本、字段、方法、接口和父类等信息。</p>
<p>方法区是<strong>java虚拟机规范去中定义的一种概念上的区域（不是具体空间，可以在堆上，也可以在本地内存里）</strong>，具有什么功能，但并没有规定这个区域到底应该位于何处，因此对于实现者来说，如何来实际方法区是有着很大自由度的。</p>
<p>永生代是hotspot中的一个概念，其他jvm实现未必有，例如jrockit就没这东西。java8之前，hotspot使用在内存中划分出一块区域来存储类的元信息、类变量以及内部字符串（interned string）等内容，称之为永生代，把它作为方法区来使用。</p>
<p>JEP122提议取消永生代，方法区作为概念上的区域仍然存在。原先永生代中类的元信息会被放入本地内存（元数据区，metaspace），将类的静态变量和内部字符串放入到java堆中。</p>
<h5 id="PermGen-永久代"><a href="#PermGen-永久代" class="headerlink" title="PermGen(永久代)"></a>PermGen(永久代)</h5><p>绝大部分Java程序员应该都见过“java.lang.OutOfMemoryError: PremGen space”异常。这里的“PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是JVM的规范，而后者则是JVM规范的一种实现，并且只有HotSpot才有“PermGen space”，而对于其他类型的虚拟机，如JRockit(Oracle)、J9(IBM)并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。并且JDK 1.8中参数PermSize和MaxPermSize已经失效。</p>
<h5 id="元空间（Metaspace）"><a href="#元空间（Metaspace）" class="headerlink" title="元空间（Metaspace）"></a>元空间（Metaspace）</h5><p>其实，移除永久代的工作从JDK 1.7就开始了。JDK 1.7中，存储在永久代的部分数据就已经转移到Java Heap或者Native Heap。但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了Java heap；类的静态变量(class statics)转移到了Java heap。</p>
<p>JDK1.8对JVM架构的改造将类元数据放到本地内存中，另外，将常量池和静态变量放到Java堆里。HotSpot VM将会为类的元数据明确分配和释放本地内存。在这种架构下，类元信息就突破了原来-XX:MaxPermSize的限制，现在可以使用更多的本地内存。 <strong>这样就从一定程度上解决了原来在运行时生成大量类造成经常Full GC问题，如运行时使用反射、代理等。所以升级以后Java堆空间可能会增加。</strong></p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间的最大区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存。</strong>因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数指定元空间的大小：</p>
<blockquote>
<p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对改值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</p>
<p>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
</blockquote>
<p>除了上面的两个指定大小的选项外，还有两个与GC相关的属性：</p>
<blockquote>
<p>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集。</p>
<p>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。 </p>
</blockquote>
<p>所以对于方法区，Java8之后的变化：</p>
<p>移除了永久代（PermGen），替换为元空间（Metaspace）；<br>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；<br><strong><em>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；(方法区和堆存在了交集)</em></strong><br>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</p>
<p>堆被划分为新生代和老年代，新生代又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105909.png" alt="heap"></p>
<p>新生代中存放的对象用完即回收。老年代中存放长久存活的对象，例如：多次被静态方法调用的静态对象，并且没有被触发回收。</p>
<h4 id="虚拟机栈（VM-stack）"><a href="#虚拟机栈（VM-stack）" class="headerlink" title="虚拟机栈（VM stack）"></a>虚拟机栈（VM stack）</h4><p>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。<strong>一个线程创建的本地变量对其它线程不可见，仅自己可见。</strong>即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</p>
<p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的<strong>引用</strong>(不是对象)，对象都存放在堆区中。</p>
<p>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</p>
<p>每一个方法的调用都伴随着<strong>栈帧</strong>的入栈操作，方法的返回则是栈帧的出栈操作。此处线程的本地变量为方法内的局部变量。</p>
<h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><p>本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于<strong>管理 Java 函数</strong>的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆上包含在Java程序中创建的所有对象实例，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</p>
<p>存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)。</p>
<p>jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。</p>
<h4 id="不属于JVM的内存空间"><a href="#不属于JVM的内存空间" class="headerlink" title="不属于JVM的内存空间"></a>不属于JVM的内存空间</h4><p>通过NIO中的allocateDirect这种API，可以在Java堆外分配内存空间。然后，通过Java虚拟机里的DirectByteBuffer来引用和操作堆外内存空间。其实很多技术都会用这种方式，因为有一些场景下，堆外内存分配可以提升性能。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</p>
<p>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</p>
<p>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。</p>
<p>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</p>
<p>静态成员变量跟随着类定义一起也存放在堆上。</p>
<p>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。</p>
<h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4><p>程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p>
<p>由于 Java 是多线程语言，当执行的线程数量超过 CPU 数量时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。</p>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105917.gif" alt="jvmdebug"></p>
<p>执行字节码指令时，需要用到“程序计数器”。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>合约模块解析</title>
    <url>/blog/7029f79.html</url>
    <content><![CDATA[<p>分析基于 substrate 的 2021年3月11日 <code>b24c43af</code> 版本。本文将介绍合约模块的合约调用 的基本逻辑，并且会介绍关于合约存储收费的设计。<br><a id="more"></a></p>
<h1 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h1><p>合约调用的大致流程，下图中只显示了<code>ExecutionContext::call</code>的内部逻辑，<code>ExecutionContext::instantiate</code>其实也是类似的。主要在于理解链的runtime层与合约WASM代码是怎么交互的。<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20210311145120.png" alt="call"></p>
<h2 id="手续费"><a href="#手续费" class="headerlink" title="手续费"></a>手续费</h2><p>在Substrate的设计中，调用交易需要根据Weight收取交易手续费。contracts模块定义了几个主要执行接口：<code>call</code>、<code>instantiate_with_code</code>和<code>instantiate</code>。其中，<code>instantiate_with_code</code>接口包含了早期版本中的<code>put_code</code>和<code>instantiate</code>，是为了对合约代码存储进行收费。</p>
<p>在调用以上三个接口时，除了收取由Weight固定的交易手续费之外，还根据<code>gas_limit</code>收取gas费用。gas费用被转换成Weight，在调用接口时，按照Weight的方式统一收取。</p>
<p>根据<code>gas_limit</code>收取的手续费存储在<code>gas_meter</code>中，<code>gas_meter</code>可以被称为gas管家。在合约执行过程中，每次调用host_function会进行相应的gas费用收取，就是从<code>gas_meter</code>提取的。执行完所有步骤后，由<code>gas_meter</code>中记录的<code>gas_left</code>进行手续费的返还。</p>
<h2 id="合约执行上下文"><a href="#合约执行上下文" class="headerlink" title="合约执行上下文"></a>合约执行上下文</h2><p>合约只向pallet::contracts模块层（以下简称为contracts模块）暴露两个执行入口：<code>Constructor</code>、<code>Call</code>。在contracts模块中，<code>Constructor</code>被封装在<code>ExecutionContext::instantiate</code>中，<code>Call</code>被封装在<code>ExecutionContext::call</code>中。<br>contracts模块中的三个接口调用<code>ExecutionContext</code>的两个封装后的执行入口，调用关系如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20210311145610.png" alt="ExecutionContext"></p>
<p><code>ExecutionContext</code>是合约执行上下文，合约调用另一个合约的情况下，直接调用封装在<code>ExecutionContext</code>中的接口，不需要从最外层的三个接口调用，因此不用再收取contracts模块中定义的固定Weight的手续费。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>在<code>ExecutionContext::call</code>中，需要根据<code>code_hash</code>加载合约代码，生成一个wasm module作为<code>executable</code>。然后根据<code>dest</code>获取对应的合约实例，并对该实例进行存储费用计算。该部分涉及费用计算，因此在<strong>合约存储收费</strong>中介绍。</p>
<p>关于<code>load</code>加载合约代码：它会比较 schedule 的版本（<code>instantiate_with_code</code>在上传合约代码时，写入一个是原始代码处理后的 <code>PrefabWasmModule</code>，包含了<code>schedule_version</code>、<code>original_code</code>、<code>code_hash</code>和<code>refcount</code>等）。如果当前版本大于<code>PrefabWasmModule</code>中的版本， 那么需要重新预处理，否则直接返回已经存储的 <code>PrefabWasmModule</code>。</p>
<blockquote>
<p>schedule内主要定义合约命令的weight和host_fn的weight，影响了手续费的计算。</p>
</blockquote>
<h4 id="嵌套执行上下文"><a href="#嵌套执行上下文" class="headerlink" title="嵌套执行上下文"></a>嵌套执行上下文</h4><p>在执行具体业务逻辑之前，需要把执行上下文包装在新的<code>ExecutionContext</code>中，并且在最后能截获当前合约执行的结果。</p>
<h4 id="ExecutionContext执行"><a href="#ExecutionContext执行" class="headerlink" title="ExecutionContext执行"></a>ExecutionContext执行</h4><p>在<code>NestedExecutionContext</code>环境中，执行以下的业务逻辑。</p>
<p>如果调用时传入的参数<code>value</code>不为0的话，会调用<code>transfer</code>将<code>value</code>传给<code>dest</code>账户（不一定是合约账户）。</p>
<p>以<code>executable</code>执行合约。通过<code>ExportedFunction::Call</code>(合约暴露的接口)执行合约代码内的相应函数，传入<code>input_data</code>，其中包含了<code>selector</code>与合约函数对应的传参。</p>
<h4 id="合约Runtime与链Runtime交互"><a href="#合约Runtime与链Runtime交互" class="headerlink" title="合约Runtime与链Runtime交互"></a>合约Runtime与链Runtime交互</h4><p>在执行合约时，需要开辟一段内存空间，将合约实例加载进去，形成了合约实例的Runtime环境，把它称为合约Runtime。</p>
<p>两个Runtime像是运行在两个不同的沙盒中，互不感知。他们之间的交互就需要一个第三方介入，它就是Host。Host是链固定的功能部分，采用原生执行的方式。对于host_fn这些接口，在合约编写框架层（例如ink!）和contracts模块需要制定一致的协议。Substrate上的host_fn代码在<code>frame/contracts/src/wasm/runtime.rs</code>中的<code>define_env!</code>宏中。</p>
<p>更具体的机制介绍可以查看<a href="https://zhuanlan.zhihu.com/p/321618822">赖智超的substrate的合约机制分析</a>，在文章的<strong>Wasm合约的执行Sandbox机制</strong>有相关介绍。</p>
<p>对于合约调用另一个合约的嵌套调用情况，实际上也是两个合约Runtime交互的过程。</p>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p>根据执行的结果，调用<code>commit_transaction()</code> 或者 <code>rollback_transaction()</code>。注意，如果是gas耗尽导致的<code>Revert</code>，只会回滚当前合约的状态，而更高层次的合约状态无法回滚。</p>
<p>最后就是返回剩余手续费。</p>
<h1 id="合约存储收费"><a href="#合约存储收费" class="headerlink" title="合约存储收费"></a>合约存储收费</h1><p>涉及到存储收费的主要是在<code>contracts/src/rent.rs</code>中的<code>collect_rent</code>函数。</p>
<p>如果合约不存在或者为<code>tombstone</code>（可恢复的死亡状态）状态，则直接返回错误。</p>
<p>在<code>instantiate</code>时，我们传入了<code>endowment</code>这个值，令合约账户中拥有资产。根据合约账户的<code>free_balance</code>大小，可以拥有一定大小的免费存储空间。</p>
<p>需要计费的合约代码大小的计算公式：<code>occupied_storage = [ original_code_len + code.len() ] / refcount</code></p>
<blockquote>
<p><code>original_code_len</code>：原始合约代码大小；<br><code>code</code>：注入gas_meter，stack_height_meter后编码成的wasm代码；<br><code>refcount</code>：该合约代码的引用计数，即使用该合约代码的合约账户数。</p>
</blockquote>
<p>而如果合约大小超过了这个免费空间，那么需要收费。需要支付的租用费用计算公式为：</p>
<ol>
<li><code>dues = fee_per_block * blocks_passed</code></li>
<li><code>fee_per_block = RentFraction * uncovered_by_balance</code></li>
<li><code>uncovered_by_balance = DepositPerStorageByte * (contract.storage_size + occupied_storage) + DepositPerStorageItem * contract.pair_count + DepositPerContract - free_balance</code><blockquote>
<p><code>RentFraction</code>：每个区块租赁费用的乘法系数，决定了deposit对应的租赁费用有多高<br><code>DepositPerStorageByte</code>：每个存储字节需要的deposit<br><code>DepositPerStorageItem</code>：每个存储键值对需要的deposit<br><code>DepositPerContract</code>：每个合约存活就基本需要的deposit</p>
</blockquote>
</li>
</ol>
<p>根据合约可以用来支付rent的资产，决定合约的存活状态。<br>可以用来支付租赁费用的资产：<code>rent_budget =  min(contract.rent_allowance, free_balance - subsistence_threshold)</code>。</p>
<blockquote>
<p><code>contract.rent_allowance</code>：一个设置值（该合约可以用来支付租赁费用的最大值），刚部署时默认为balance的最大值，随着租赁费用的支付而逐渐减小。可以通过合约方法<code>set_rent_allowance</code>重新设置该值<br>实例存活下限：<code>subsistence_threshold = Currency::minimum_balance() + TombstoneDeposit</code>。</p>
</blockquote>
<p>如果合约的总资产（包括reserved)都小于实例存活下限，那么会永久删除合约。<br>如果足够支付，就直接扣除。如果不足以支付租赁费用，合约会变成<code>tombstone</code>状态。但是分为两种情况:<br>1.支付后账户都不能存在了，那么不进行扣除租赁费用；<br>2.支付后账户还能存在，还是要扣除租赁费用。<br>这里注意区分合约实例存活下限和合约账户存活下限。<br>合约变为<code>tombstone</code>状态时，保存一个键值对(account,(child_storage_root + code_hash))。对该合约的引用计数减1，如果合约的引用计数为0，会直接删除contracts模块中合约代码的存储。之后如果又有基于同样合约代码的部署，会被认为是新合约代码。</p>
<p>可见，随着时间的流逝，（如果不对合约账户进行充值）合约的资产会减少到无法维持<code>Alive</code>状态，从而变更为<code>tombstone</code>，甚至被永久删除。如果需要估算当前合约的资产能在链上实例存活多久，可以调用<code>rent_projection</code>来估算。</p>
<p>状态为<code>tombstone</code>的合约，在后面可以用状态为<code>Alive</code>的合约<code>retore_to</code>进行替换。</p>
]]></content>
      <categories>
        <category>Polkadot</category>
        <category>substrate</category>
      </categories>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/blog/9a0369ec.html</url>
    <content><![CDATA[<h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><h2 id="算法题目"><a href="#算法题目" class="headerlink" title="算法题目"></a>算法题目</h2><p>如果一个黑名单网站包含100亿个黑名单网页，每个网页最多占64B，设计一个系统，判断当前的URL是否在这个黑名单当中，要求额外空间不超过30GB，允许误差率为万分之一。<br><a id="more"></a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>布隆过滤器</p>
<h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><blockquote>
<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p>
</blockquote>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>实际工程的应用实际上，布隆过滤器广泛应用于网页黑名单系统、垃圾邮件过滤系统、爬虫网址判重系统等，有人会想，我直接将网页URL存入数据库进行查找不就好了，或者建立一个哈希表进行查找不就OK了。当数据量小的时候，这么思考是对的，但如果整个网页黑名单系统包含100亿个网页URL，在数据库查找是很费时的，并且如果每个URL空间为64B，那么需要内存为640GB，一般的服务器很难达到这个需求。那么，在这种内存不够且检索速度慢的情况下，不妨考虑下布隆过滤器，但业务上要可以忍受判断失误率。<br><img src="en-resource://database/3196:1" alt="46ce58dd1b5437be76f0a0a7996d78e6.jpeg"></p>
<p>位图（bitmap）布隆过滤器其中重要的实现就是位图的实现，也就是位数组，并且在这个数组中每一个位置只占有1个bit，而每个bit只有0和1两种状态。如上图bitarray所示！bitarray也叫bitmap，大小也就是布隆过滤器的大小。假设一种有k个哈希函数，且每个哈希函数的输出范围都大于m，接着将输出值对k取余（%m），就会得到k个[0, m-1]的值，由于每个哈希函数之间相互独立，因此这k个数也相互独立，最后将这k个数对应到bitarray上并标记为1（涂黑）。等判断时，将输入对象经过这k个哈希函数计算得到k个值，然后判断对应bitarray的k个位置是否都为1（是否标黑），如果有一个不为黑，那么这个输入对象则不在这个集合中，也就不是黑名单了！如果都是黑，那说明在集合中，但有可能会误，由于当输入对象过多，而集合也就是bitarray过小，则会出现大部分为黑的情况，那样就容易发生误判！因此使用布隆过滤器是需要容忍错误率的，即使很低很低！</p>
<h1 id="布隆过滤器重要参数计算"><a href="#布隆过滤器重要参数计算" class="headerlink" title="布隆过滤器重要参数计算"></a>布隆过滤器重要参数计算</h1><p>通过上面的描述，我们可以知道，如果输入量过大，而bitarray空间的大小又很小，那么误判率就会上升。那么bitarray空间大小怎么确定呢？不要慌，已经有人通过数据推倒出公式了！假设输入对象个数为n，bitarray大小（也就是布隆过滤器大小）为m，所容忍的误判率p和哈希函数的个数k。计算公式如下：（小数向上取整）<br><img src="en-resource://database/3198:1" alt="fc1fb96508a363b17d1bb7737dc51e54.jpeg"></p>
<p>注意：由于我们计算的m和k可能是小数，那么需要经过向上取整，此时需要重新计算误判率p！假设一个网页黑名单有URL为100亿，每个样本为64B，失误率为0.01%，经过上述公式计算后，需要布隆过滤器大小为25GB，这远远小于使用哈希表的640GB的空间。并且由于是通过hash进行查找的，所以基本都可以在O(1)的时间完成！</p>
<h1 id="在比特币中的应用"><a href="#在比特币中的应用" class="headerlink" title="在比特币中的应用"></a>在比特币中的应用</h1><p>比特币中布隆过滤器是在BIP-0037中提到。下面我们通过“比特币钱包如何知道有多少钱”的问题来介绍布隆过滤器在比特币中的应用。这个问题其实就是“比特币钱包如何知道有多少UTXO”。<br>比特币网络中主要有两种节点类型：</p>
<ul>
<li>全节点：存放所有区块数据和交易</li>
<li>SPV节点：只存放区块头（Block Header）</li>
</ul>
<p>我们假设，比特币钱包最开始值存储了私钥，没有任何其他数据。那么它要获取跟自己地址相关的UTXO，只能向比特币网络中相邻的全节点询问，询问的方式有3种：</p>
<ul>
<li>方法一：下载完整的区块链账本，自己查找<br>这种方法很简单，也能隐藏用户的隐私（全节点无法知道SPV节点关联的钱包的地址）。但是在手机端是不现实的，每次用户需要下载上百G的区块链数据，才能知道自己钱包有多少钱，虽然保护了用户隐私，但是浪费了存储空间和带宽。所以这种方法不行，而这也是为什么有SPV的概念存在，中本聪也是考虑到移动支付的场景的。</li>
<li>方法二：直接告诉全节点自己钱包的所有地址，全节点返回所有跟钱包地址相关的UTXO<br>这种方法直接等于是泄露了用户隐私，其他全节点就知道SPV节点所关联的钱包地址。但是好处是所要下载的数据少了很多，也更精确了。</li>
<li>方法三：告诉全节点部分自己钱包的地址信息，全节点返回可能相关的UTXO这种方法实际上就是采用布隆过滤器的方法隐藏用户隐私，从而做到即保护用户隐私，又节省存储空间和带宽。<br>布隆过滤器的两个特点：只能告诉你某个元素可能存在集合中以及某个元素一定不存在集合中。这里可以简单理解Bloom Filter就是一个过滤器，用来过滤不属于钱包的UTXO。钱包节点（SPV节点）会以布隆过滤器的形式告诉相邻全节点自己地址信息，那么根据布隆过滤器的特性，会有两种结果：没有通过布隆过滤器过滤出来的UTXO，就【一定】不属于钱包地址通过布隆过滤器过滤出来的UTXO，【可能】属于钱包地址这种方法虽然在一定程度上保护用户隐私，节省了存储空间和带宽，但是根据布隆过滤器的特点，我们知道，随着钱包交易的UTXO越多，布隆过滤器误报率会越高，也就是相邻全节点返回正确的UTXO概率越低。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/72378274">数学之美：布隆过滤器 - TeddyZhang的文章 - 知乎 </a><br><a href="https://blog.csdn.net/xuanfuhuo4769/article/details/84785007">比特币原理分析（三）</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>bitcoin</category>
      </categories>
  </entry>
  <entry>
    <title>数字签名</title>
    <url>/blog/a277e67b.html</url>
    <content><![CDATA[<p>数字签名在区块链中主要运用在交易签名上。<br><a id="more"></a></p>
<h1 id="RSA（模幂运算）"><a href="#RSA（模幂运算）" class="headerlink" title="RSA（模幂运算）"></a>RSA（模幂运算）</h1><p>根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥.</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>RSA算法的具体描述如下：</p>
<p>（1）任意选取两个不同的大素数p和q计算乘积$n=pq, φ(n)=(p-1)(q-1);$</p>
<p>n的二进制长度是密钥长度。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p>
<p>（2）任意选取一个大整数e，满足  <code>gcd(e,φ(n)) = 1</code>，<code>1&lt; e &lt; φ(n)</code>，整数e用做加密钥（注意：e的选取是很容易的，例如，所有大于p和q的素数都可用）；</p>
<p>（3）确定的解密钥d，满足 <code>(de)mod φ(n) = 1</code> ，即<code>de = kφ(n) +1, k≥1</code>是一个任意的整数；所以，若知道e和φ(n)，则很容易计算出d；</p>
<p>（4）公开整数n和e，秘密保存d ；</p>
<p>（5）将明文m（m&lt;n是一个整数）加密成密文c，加密算法为$c=E(m)=m^emodn$ , n和e为公钥；</p>
<p>（6）将密文c解密为明文m，解密算法为$m=D(c)=c^dmodn$，n和d为私钥；</p>
<p>然而只根据n和e（注意：不是p和q）要计算出d是不可能的。因此，任何人都可对明文进行加密，但只有授权用户（知道d）才可对密文解密。</p>
<h2 id="RSA签名验证"><a href="#RSA签名验证" class="headerlink" title="RSA签名验证"></a>RSA签名验证</h2><p>RSA密码体制既可以用于加密又可以用于数字签名。下面介绍RSA数字签名的功能。</p>
<p>已知公钥（e，n），私钥d</p>
<ul>
<li>1.对于消息m签名为：<code>sign ≡ m ^d mod n</code></li>
<li>2.验证：对于消息签名对（m，sign），如果<code>m ≡ sign ^e mod n</code>，则sign是m的有效签名</li>
</ul>
<p>这里的c是明文m。</p>
<p>证明：c=(((c^e)%n)^d)%n</p>
<p><code>(((c^e)%n)^d)%n =(c^(d*e))%n =(c^(k*t+1))%n =(c*((c^k)^t))%n =((c%n)*(((c^k)^t)%n))%n =((c%n)*(((c^k)%n)^t)%n)%n</code></p>
<p>ϕ(n)是欧拉函数，ϕ(n)=从1到n-1中所有与n互质整数的个数。k=ϕ(n)。根据欧拉定理(1)，对于任意c，如果c与n互质，那么：<code>(c^k)%n=(c^ϕ(n))%n=1</code></p>
<p>因此，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">((c%n)*(((c^k)%n)^t)%n)%n</span><br><span class="line"></span><br><span class="line">=((c%n)*((1^t)%n))%n</span><br><span class="line"></span><br><span class="line">=((c%n)*1)%n</span><br><span class="line"></span><br><span class="line">=c%n</span><br></pre></td></tr></table></figure>
<p>因为c与n互质，所以c%n=c，也就是说：</p>
<p><code>(((c^e)%n)^d)%n=c</code></p>
<hr>
<h1 id="ECC（几何离散）"><a href="#ECC（几何离散）" class="headerlink" title="ECC（几何离散）"></a>ECC（几何离散）</h1><p>阶：一个群的点的数量；在循环子群中，P的阶是最小的正整数n，n使得nP=0；</p>
<p>如何根据基点 P 找到子群的阶：</p>
<ol>
<li>使用Schoof的算法去计算椭圆曲线的阶 N 。</li>
<li>找到 N 所有的因子。</li>
<li>对于 N 的每一个因子 n ,计算 nP 。</li>
<li>找到最小的且满足 nP=0 的 n , n 就是子群的阶。</li>
</ol>
<p><code>NP=n(hP)=0 , 令G=hP =&gt; nG=0</code></p>
<h2 id="找基点"><a href="#找基点" class="headerlink" title="找基点"></a>找基点</h2><ol>
<li>计算椭圆曲线的阶 N 。</li>
<li>选择一个阶为 n 的子群。n必须是素数且必须是 N 的因子。</li>
<li>计算辅因子 h = N / n 。</li>
<li>在曲线上选择一个随机的点 P 。</li>
<li>计算 G = hP 。</li>
<li>如果 G 是0，那么回到步骤4。否则我们就已经找到了阶为 n 和辅因子是 h 的子群的基点。</li>
</ol>
<p>私钥：d , {1…n-1}； 公钥：H=dG</p>
<h2 id="ECDH"><a href="#ECDH" class="headerlink" title="ECDH"></a>ECDH</h2><ol>
<li>Alice 和 Bob 生成各自的私钥和公钥，Alice 的私钥为 $d_A$ ，公钥为 $H_A = d_AG$ 。Bob 的私钥为  $d_B$，公钥为 $H_B = d_BG$ ，注意，Alice 和 Bob 需要使用一样的主要参数：在同一条曲线的同一个有限域上选择一样的基点 G。</li>
<li>Alice 和 Bob 通过不安全信道交换各自的公钥$H_A$和 $H_B$ ，中间人可以窃听到 $H_A$和  $H_B$，但是在无法攻破离散对数难题的情况下无法得到 $d_A$ 和 $d_B$ 。</li>
<li>Alice 计算 $S=d_AH_B$ （使用自身的私钥和 Bob 的公钥），Bob 计算 $S=d_BH_A$  （使用自身的私钥和 Alice 的公钥），双方求得的 S 是一样的，因为 $S=d_AH_B=d_A(d_BG)=d_B(d_AG)=d_BH_A$</li>
</ol>
<p>举个栗子，他们可以使用 S 的 x 轴坐标作为 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> 或者 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Triple_DES">3DES</a> 的密钥来加密信息，这多少有点像是 TLS 的操作，不同点是 TLS 将 x 轴坐标和网络连接相关的其他参数串联起来，然后计算这个串的哈希值。</p>
<h2 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h2><p>Alice 想要使用她的私钥 $d_A$ 来签名，Bob 想用 Alice 的公钥  $H_A$ 要验证签名，只有 Alice 才能提供正确的签名，而每个人都可以验证签名。</p>
<p>Alice 使用算法来签名的步骤如下：</p>
<ol>
<li>在 {1,…, n-1} 范围内选取一个随机数 k （ n 是子群的阶）</li>
<li>计算点 <code>P=kG</code>（ G 是子群的基点）</li>
<li>计算数字 $r = x_p[mod]n$ （  $x_p$是p的x轴坐标）</li>
<li>如果 r=0 ，另选一个 k 并重新计算</li>
<li>计算 $s=k^{-1}(z+rd_A)[mod]n$ （ $d_A$是 Alice 的私钥，  $k^{-1}$是 k mod n 的乘法逆元）</li>
<li>如果 s=0 ，另选一个 k 并重新计算</li>
</ol>
<p>(r, s) 就是签名。</p>
<h3 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h3><p>为了验证签名，我们需要 Alice 的公钥 $H_A$ ，被截断的哈希值 z，还有签名 (r, s)</p>
<ol>
<li>计算整数 $u_1 = s^{-1}z [mod] n$</li>
<li>计算整数 $u_2 = s^{-1}r[mod]n$</li>
<li>计算点 $P=u_1G + u_2H_A$</li>
</ol>
<p>只有当 $r=x_P[mod]n$ 的时候，签名才被成功验证</p>
<h3 id="算法的正确性"><a href="#算法的正确性" class="headerlink" title="算法的正确性"></a>算法的正确性</h3><p>算法的逻辑一开始看不是很容易理解，如果我们把前面用到的公式整合联立一下，就变得清晰了</p>
<p>我们从  $P=u_1G + u_2H_A$ 开始，通过公钥的定义我们知道 $H_A = d_A G$ （  $d_A$是私钥），所以我们得到：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105612.png" alt="image-20200909163306958"></p>
<p>使用 $u_1$ 和  $u2$的定义，可以得到：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105620.png" alt="image-20200909163321840"></p>
<p>这里为了简单先忽略 mod n ，因为由 G 生成的循环子群的阶为 n ，所以这里的 mod n 其实也是没必要的。</p>
<p>再往前，我们定义了 $s = k^{-1}(z+rd_A)[mod]n$ ，式子两边同乘以  k再同除  s，也就是:$k=s^{-1}(z+rd_A)[mod]n$，把这个结果带到上面关于 P 的等式中得到：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105644.png" alt="image-20200909163510588"></p>
<h1 id="Schnorr"><a href="#Schnorr" class="headerlink" title="Schnorr"></a>Schnorr</h1><p>我们定义几个变量：</p>
<ul>
<li>G：椭圆曲线基点。</li>
<li>m：待签名的数据，通常是一个32字节的哈希值。</li>
<li>x：私钥。P = xG，P为x对应的公钥。</li>
<li>H()：哈希函数。</li>
<li><ul>
<li>示例：写法H(m || R || P)可理解为：将m, R, P三个字段拼接在一起然后再做哈希运算。</li>
</ul>
</li>
</ul>
<h2 id="生成签名"><a href="#生成签名" class="headerlink" title="生成签名"></a>生成签名</h2><p>签名者已知的是：G-椭圆曲线基点, H()-哈希函数，m-待签名消息, x-私钥。</p>
<ol>
<li>选择一个随机数k, 令 <code>R = k*G</code></li>
<li>令 <code>s = k + H(m || R || P)*x</code></li>
</ol>
<p>那么，公钥P对消息m的签名就是：(R, s)，这一对值即为Schnorr签名。</p>
<h2 id="验证签名-1"><a href="#验证签名-1" class="headerlink" title="验证签名"></a>验证签名</h2><p>验证者已知的是：G-椭圆曲线, H()-哈希函数，m-待签名消息, P-公钥，(R, s)-Schnorr签名。验证如下等式：</p>
<p><code>s*G = R + H(m || R || P)P</code></p>
<p>若等式成立，则可证明签名合法。</p>
<p>我们推演一下，此过程包含了一个极其重要的理论：椭圆曲线无法进行除法运算。</p>
<ol>
<li>s值的定义：<code>s = k + H(m || R || P)*x</code>，等式两边都乘以椭圆曲线G，则有：</li>
<li><code>sG = kG + H(m || R || P)*x*G</code>，又因R = kG, P = xG，则有：</li>
<li><code>sG = R + H(m || R || P)P</code>，椭圆曲线无法进行除法运算，所以第3步的等式，无法向前反推出第1步，就不会暴露k值以及x私钥。同时，也完成了等式验证。</li>
</ol>
<h2 id="组签-Group-Signature"><a href="#组签-Group-Signature" class="headerlink" title="组签, Group Signature"></a>组签, Group Signature</h2><p>一组公钥，N把，签名后得到N个签名。这个N个签名是可以相加的，最终得到一个签名。这个签名的验证通过，则代表N把公钥的签名全部验证通过。</p>
<p>有：</p>
<ul>
<li>椭圆曲线基点：G</li>
<li>待签名的数据：m</li>
<li>哈希函数：H()</li>
<li>私钥：x1，x2，公钥：P1=x1<em>G, P2=x2</em>G</li>
<li>随机数：k1, k2，并有 R1=k1<em>G, R2=k2</em>G</li>
<li>组公钥：P = P1 + P2</li>
</ul>
<p>则有：</p>
<ul>
<li>私钥x1和x2的签名为：(R1, s1), (R2, s2)。</li>
<li>两个签名相加得到组签名：(R, s)。其中：R = R1 + R2, s = s1 + s2。</li>
</ul>
<h3 id="推演过程："><a href="#推演过程：" class="headerlink" title="推演过程："></a>推演过程：</h3><ol>
<li><p>令<code>R = R1 + R2, s = s1 + s2</code></p>
</li>
<li><p>已知：<code>s1 = k1 + H(m || R || P)*x1</code>，<code>s2 = k2 + H(m || R || P)*x2</code></p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; s1 + s2</span><br><span class="line"></span><br><span class="line">   &#x3D; k1 + H(m || R || P)*x1 + k2 + H(m || R || P)*x2</span><br><span class="line"></span><br><span class="line">   &#x3D; (k1 + k2) + H(m || R || P)(x1 + x2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>两边同时乘以G，则有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sG &#x3D; (k1 + k2)G + H(m || R || P)(x1 + x2)G</span><br><span class="line">	&#x3D; (k1G + k2G) + H(m || R || P)(x1G + x2G)</span><br><span class="line">	&#x3D; (R1 + R2) + H(m || R || P)(P1 + P2)</span><br><span class="line">	&#x3D; R + H(m || R || P)P</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成证明，并从两个合作方推演至N个合作方</p>
</li>
</ol>
<p>组公钥(Group Key)，是N把公钥进行相加后的值，又称聚合公钥(Aggregation Key)。需要指出的是，参与方需要先相互交换公钥和R值，然后再进行各自的签名。</p>
<h2 id="多签"><a href="#多签" class="headerlink" title="多签"></a>多签</h2><p>聚合签名对应于聚合公钥。但是，我们不只是将所有联合签名者的公钥相加，而是将它们乘以某个因子。聚合的公钥将是<code>P=hash(L,P1)×P1+…+hash(L,Pn)×Pn</code>。这里<code>L=hash(P1,…,Pn)</code>是一个取决于所有公钥的公用数字。这种非线性特性可以防止攻击者构造一个不好的公钥，例如在恶意密钥攻击当中。尽管攻击者知道自己的哈希 (L,Patk)×Patk 应是什么，但他不能从中派生 Patk，这和从公钥派生私钥是相同的问题。</p>
<p>m-of-n多重签名使用默克尔树；</p>
<h1 id="BLS"><a href="#BLS" class="headerlink" title="BLS"></a>BLS</h1><p><a href="https://www.iacr.org/archive/asiacrypt2001/22480516.pdf">Boneh-Lynn-Shacham</a></p>
<p>Schnorr 签名方案是非常了不起的，如果我们做得对，我们可以将交易中的所有签名和公钥组合为一个密钥和一个签名，没有人会发现它们对应于多个密钥。区块验证也可以变得更快，因为我们可一次性验证所有签名。但它也存在着一些问题：</p>
<ol>
<li>多重签名方案需要多轮通信，这会使冷存储变得非常烦人；</li>
<li>对于签名聚合，我们必须依赖随机数生成器，我们不能像在 ECDSA 中那样确定地选择随机点 R；</li>
<li>m-of-n 多重签名方案是棘手的，我们需要制作一个公共密钥的默克尔树（merkle tree），对于大数的 m 和 n 来说，这颗默克尔树可以变得相当大；</li>
<li>我们不能将区块中的所有签名组合为单个签名；</li>
</ol>
<p>BLS 签名可修复上述所有问题，我们不需要随机数，区块中的所有签名都可以组合成单个签名，m-of-n 类型的多重签名非常简单，我们不需要签名者之间进行多轮通信。此外，BLS 签名相比 Schnorr 签名或 ECDSA 签名要小 2 倍，其签名不是一对，而是一个单曲线点。</p>
<p>私钥：pk，公钥 P=pk<em>G， 签名消息是m，消息哈希到曲线H(m)，签名：S=pk</em>H(m)</p>
<p>验证：e(P,H(m)) = e(G,S)</p>
<p>和 Schnorr 签名方案一样，运用 BLS 签名需要保护自己免受流氓密钥攻击。我们可通过要求每个联合签名者证明他们具有的公钥的私钥（通过签名他们的公钥），或者我们可以在方案中添加一些非线性元素，使恶意密钥攻击成为不可能。我们不是简单地将所有的密钥和签名相加，而是将它们乘以一个特定的数字，然后再相加：</p>
<p><code>S = a1×S1+a2×S2+a3×S3</code></p>
<p><code>P = a1×P1+a2×P2+a3×P3</code></p>
<p>在这里，签名和密钥的系数是根据签名者的公钥和所有其他公钥来确定计算的：</p>
<p><code>ai = hash(Pi, &#123;P1,P2,P3&#125;)</code></p>
<p>这个方案的好处在于，你不需要在设备之间进行多轮通信。你只需要知道谁是其他签名者。这比 Schnorr 签名的 3 轮多重签名方案要简单得多。它也不依赖任何随机性，它是一种完全确定的签名算法。</p>
<h2 id="m-of-n签名"><a href="#m-of-n签名" class="headerlink" title="m-of-n签名"></a>m-of-n签名</h2><p>我们的每个设备都有一个签名者编号 i=1,2,3，代表其在集合中的位置，一个私钥 pki 以及一个对应的公钥 Pi = pki×G。这里计算聚合公钥的方式与之前完全相同：</p>
<p><code>P = a1×P1+a2×P2+a3×P3</code>, <code>ai = hash(Pi, &#123;P1,P2,P3&#125;)</code></p>
<p>现在，每个设备都需要签名，而编号 i 是我们的聚合公钥的成员（对于每个 i），聚合这些签名并将结果保存到相应的设备上：</p>
<p><code>MKi = (a1⋅pk1)×H(P, i)+(a2⋅pk2)×H(P, i)+(a3⋅pk3)×H(P, i)</code></p>
<p>这个签名我们称为“成员密钥”，稍后我们将使用它进行签名。每个成员密钥都是消息 H(P,i) 的有效 n-of-n 签名，这意味着：</p>
<p><code>e(G, MKi)=e(P, H(P,i))</code></p>
<p>记住这个方程，我们以后会用到的。它将用来证明我们是多重签名方案的有效参与者。</p>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>现在假设我们只想用密钥 pk1 和 pk3 签署一笔交易。我们生成两个签名 S1 和 S3:</p>
<p><code>S1 = pk1×H(P, m)+MK1, S3=pk3×H(P, m)+MK3</code></p>
<p>并将它们相加以获得单个签名和密钥：</p>
<p><code>(S’, P’) = (S1+S3, P1+P3)</code></p>
<p>我在这里写为 P’ 和 S’，来强调这个密钥和签名只由签名者的一个子集签名，它与 P 不同，P 是所有签名者的聚合密钥。要验证这 3 个签名中的 2 个，我们需要检查：</p>
<p><code>e(G, S’) = e(P’, H(P, m))⋅e(P, H(P, 1)+H(P, 3))</code></p>
<p>我们记得成员密钥 MK1 和 MK3 是由聚合密钥 P 签名的消息 H(P, 1) 及 H(P, 3) 的有效签名，因此：</p>
<p><code>e(G, S’) = e(G, S1+S3)=e(G, pk1×H(P, m)+pk3×H(P, m)+MK1+MK3) =e(G, pk1×H(P,m)+pk3×H(P, m))⋅e(G, MK1+MK3)=e(pk1×G+pk3×G, H(P, m))⋅e(P, H(P, 1)+H(P,3))=e(P’, H(P, m))⋅e(P, H(P, 1)+H(P, 3))</code></p>
<p>BLS 签名的弊端：配对效率低下。</p>
<h1 id="VRF"><a href="#VRF" class="headerlink" title="VRF"></a>VRF</h1><p>全称为Verifiable Random Functionn。</p>
<p>可验证随机函数一共包含四个函数：1、生成密钥，生成一个公钥私钥对；2、生成随机数输出；3、计算零知识证明；4、验证随机数输出。</p>
<p>证明人用私钥和随机数r计算证明s,t，私钥可以确定得到随机数v，发送（随机数v，证明哈希，t)。验证者不需要知道证明人的私钥和随机数r，就可以验证随机数生成是否正确。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>密码学</category>
      </categories>
  </entry>
  <entry>
    <title>比特币与以太坊</title>
    <url>/blog/f98f8a09.html</url>
    <content><![CDATA[<h1 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h1><h2 id="记账"><a href="#记账" class="headerlink" title="记账"></a>记账</h2><h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>未花费的交易输出。翻译成大白话就是我花的钱都是别人给我的钱，而且花的时候必须花完。比如我有一个2 BTC（比特币） 的UTXO，我想给你1 BTC，我就必须把这个 2BTC的UTXO 花掉，然后生成两个UTXO，一个 1BTC 的UTXO给你，一个UTXO（小于1 BTC，差值为交易费）给我自己。想看余额怎么办，就查一下这个地址里有多少UTXO，把里面的BTC加起来就是余额。<br><a id="more"></a></p>
<h3 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h3><p>以太坊有两种账户：<br>外部账户（externally owned accounts），由密钥控制。<br>合约账户（contract accounts），由智能合约的代码控制。<br>以太坊的账户包括四个字段：一个随机数、账户的余额、合约代码（如果有的话）、存储（通常为空）。<br>只有合约账户才有代码，其中存储的是 codeHash（这个账户的以太坊虚拟机代码的哈希值）。这个字段在生成后是不可修改的，这意味着智能合约代码是不可修改的。<br>外部账户可以触发交易，而合约账户不能主动发起交易，只能在被触发后按预先编写的智能合约代码执行。<br>合约账户可以设置多重签名（multisign），比如一个简单示例是：现有一个合约账户，它要求一个转账由发起转账的人（Alice）和另一个人（Charles）签名均可。因此，当 Alice 通过这个合约向 Bob 转账 20 个 ETH 时，合约会通知 Charles 签名，在他签名后，Bob 才可以收到这 20 个 ETH。</p>
<h2 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h2><h3 id="比特币-1"><a href="#比特币-1" class="headerlink" title="比特币"></a>比特币</h3><p>交易结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029104521.png" alt="交易结构"></p>
<p>交易输入结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029104357.png" alt="交易输入"></p>
<p>交易输出结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029104503.png" alt="交易输出"></p>
<h3 id="以太坊-1"><a href="#以太坊-1" class="headerlink" title="以太坊"></a>以太坊</h3><p>和比特币一样，以太坊的区块中存储的也是交易（transaction），它包括的字段主要有：接受者（接受的账户）、发送者的签名、发送者发给接受者的以太币金额等。<br>与比特币的区块中存储的是交易不同，以太坊的区块中以梅克尔帕特里夏树（Merkle Patricia Tree,MPT）形式存储的是相应的以太坊账户的状态。<br>以太坊的交易是所谓的状态转换函数，一个交易触发它的执行，它将相应的账户从一个状态转变成新状态，然后新状态被存储在区块链的数据区块中。<br>外部账户可以创建交易,用自己的私钥进行签名之发送消息给另一个外部账户或合约账户。两个外部账户之间传送的消息即为转账操作。从外部账户到合约账户的消息会激活合约账户的代码，执行各种操作，也就是我们常说的调用智能合约。可以通过向0地址发起交易来创建合约账户。交易包含以下主要字段：</p>
<ul>
<li>Type：交易的类型，ContractCreation（创建合约）还是MessageCall（调用合约或转账）</li>
<li>Nonce: 发送地址的交易计数</li>
<li>Value: 向目标账户发送的金额</li>
<li>ReceiveAddress：接受方地址</li>
<li>GasPrice:为交易付出的Gas价格</li>
<li>Gas:为交易付出的Gas</li>
<li>Data：交易的附加数据</li>
<li>VRS:交易签名结构体</li>
</ul>
<p>收据(Receipt)<br>账户创建交易并向其它节点广播后，会被其它节点执行并放入准备打包的区块。在这个过程中会生成一个收据。收据的主要字段有：</p>
<ul>
<li>blockHash: 交易所在块的哈希值</li>
<li>blockNumber: 交易在块的序号</li>
<li>transactionHash: 交易的哈希值</li>
<li>transactionIndex: 交易在块中的序号</li>
<li>cumulativeGasUsed: 执行完此交易时候，块内消耗的总的gas值</li>
<li>gasUsed:本交易所消耗的gas</li>
<li>contractAddress: 当此交易为创建合约时，表示所创建合约的地址，否则为空</li>
<li>logs: 此交易的日志</li>
</ul>
<p>需要注意的是，在不同的节点之间并不会发送状态和收据，后两者在可以通过交易计算得到。</p>
<h2 id="交易验证"><a href="#交易验证" class="headerlink" title="交易验证"></a>交易验证</h2><h3 id="比特币-2"><a href="#比特币-2" class="headerlink" title="比特币"></a>比特币</h3><p>比特币交易是首先要提供一个用于解锁 UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。</p>
<p>每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。</p>
<h4 id="签名流程"><a href="#签名流程" class="headerlink" title="签名流程"></a>签名流程</h4><p>1.查找该笔交易对应的UTXO<br>2.获得该UTXO对应的锁定脚本<br>3.复制该交易对象，并在复制副本中将该Input的解锁脚本字段的值设置为<em>之前</em>  交易输出部分的锁定脚本的字段<br>4.清除其他Input的解锁脚本字段<br>5.对这个改造后的交易对象计算Hash<br>6.使用私钥对Hash进行签名<br>7.将签名结果<code>sig</code>和签名人的地址<code>PubK</code>放入input的解锁脚本中<br>8.构成输入部分</p>
<h4 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h4><p>解锁脚本先进行入栈，然后锁定脚本入栈计算。<br>如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029104627.png" alt="脚本"></p>
<p>验证解锁脚本中的<code>PubK</code>（验证<code>PubKHash</code>）与<code>sig</code>（公钥验证）与锁定脚本的计算结果是否一致。</p>
<h3 id="以太坊-2"><a href="#以太坊-2" class="headerlink" title="以太坊"></a>以太坊</h3><h4 id="验证交易的有效性"><a href="#验证交易的有效性" class="headerlink" title="验证交易的有效性"></a>验证交易的有效性</h4><ul>
<li>数据量必须&lt;32KB</li>
<li>交易金额必须非负（&gt;=0）</li>
<li>交易的gas limit必须低于block的gas limit</li>
<li>签名数据必须有效，能够解析出发送者地址</li>
<li>交易的gas price必须高于pool设定的最低gas price（除非是本地交易）</li>
<li>交易的nonce值必须高于当前链上该账户的nonce值（低于则说明这笔交易已经被打包过了）</li>
<li>当前账户余额必须大于“交易金额 + gasprice * gaslimit”</li>
<li>交易的gas limit必须大于对应数据量所需的最低gas水平</li>
</ul>
<h4 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h4><p>用消息和签名推导出对方的公钥。再通过公钥，签名，消息的哈希值计算出一个叫 r 的值，这个 r 是签名的一部分，校验签名就是拿计算出来的 r 和签名中携带的 r 经行对比，如果一致就校验通过。</p>
<p>交易验证后，提交到txPool中，还需要广播出去，一方面通知EVM执行该交易，另一方面要把交易信息广播给其他结点。</p>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><h3 id="比特币-3"><a href="#比特币-3" class="headerlink" title="比特币"></a>比特币</h3><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029104642.png" alt="区块信息"><br>区块结构<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201028203438.png" alt="区块"><br>区块头<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105249.png" alt="区块头"></p>
<h3 id="以太坊-3"><a href="#以太坊-3" class="headerlink" title="以太坊"></a>以太坊</h3><ul>
<li>ParentHash:父块的哈希值</li>
<li>Number:块编号</li>
<li>Timestamp:块产生的时间戳</li>
<li>GasUsed:交易消耗的Gas</li>
<li>GasLimit:Gas限制</li>
<li>Difficulty:POW的难度值</li>
<li>Beneficiary：块打包手续费的受益人，也称矿工</li>
<li>Nonce：一个随机数，使得块头哈希满足POW需求</li>
<li>StateRoot：状态树的根哈希值</li>
<li>TransactionsRoot：交易树的根哈希值</li>
<li>ReceiptsRoot：收据树的根哈希值</li>
</ul>
<p>每个矿工在把交易打包成块的时候，会组织三颗树：</p>
<ul>
<li>交易树，树叶里是交易</li>
<li>收据树，树叶里是交易生成的收据</li>
<li>状态树，树叶里是交易影响到（节省空间）的账户状态</li>
</ul>
<p>三棵树求取根哈希，可以得到区块头中的StateRoot,TransactionsRoot,ReceiptsRoot三个字段。这样就建立了交易和区块头字段的映射。当其他用户收到块，根据块里的交易可以计算出收据和状态，计算三个根哈希后和区块头的三个字段进行验证，判断这是否为合法的块。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learnblockchain.cn/2017/11/10/bitcoin-script/">比特币脚本及交易分析</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>bitcoin</category>
      </categories>
  </entry>
  <entry>
    <title>文档注释</title>
    <url>/blog/70b7aba4.html</url>
    <content><![CDATA[<h1 id="Java-文档注释"><a href="#Java-文档注释" class="headerlink" title="Java 文档注释"></a>Java 文档注释</h1><a id="more"></a>
<p>Java 支持三种注释方式。前两种分别是 <strong>//</strong> 和 <strong>/* */</strong>，第三种被称作说明注释，它以 <strong>/**</strong> 开始，以 <strong>*/</strong>结束。</p>
<p>说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p>
<p>说明注释，使你更加方便的记录你的程序信息。</p>
<h2 id="javadoc-标签"><a href="#javadoc-标签" class="headerlink" title="javadoc 标签"></a>javadoc 标签</h2><p>javadoc 工具软件识别以下标签：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>标签</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
<th style="text-align:center"><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@author</td>
<td style="text-align:center">标识一个类的作者</td>
<td style="text-align:center">@author description</td>
</tr>
<tr>
<td style="text-align:left">@deprecated</td>
<td style="text-align:center">指名一个过期的类或成员</td>
<td style="text-align:center">@deprecated description</td>
</tr>
<tr>
<td style="text-align:left">{@docRoot}</td>
<td style="text-align:center">指明当前文档根目录的路径</td>
<td style="text-align:center">Directory Path</td>
</tr>
<tr>
<td style="text-align:left">@exception</td>
<td style="text-align:center">标志一个类抛出的异常</td>
<td style="text-align:center">@exception exception-name explanation</td>
</tr>
<tr>
<td style="text-align:left">{@inheritDoc}</td>
<td style="text-align:center">从直接父类继承的注释</td>
<td style="text-align:center">Inherits a comment from the immediate surperclass.</td>
</tr>
<tr>
<td style="text-align:left">{@link}</td>
<td style="text-align:center">插入一个到另一个主题的链接</td>
<td style="text-align:center">{@link name text}</td>
</tr>
<tr>
<td style="text-align:left">{@linkplain}</td>
<td style="text-align:center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td style="text-align:center">Inserts an in-line link to another topic.</td>
</tr>
<tr>
<td style="text-align:left">@param</td>
<td style="text-align:center">说明一个方法的参数</td>
<td style="text-align:center">@param parameter-name explanation</td>
</tr>
<tr>
<td style="text-align:left">@return</td>
<td style="text-align:center">说明返回值类型</td>
<td style="text-align:center">@return explanation</td>
</tr>
<tr>
<td style="text-align:left">@see</td>
<td style="text-align:center">指定一个到另一个主题的链接</td>
<td style="text-align:center">@see anchor</td>
</tr>
<tr>
<td style="text-align:left">@serial</td>
<td style="text-align:center">说明一个序列化属性</td>
<td style="text-align:center">@serial description</td>
</tr>
<tr>
<td style="text-align:left">@serialData</td>
<td style="text-align:center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
<td style="text-align:center">@serialData description</td>
</tr>
<tr>
<td style="text-align:left">@serialField</td>
<td style="text-align:center">说明一个ObjectStreamField组件</td>
<td style="text-align:center">@serialField name type description</td>
</tr>
<tr>
<td style="text-align:left">@since</td>
<td style="text-align:center">标记当引入一个特定的变化时</td>
<td style="text-align:center">@since release</td>
</tr>
<tr>
<td style="text-align:left">@throws</td>
<td style="text-align:center">和 @exception标签一样.</td>
<td style="text-align:center">The @throws tag has the same meaning as the @exception tag.</td>
</tr>
<tr>
<td style="text-align:left">{@value}</td>
<td style="text-align:center">显示常量的值，该常量必须是static属性。</td>
<td style="text-align:center">Displays the value of a constant, which must be a static field.</td>
</tr>
<tr>
<td style="text-align:left">@version</td>
<td style="text-align:center">指定类的版本</td>
<td style="text-align:center">@version info</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><p>在开始的 <strong>/**</strong> 之后，第一行或几行是关于类、变量和方法的主要描述。</p>
<p>之后，你可以包含一个或多个各种各样的 <strong>@</strong> 标签。每一个 <strong>@</strong> 标签必须在一个新行的开始或者在一行的开始紧跟星号(*).</p>
<p>多个相同类型的标签应该放成一组。例如，如果你有三个 <strong>@see</strong> 标签，可以将它们一个接一个的放在一起。</p>
<p>下面是一个类的说明注释的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 这个类绘制一个条形图 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> runoob </span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.2 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="IDE中使用"><a href="#IDE中使用" class="headerlink" title="IDE中使用"></a>IDE中使用</h2><p>可以使用插件、模板，自动在每个类和方法前加上文档注释。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>路线与基础</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟机网络设置</title>
    <url>/blog/cdadaa64.html</url>
    <content><![CDATA[<h1 id="三种连接模式"><a href="#三种连接模式" class="headerlink" title="三种连接模式"></a>三种连接模式</h1><p><a href="https://blog.csdn.net/qq_28203045/article/details/81266910">VMware中，桥接网络、NAT网络模式和仅主机的理解</a><br><a id="more"></a><br>如果需要同时连接局域网和公网，常常使用桥接的方式。</p>
<h1 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h1><h2 id="虚拟机网络编辑器"><a href="#虚拟机网络编辑器" class="headerlink" title="虚拟机网络编辑器"></a><a name="虚拟机网络编辑器">虚拟机网络编辑器</a></h2><p>有三个VMnet：0，1，8 。其中VMnet0在编辑模式下才可以看到。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">VMnet0</td>
<td style="text-align:center">桥接</td>
</tr>
<tr>
<td style="text-align:center">VMnet1</td>
<td style="text-align:center">仅主机</td>
</tr>
<tr>
<td style="text-align:center">VMnet8</td>
<td style="text-align:center">NAT</td>
</tr>
</tbody>
</table>
</div>
<p>分别对应三种模式的网络设置。</p>
<p>除了默认的三个虚拟网络，还可以自己添加。</p>
<h2 id="物理机网络适配器"><a href="#物理机网络适配器" class="headerlink" title="物理机网络适配器"></a>物理机网络适配器</h2><p>对VMnetx 进行ip地址的配置。</p>
<h2 id="虚拟机网络适配器"><a href="#虚拟机网络适配器" class="headerlink" title="虚拟机网络适配器"></a>虚拟机网络适配器</h2><p>选择以何种网络模式上网。默认的，每种模式对应与<a href="#虚拟机网络编辑器">虚拟机网络编辑器</a>的虚拟网络设置。</p>
]]></content>
      <categories>
        <category>编程</category>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title>账户模型</title>
    <url>/blog/1d646e11.html</url>
    <content><![CDATA[<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ol>
<li>节省大量空间<a id="more"></a></li>
<li>可替代性更高</li>
<li>实现简单</li>
<li>轻客户端</li>
</ol>
<h1 id="账户基本概念"><a href="#账户基本概念" class="headerlink" title="账户基本概念"></a>账户基本概念</h1><h2 id="外部账户"><a href="#外部账户" class="headerlink" title="外部账户"></a>外部账户</h2><p>EOAs-外部账户(external owned accouts)是由人们通过私钥创建的账户。 是真实世界的金融账户的映射，拥有该账户私钥的任何人都可以控制该账户。 如同银行卡，到ATM机取款时只需要密码输入正确即可交易。 这也是人类与以太坊账本沟通的唯一媒介，因为以太坊中的交易需要签名， 而只能使用拥有私有外部账户签名。<br>外部账户特点总结：</p>
<ul>
<li>拥有以太余额。</li>
<li>能发送交易，包括转账和执行合约代码。</li>
<li>被私钥控制。</li>
<li>没有相关的可执行代码。</li>
</ul>
<h2 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h2><p>含有合约代码的账户。被外部账户或者合约创建，合约在创建时被自动分配到一个账户地址，用于存储合约代码以及合约部署或执行过程中产生的存储数据。 合约账户地址是通过SHA3哈希算法产生，而非私钥。因无私钥，因此无人可以拿合约账户当做外部账户使用。只能通过外部账户来驱动合约执行合约代码。<br>合约账户特点总结：</p>
<ul>
<li>拥有以太余额。</li>
<li>有相关的可执行代码（合约代码）。</li>
<li>合约代码能够被交易或者其他合约消息调用。</li>
<li>合约代码被执行时可再调用其他合约代码。</li>
<li>合约代码被执行时可执行复杂运算，可永久地改变合约内部的数据存储。</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    Nonce    <span class="keyword">uint64</span></span><br><span class="line">    Balance  *big.Int</span><br><span class="line">    Root     common.Hash</span><br><span class="line">    CodeHash []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部账户的 Root/StateRootHash/StorageRootHash 和 CodeHash 是一个空默认值。</p>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>MPT存储所有账户状态。</p>
<h2 id="账户状态值存储"><a href="#账户状态值存储" class="headerlink" title="账户状态值存储"></a>账户状态值存储</h2><p>账户状态数据经过RLP（Recursive Length Prefix）序列化后存储，RLP序列化方式相比protobuf较为简单，只支持字符嵌套数组（nested array of bytes），实现起来比较容易。</p>
<h2 id="RLP编码"><a href="#RLP编码" class="headerlink" title="RLP编码"></a>RLP编码</h2><h3 id="RLP编码定义"><a href="#RLP编码定义" class="headerlink" title="RLP编码定义"></a>RLP编码定义</h3><p>RLP编码只处理两类数据：一类是字符串（字节数组），一类是列表。</p>
<ul>
<li>字符串，指的是一串二进制数据，</li>
<li>列表，是一个嵌套递归的结构，里面可以包含字符串和列表，例如[“cat”,[“puppy”,”cow”],”horse”,[[]],”pig”,[“”],”sheep”]就是一个复杂的列表。</li>
</ul>
<p>其他类型的数据需要转成以上的两类，转换的规则不是RLP编码定义的，可以根据自己的规则转换。例如struct可以转成列表，int可以转成二进制（属于字符串一类），以太坊中整数都以大端形式存储。<br>RLP编码方式的特点：</p>
<ul>
<li>递归，被编码的数据是递归的结构，编码算法也是递归进行处理的；</li>
<li>长度前缀，也就是RLP编码都带有一个前缀，这个前缀是跟被编码数据的长度相关的，从下面的编码规则中可以看出这一点。</li>
</ul>
<h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h3><p>规则一：对于单个字节，如果它的值范围是[0x00, 0x7f]，它的RLP编码就是它本身。这里面需要注意的是0x7f这个边界，因为ASCII编码最大值就是0x7f，也就是说在0x7f以内完全当做ASCII编码使用。<br>规则二：如果一个字符串的长度是0-55字节，它的RLP编码包含一个单字节的前缀，后面跟着字符串本身，这个前缀的值是0x80加上字符串的长度。由于被编码的字符串最大长度是55=0x37,因此单字节前缀的最大值是0x80+0x37=0xb7，即编码的第一个字节的取值范围是[0x80, 0xb7]。<br>规则三：如果字符串的长度大于55个字节，它的RLP编码包含一个单字节的前缀，后面跟着字符串的长度，后面再跟着字符串本身。这个前缀的值是0xb7加上字符串长度的二进制形式的字节长度，说的有点绕，举个例子就明白了，例如一个字符串的长度是1024，它的二进制形式是10000000000，这个二进制形式的长度是2个字节，所以前缀应该是0xb7+2=0xb9，字符串长度1024=0x400，因此整个RLP编码应该是\xb9\x04\x00再跟上字符串本身。编码的第一个字节即前缀的取值范围是[0xb8, 0xbf]，因为字符串长度二进制形式最少是1个字节，因此最小值是0xb7+1=0xb8，字符串长度二进制最大是8个字节，因此最大值是0xb7+8=0xbf。<br>规则四：如果一个列表的总长度（列表的总长度指的是它包含的项的数量加它包含的各项的长度之和）是0-55字节，它的RLP编码包含一个单字节的前缀，后面跟着列表中各元素项的RLP编码，这个前缀的值是0xc0加上列表的总长度。编码的第一个字节的取值范围是[0xc0, 0xf7]。<br>规则五：如果一个列表的总长度大于55字节，它的RLP编码包含一个单字节的前缀，后面跟着列表的长度，后面再跟着列表中各元素项的RLP编码，这个前缀的值是0xf7加上列表总长度的二进制形式的字节长度。编码的第一个字节的取值范围是[0xf8, 0xff]。</p>
<p>例子分析：<br>15(‘\x0f’) = 0x0f （规则一）<br>空字符串 “” = 0x80 （规则二）<br>字符串 “dog” = [0x83, ‘d’, ‘o’, ‘g’ ] （规则二）<br>1024(‘\x04\00’) = [0x82, 0x04, 0x00] （规则二）<br>字符串 “Lorem ipsum dolor sit amet, consectetur adipisicing elit” = [0xb8, 0x38, ‘L’, ‘o’, ‘r’, ‘e’, ‘m’, ‘ ‘, … , ‘e’, ‘l’, ‘i’, ‘t’]（规则三）<br>空列表 [] = [0xc0] （规则四）<br>列表 [“cat”,”dog”] = [0xc8, 0x83, ‘c’, ‘a’, ‘t’, 0x83, ‘d’, ‘o’, ‘g’ ] （规则四）</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>RLP的设计思想，就是通过首字节快速判断一串编码的类型，充分利用了一个字节的存储空间，将0x7f以后的值赋予了新的含义，以往我们见到的编码方式主要是对指定长度字节进行编码，比如Unicode等，在处理这些编码时一般按照指定长度进行拆分解码，最大的弊端是传统编码无法表现一个结构，就是本文说的列表，RLP最大的优点是在充分利用字节的情况下，同时支持列表结构，也就是说可以很轻易的利用RLP存储一个树状结构。<br>  程序处理RLP编码时也非常容易，根据首字节就可以判断出这段编码的类型，同时调用不同的方法进行解码，如果您熟悉jason这种结构，会发现RLP很类似，支持嵌套的结构，通过递归调用可以将整个RLP快速还原成一颗树，或者转译成一个jason结构，便于其他程序使用。<br>  RLP使用首字节存储长度的位数，再用后续的字节表明整体字符串的长度，根据规则二计算，RLP可以支持的单个最大字符串长度为2的64次方，这无疑是个天文数字，再加上嵌套规则，所以理论上RLP可以编码任何数据。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learnblockchain.cn/books/geth">以太坊技术与实现</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>eth</category>
      </categories>
  </entry>
  <entry>
    <title>非对称加密</title>
    <url>/blog/7d8bf595.html</url>
    <content><![CDATA[<h1 id="RSA（模幂运算）"><a href="#RSA（模幂运算）" class="headerlink" title="RSA（模幂运算）"></a>RSA（模幂运算）</h1><a id="more"></a>
<p>根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥.</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>RSA算法的具体描述如下：</p>
<p>（1）任意选取两个不同的大素数p和q计算乘积$n=pq, φ(n)=(p-1)(q-1);$</p>
<p>n的二进制长度是密钥长度。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p>
<p>（2）任意选取一个大整数e，满足  <code>gcd(e,φ(n)) = 1</code>，<code>1&lt; e &lt; φ(n)</code>，整数e用做加密钥（注意：e的选取是很容易的，例如，所有大于p和q的素数都可用）；</p>
<p>（3）确定的解密钥d，满足 <code>(de)mod φ(n) = 1</code> ，即<code>de = kφ(n) +1, k≥1</code>是一个任意的整数；所以，若知道e和φ(n)，则很容易计算出d；</p>
<p>（4）公开整数n和e，秘密保存d ；</p>
<p>（5）将明文m（m&lt;n是一个整数）加密成密文c，加密算法为$c=E(m)=m^emodn$ , n和e为公钥；</p>
<p>（6）将密文c解密为明文m，解密算法为$m=D(c)=c^dmodn$，n和d为私钥；</p>
<p>然而只根据n和e（注意：不是p和q）要计算出d是不可能的。因此，任何人都可对明文进行加密，但只有授权用户（知道d）才可对密文解密。</p>
<h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><p>查看<a href="https://munan.tech/2020/08/21/digital-signature/#more">数字签名</a>这一章。</p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>密码学</category>
      </categories>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/blog/58add7e9.html</url>
    <content><![CDATA[<h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><p>随着前后端分离技术的越来越盛行，跨域问题也逐渐凸显了出来。跨域问题的根本原因：因为浏览器收到同源策略的限制，当前域名的js只能读取同域下的窗口属性。什么叫做同源策略？就是不同的域名, 不同端口, 不同的协议不允许共享资源的，保障浏览器安全。同源策略是针对浏览器设置的门槛。如果绕过浏览器就能实现跨域，所以说早期的跨域都是打着安全路数的擦边球，都可以认为是 hack 处理。<br><a id="more"></a></p>
<blockquote>
<p>这里要注意的是，只有访问类型为xhr（XMLHttpRequest)的才会出现跨域。</p>
<p>同源检测主要是为了防止CSRF攻击。</p>
</blockquote>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h3><p>Cross-site request forgery 跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<p>一个典型的CSRF攻击有着如下的流程：</p>
<ul>
<li>受害者登录a.com，并保留了登录凭证（Cookie）。</li>
<li>攻击者引诱受害者访问了b.com。</li>
<li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li>
<li>a.com以受害者的名义执行了act=xx。</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li>
</ul>
<h3 id="防护策略"><a href="#防护策略" class="headerlink" title="防护策略"></a>防护策略</h3><p>CSRF的两个特点：</p>
<ul>
<li>CSRF（通常）发生在第三方域名。</li>
<li>CSRF攻击者不能获取到Cookie等信息，只是使用。</li>
</ul>
<p>针对这两点，我们可以专门制定防护策略，如下：</p>
<ul>
<li>阻止不明外域的访问<ul>
<li>同源检测</li>
<li>Samesite Cookie</li>
</ul>
</li>
<li>提交时要求附加本域才能获取的信息<ul>
<li>CSRF Token</li>
<li>双重Cookie验证</li>
</ul>
</li>
</ul>
<h1 id="跨域问题的解决方案"><a href="#跨域问题的解决方案" class="headerlink" title="跨域问题的解决方案"></a>跨域问题的解决方案</h1><h2 id="修改浏览器设置"><a href="#修改浏览器设置" class="headerlink" title="修改浏览器设置"></a>修改浏览器设置</h2><p>以Google Chrome为例，浏览器以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;C:\ProgramFiles(x86)\Google\Chrome\Application\chrome.exe&quot;</span></span><br><span class="line">    --disable-web-security--user-data-dir</span><br></pre></td></tr></table></figure>
<p>中模式打开，右键点击浏览器快捷方式，在目标中输入上述代码即可解决（不推荐）。</p>
<h2 id="修改请求的方式：jsonp"><a href="#修改请求的方式：jsonp" class="headerlink" title="修改请求的方式：jsonp"></a>修改请求的方式：jsonp</h2><p>JQuery中的正常AJAX请求代码片段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#demo1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url : <span class="string">&#x27;http://www.tpadmin.top/Index/Test/crossDomain&#x27;</span>,</span><br><span class="line">        data : &#123;&#125;,</span><br><span class="line">        type : <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        success : <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. Origin &#x27;http://127.0.0.1&#x27; is therefore not allowed access. 在执行时候报出的错误，这代表了跨域错误</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> JQuery中的使用JSONP的AJAX请求代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#demo2&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url : <span class="string">&#x27;http://www.tpadmin.top/Index/Test/crossDomain&#x27;</span>,</span><br><span class="line">        data : &#123;&#125;,</span><br><span class="line">        type : <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        dataType : <span class="string">&#x27;jsonp&#x27;</span>, </span><br><span class="line">        success : <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这时候我们看到 请求的网址自动变成了</p>
<p><code>http://www.tpadmin.top/Index/Test/crossDomain?callback=jQuery331015214102388989237_1534993962395&amp;_=1534993962396</code><br>这是为什么呢？原来由于跨域访问的只限制<code>xhr</code>类型的请求（上文中已经说了），所以js中就利用了这一特点，让服务端不在返回的是一个JSON格式的数据，而是返回一段JS代码，将JSON的数据以参数的形式传递到这个函数中，而函数的名称就是callback参数的值，所以我们还需要修改服务端的代码，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $callback = isset($_GET[<span class="string">&#x27;callback&#x27;</span>])?$_GET[<span class="string">&#x27;callback&#x27;</span>]:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!empty($callback)) &#123;</span><br><span class="line">        $arr = [<span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">200</span>, <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;cui&#x27;</span>];</span><br><span class="line">        $data = json_encode($arr);</span><br><span class="line">        exit($callback . <span class="string">&#x27;(&#x27;</span> . $data . <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>OK，现在问题解决了，但是JSONP存在着诸多限制：</p>
<ol>
<li><p>JSONP只支持GET请求，什么？你要提交表单，sorry，此路不通</p>
</li>
<li><p>它只支持跨域HTTP请求</p>
</li>
</ol>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>跨域访问的请求头中存在Origin的字段，用来记录当前的访问域名，我们可以再服务端增加一个响应头<code>Access-Control-Allow-Origin</code>来告诉浏览器我们支持它获取就可以了，代码实现：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$requestHeader = getallheaders();</span><br><span class="line">$origin = <span class="keyword">isset</span>($requestHeader[<span class="string">&#x27;Origin&#x27;</span>])?$requestHeader[<span class="string">&#x27;Origin&#x27;</span>]:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> ($origin) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;http://127.0.0.1&#x27;</span>:</span><br><span class="line">        header(<span class="string">&#x27;Access-Control-Allow-Origin:http://127.0.0.1&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;http://localhost&#x27;</span>:</span><br><span class="line">        header(<span class="string">&#x27;Access-Control-Allow-Origin:http://localhost&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">$arr = [<span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">200</span>, <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;cui&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> $data = json_encode($arr);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p>通过配置反向代理，增加允许访问的<code>Origin</code>请求头部分：<code>add_header Access-Control-Allow-Origin xxx</code></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/cuixiaogang110/article/details/81948173">前后端分离与跨域的解决方案（CORS的原理)</a></p>
<p>[<a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">前端安全系列（二）：如何防止CSRF攻击？</a>]</p>
]]></content>
      <categories>
        <category>编程</category>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title>MPT</title>
    <url>/blog/51be0f38.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Merkle Patricia Tree（又称为 Merkle Patricia Trie）是一种经过改良的、融合了 Merkle tree 和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。<br><a id="more"></a><br>MPT 树有以下几个作用：</p>
<ul>
<li>存储任意长度的 key-value 键值对数据，符合以太坊的 state 模型；</li>
<li>提供了一种快速计算所维护数据集哈希标识的机制；</li>
<li>提供了快速状态回滚的机制；</li>
<li>提供了一种称为默克尔证明的证明方法，进行轻节点的扩展，实现简单支付验证；</li>
</ul>
<p>由于 MPT 结合了 Radix trie 和 Merkle 两种树结构的特点与优势 ，因此在介绍 MPT 之前，我们首先简要地介绍下这两种树结构的特点。</p>
<h1 id="Radix-trie"><a href="#Radix-trie" class="headerlink" title="Radix trie"></a>Radix trie</h1><p>Trie 树，又称前缀树或字典树，是一种有序树，用于保存关联数组。其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定 。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。<br>一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。实际上 trie 每个节点是一个确定长度的数组，数组中每个元素的值是一个指向子节点的指针，最后有个标志域，标识这个位置为止是否是一个完整的字符串。<br>常见的用来存英文单词的 trie 每个节点是一个长度为 27 的指针数组，index0-25 代表 a-z 字符，26 为标志域。如图：<br><img src="en-resource://database/3157:1" alt="07a263568193a61ed457ea441a69513f.jpeg"></p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>相比于哈希表，使用前缀树来进行查询拥有共同前缀 key 的数据时十分高效，例如在字典中查找前缀为 pre 的单词，对于哈希表来说，需要遍历整个表，时间效率为 O(n)，然而对于前缀树来说，只需要在树中找到前缀为 pre 的节点，且遍历以这个节点为根节点的子树即可。<br>但是对于最差的情况（前缀为空串)，时间效率为 O(n), 仍然需要遍历整棵树，此时效率与哈希表相同。<br>相比于哈希表，在前缀树不会存在哈希冲突的问题。<br>更新数据非常容易，只需访问局部分支。</p>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><p>直接查找效率低下。前缀树的查找效率是 O(m)，m 为所查找节点的 key 长度，而哈希表的查找效率为 O(1)。且一次查找会有 m 次 IO 开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。可能会造成空间浪费 当存在一个节点，其 key 值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。</p>
<h1 id="Patricia-trie"><a href="#Patricia-trie" class="headerlink" title="Patricia trie"></a>Patricia trie</h1><p>他是一种更节省空间的 Trie。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。<br><img src="en-resource://database/3158:1" alt="932c5c442939901fa4259789029eb190.jpeg"><br>Patricia tree适合键值分布比较稀疏的数据，压缩效果比较明显。在以太坊中，为防止碰撞，使用了160bit长的账户，非常稀疏，因此适合使用Patricia tree数据结构。</p>
<h1 id="Merkle-tree"><a href="#Merkle-tree" class="headerlink" title="Merkle tree"></a>Merkle tree</h1><p>Merkle 树是由计算机科学家 Ralph Merkle 在很多年前提出的，并以他本人的名字来命名, 由于在 Bitcoin 网络中用到了这种数据结构来进行数据正确性的验证，在这里简要地介绍一下 merkle 树的特点及原理。<br>在 Bitcoin 网络中，merkle 树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹。此外，由于 merkle 树的存在，使得在 Bitcoin 这种公链的场景下，扩展一种 “轻节点” 实现简单支付验证变成可能。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>Merkle tree 是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；</li>
<li>Merkle tree 叶子节点的 value 是数据项的内容，或者是数据项的哈希值；</li>
<li>非叶子节点的 value 根据其孩子节点的信息，然后按照 Hash 算法计算而得出的；</li>
</ul>
<p><img src="en-resource://database/3159:1" alt="8804db71163a98e46d2966e998a5a868.jpeg"></p>
<p>将相邻两个节点的哈希值合并成一个字符串，然后计算这个字符串的哈希，得到的就是这两个节点的父节点的哈希值。<br>如果该层的树节点个数是单数，那么对于最后剩下的树节点，这种情况就直接对它进行哈希运算，其父节点的哈希就是其哈希值的哈希值（对于单数个叶子节点，有着不同的处理方法，也可以采用复制最后一个叶子节点凑齐偶数个叶子节点的方式）。循环重复上述计算过程，最后计算得到最后一个节点的哈希值，将该节点的哈希值作为整棵树的哈希。<br>若两棵树的根哈希一致，则这两棵树的结构、节点的内容必然相同。</p>
<h2 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h2><ul>
<li>快速重哈希<br>Merkle tree 的特点之一就是当树节点内容发生变化时，能够在前一次哈希计算的基础上，仅仅将被修改的树节点进行哈希重计算，便能得到一个新的根哈希用来代表整棵树的状态。</li>
<li>轻节点扩展<br>采用 Merkle tree，可以在公链环境下扩展一种 “轻节点”。轻节点的特点是对于每个区块，仅仅需要存储约 80 个字节大小的区块头数据，而不存储交易列表，回执列表等数据。然而通过轻节点，可以实现在非信任的公链环境中验证某一笔交易是否被收录在区块链账本的功能。这使得像比特币，以太坊这样的区块链能够运行在个人 PC，智能手机等拥有小存储容量的终端上。<br>对于轻节点来说，验证一条交易只需要验证包含该交易的路径即可，并不需要把所有交易的 Hash 全部重新算一遍。<br><img src="en-resource://database/3160:1" alt="1acfb4f6da08977b33ee75e349f83d88.jpeg"><h2 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h2>存储空间开销大<h1 id="MPT"><a href="#MPT" class="headerlink" title="MPT"></a>MPT</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2>在深入 MPT 数据结构之前，我们先了解一下如下概念：</li>
<li>世界状态：在以太坊中，所有账户（包括合约账户、普通账户）的状态数据统称为世界状态；</li>
<li>轻节点：指只存储区块头数据的区块链节点；</li>
<li>区块链分叉：指向同一个父块的 2 个区块被同时生成的情况，某些部分的矿工看到其中一个区块，其他的矿工则看到另外一个区块。这导致 2 种区块链同时增长；</li>
<li>区块头：指以太坊区块结构体的一部分，用于存储该区块的头部信息，如父区块哈希、世界状态哈希、交易回执集合哈希等。区块头仅存储一些 “固定” 长度的哈希字段；<h2 id="MPT-树中的节点"><a href="#MPT-树中的节点" class="headerlink" title="MPT 树中的节点"></a>MPT 树中的节点</h2></li>
<li>空节点 (NULL) - represented as the empty string<br>简单的表示空，在代码中是一个空串。</li>
<li>叶子节点 (leaf) - a 2-item node [encodedPath, value]<br>表示为 [key,value] 的一个键值对，其中 key 是 key 的一种特殊十六进制编码 (MP 编码)， value 是 value 的 RLP 编码。</li>
<li>分支节点 (branch) - a 17-item node [v0 … v15, vt]<br>因为 MPT 树中的 key 被编码成一种特殊的 16 进制的表示，再加上最后的 value，所以分支节点是一个 长度为 17 的 list，前 16 个元素对应着 key 中的 16 个可能的十六进制字符，如果有一个 [key,value] 对在这个分支节点终止，最后一个元素代表一个值，即分支节点既可以搜索路径的终止也可以是路径的中间节点。</li>
<li>扩展节点 (extension) - a 2-item node [encodedPath, key]也是 [key，value] 的一个键值对 ，但是这里的 value 是其他节点的 hash 值 ，这个 hash 可以被用来查询数据库中的节点。也就是说通过 hash 链接到其他节点。<br>因此，有两种 [key,value] 节点(叶节点和扩展节点)<h2 id="以太坊中对-Key-的编码"><a href="#以太坊中对-Key-的编码" class="headerlink" title="以太坊中对 Key 的编码"></a>以太坊中对 Key 的编码</h2>在以太坊中，MPT 树的 key 值共有三种不同的编码方式，以满足不同场景的不同需求。<br>三种编码方式分别为：<br>1.Raw 编码（原生的字符）；<br>2.Hex 编码（扩展的 16 进制编码）；<br>3.Hex-Prefix 编码（16 进制前缀编码）；<h3 id="Raw-编码"><a href="#Raw-编码" class="headerlink" title="Raw 编码"></a>Raw 编码</h3>Raw 编码就是原生的 key 值，不做任何改变。这种编码方式的 key，是 MPT 对外提供接口的默认编码方式。<br>例如一条 key 为 “cat”，value 为“dog” 的数据项，其 key 的 Raw 编码就是[‘c’, ‘a’, ‘t’]，换成 ASCII 表示方式就是[63, 61, 74]（Hex）<h3 id="Hex-编码"><a href="#Hex-编码" class="headerlink" title="Hex 编码"></a>Hex 编码</h3>Hex 编码就是把一个 8 位的字节数据用两个十六进制数展示出来，编码时，将 8 位二进制码重新分组成两个 4 位的字节，其中一个字节的低 4 位是原字节的高四位，另一个字节的低 4 位是原数据的低 4 位，高 4 位都补 0，然后输出这两个字节对应十六进制数字作为编码。Hex 编码后的长度是源数据的 2 倍。<br>例如：<br>ASCII 码：A (65) 二进制码：0100_0001 重新分组：0000_0100 0000_0001 十六进制： 4 1 Hex 编码：41<br>若该 Key 对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个 ASCII 值为 16 的字符作为 terminator；<br>若该 key 对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；<br>[‘c’,’a’,’t’] -&gt; [6,3,6,1,7,4,16]<h2 id="HP-编码"><a href="#HP-编码" class="headerlink" title="HP 编码"></a>HP 编码</h2>目的：</li>
<li>区分 leaf 和 extension</li>
<li>把奇数路径变成偶数路径</li>
</ul>
<p>步骤：</p>
<ul>
<li>如果有 terminator（16）那么就去掉 terminator。根据表格给 key 加上 prefix</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>node type</th>
<th>path length</th>
<th>prefix</th>
<th>hexchar</th>
</tr>
</thead>
<tbody>
<tr>
<td>extension</td>
<td>even</td>
<td>0000</td>
<td>0x0</td>
</tr>
<tr>
<td>extension</td>
<td>odd</td>
<td>0001</td>
<td>0x1</td>
</tr>
<tr>
<td>leaf</td>
<td>even</td>
<td>0010</td>
<td>0x2</td>
</tr>
<tr>
<td>leaf</td>
<td>odd</td>
<td>0011</td>
<td>0x3</td>
</tr>
</tbody>
</table>
</div>
<p>如果 prefix 是 0x0 或者 0x2，加一个 padding nibble 0 在 prefix 后面，所以最终应该是 0x00 和 0x20。原因是为了保证 key（path）的长度为偶数。<br>例子： 末尾的字符 “16” 说明该节点为叶子结点，并且加上了 0x20<br>[ 0, f, 1, c, b, 8, 16] -&gt; ‘20 0f 1c b8’</p>
<h2 id="编码转换关系"><a href="#编码转换关系" class="headerlink" title="编码转换关系"></a>编码转换关系</h2><p>以上三种编码方式的转换关系为：<br>Raw 编码：原生的 key 编码，是 MPT 对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw 编码被转换成 Hex 编码；<br>Hex 编码：16 进制扩展编码，用于对内存中树节点 key 进行编码，当树节点被持久化到数据库时，Hex 编码被转换成 HP 编码；<br>HP 编码：16 进制前缀编码，用于对数据库中树节点 key 进行编码，当树节点被加载到内存时，HP 编码被转换成 Hex 编码；<img src="en-resource://database/3161:1" alt="232537cfac5103618cb9b0b45e9a47e2.jpeg"></p>
<h2 id="MPT-的结构"><a href="#MPT-的结构" class="headerlink" title="MPT 的结构"></a>MPT 的结构</h2><p>MPT 树的特点如下:</p>
<ul>
<li>叶子节点和分支节点可以保存 value, 扩展节点保存 key；</li>
<li>没有公共的 key 就成为 2 个叶子节点；key1=[1,2,3] key2=[2,2,3]</li>
<li>有公共的 key 需要提取为一个扩展节点；key1=[1,2,3] key2=[1,3,3] =&gt; ex-node=[1], 下一级分支 node 的 key</li>
<li>如果公共的 key 也是一个完整的 key，数据保存到下一级的分支节点中；key1=[1,2] key2=[1,2,3] =&gt; ex-node=[1,2], 下一级分支 node 的 key; 下一级分支 =[3], 上一级 key 对应的 value</li>
</ul>
<p>简单的结构如下图：<br><img src="en-resource://database/3162:1" alt="e2698781750973ae4a083f3dbe8bb517.jpeg"><br>我们将存入如下 state 数据:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>key</th>
<th>values</th>
</tr>
</thead>
<tbody>
<tr>
<td>a711355</td>
<td>45.0 ETH</td>
</tr>
<tr>
<td>a77d337</td>
<td>1.00 WEI</td>
</tr>
<tr>
<td>a7f9365</td>
<td>1.1  ETH</td>
</tr>
<tr>
<td>a77d397</td>
<td>0.12 ETH</td>
</tr>
</tbody>
</table>
</div>
<p>插入第一个<a711355, 45>，由于只有一个 key, 直接用 leaf node 既可表示<img src="en-resource://database/3163:1" alt="ed1f460bb6353d5817ce4cb24a6d5d3d.jpeg"><br>接着插入 a77d337, 由于和 a711355 共享前缀’a7’, 因而可以创建’a7’扩展节点。<img src="en-resource://database/3164:1" alt="b8117db4cafb85f52e840899ff22241e.jpeg"><br>接着插入 a7f9365, 也是共享’a7’, 只需新增一个 leaf node.<img src="en-resource://database/3165:1" alt="fb9cace75809b83abb90c79957a6d675.jpeg"><br>最后插入 a77d397, 这个 key 和 a77d337 共享’a7’+’d3’, 因而再需要创建一个’d3’扩展节点<img src="en-resource://database/3166:1" alt="4fcf5ab87c1b497a34f9e113a3da5be9.jpeg"><br>将叶子节点和最后的 short node 合并到一个节点了，事实上源码实现需要再深一层，最后一层的叶子节点只有数据<img src="en-resource://database/3167:1" alt="345a4e2896e9605aea982b206dcbd940.jpeg"><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nodeFlag contains caching-related metadata about a node.</span></span><br><span class="line"><span class="keyword">type</span> nodeFlag <span class="keyword">struct</span> &#123;</span><br><span class="line">    hash  hashNode <span class="comment">// cached hash of the node (may be nil)</span></span><br><span class="line">    gen   <span class="keyword">uint16</span>   <span class="comment">// cache generation counter</span></span><br><span class="line">    dirty <span class="keyword">bool</span>     <span class="comment">// whether the node has changes that must be written to the database</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>MPT 节点有个 flag 字，nodeFlag，记录了一些辅助数据：</a711355,></p>
<ul>
<li>节点哈希：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；</li>
<li>诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中 “太老” 的未被修改的节点，防止占用的内存空间过多；</li>
<li>脏标志：当一个节点被修改时，该标志位被置为 1；</li>
</ul>
<p>flag.hash 会保存该节点采用 merkle tree 类似算法生成的 hash。同时会将 hash 和源数据以 <hash, node.rlp.rawdata> 方式保存在 leveldb 数据库中。这样后面通过 hash 就可以反推出节点数据。具体结构如下 (蓝色的 hash 部分就是 flag.hash 字段)<br><img src="en-resource://database/3168:1" alt="7d1caad737c77663a8ae43611eff29af.jpeg"></hash,></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>hash 可以还原出节点上的数据，这样只需要保存一个 root(hash)，即可还原出完整的树结构，同时还可以按需展开节点数据，比如如果需要访问 <a771355, 45> 这个数据，只需展开 h00, h10, h20, h30 这四个 hash 对应的节点。</a771355,></p>
<h2 id="出块后的变化"><a href="#出块后的变化" class="headerlink" title="出块后的变化"></a>出块后的变化</h2><p>新发布一个区块的时候，某些账户的状态会发生变化，新区块中会为变化的账户重新建立分支，大部分不变的数据则指向历史区块中的分支，因此区块间会共享大部分不变的状态分支。如下图所示：<img src="en-resource://database/3236:1" alt="df12ba2a0c3a1aaebb7a24d02c730245.png"></p>
<p>保留历史状态的好处：<br>未胜出的临时性分叉需要回滚才能继续出块，由于智能合约的执行不易反推执行，保留起始与结束的记录，回滚才比较方便。</p>
<p>账户树中保存全部账户信息的原因：<br>查找某个账户更快速，如果区块内只保存区块内交易的相关账户信息，查询某个很久没有交易的账户就要花费很长时间，最坏的情况是如果转账给一个从未进行交易的账户，就必须追溯到创世区块，最后有可能发现区块内没有该账户的信息。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>以太坊中的状态树、交易树、收据树都采用MPT。只有状态树会共享分支。</p>
<h2 id="交易树"><a href="#交易树" class="headerlink" title="交易树"></a>交易树</h2><p>NewBlock函数里包含交易树、收据树的创建以及叔父区块处理。<br>创建交易树的步骤：</p>
<ul>
<li>判断交易列表是否为空，如果为空，那么块头的根哈希就是空哈希值</li>
<li>如果不为空，调用DeriveSha函数得到交易树的根哈希值</li>
<li>然后创建区块的交易列表<h2 id="收据树"><a href="#收据树" class="headerlink" title="收据树"></a>收据树</h2>创建收据树的步骤：</li>
<li>判断收据列表是否为空，如果为空，那么根哈希就是空哈希值</li>
<li>如果不为空，调用DeriveSha函数得到收据树的根哈希值</li>
<li>然后调用CreateBloom函数创建块头里的bloom filter<h2 id="叔父区块"><a href="#叔父区块" class="headerlink" title="叔父区块"></a>叔父区块</h2>处理叔父区块：</li>
<li>判断叔父区块列表是否为空，如果为空，那么块头的叔父区块哈希值就是空的哈希值</li>
<li>如果不为空，调用CalcUncleHash计算哈希值</li>
<li>通过一个循环构建区块里的叔父数组</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learnblockchain.cn/books/geth/part3/mpt.html">MPT</a></p>
]]></content>
      <categories>
        <category>区块链</category>
        <category>eth</category>
      </categories>
  </entry>
  <entry>
    <title>PAT</title>
    <url>/blog/16991c0b.html</url>
    <content><![CDATA[<h1 id="算法初步"><a href="#算法初步" class="headerlink" title="算法初步"></a>算法初步</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>使用sort函数，必要时需要自定义cmp比较函数；<br><a id="more"></a></p>
<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>常用来打表，比如将字符串散列到一个长数组中；</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>两个重点：递归边界，递推式；</p>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>局部最优，得到全局最优。应用例如：求最低价格。有时，需要加上对具体题目的规律推断。</p>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>Upper_bound(begin, end, value) 找到第一个大于value的元素的地址，不存在则返回end；对数组或容器使用。</p>
<h2 id="two-pointers"><a href="#two-pointers" class="headerlink" title="two pointers"></a>two pointers</h2><p>研究问题与序列的特性，使用两个互相牵制的下标对序列进行扫描；</p>
<h1 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h1><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分数的四则运算"><a href="#分数的四则运算" class="headerlink" title="分数的四则运算"></a>分数的四则运算</h2><p>利用结构体定义分子分母，分别运算；</p>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">int</span> sqr = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span> *n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factor</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,cnt;</span><br><span class="line">&#125;fac[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>从2到sqrt(n)范围的素数表中找质因子与对应的个数；如果没有被sqrt(n)以内的素数除尽，那么他本身是一个素数，质因子为本身；</p>
<h2 id="大整数运算"><a href="#大整数运算" class="headerlink" title="大整数运算"></a>大整数运算</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><ol>
<li>只有vector和string支持*(it + i)的访问方式；</li>
<li>遍历容器可以用<code>for(auto it: v)</code>；</li>
<li>String::nops是find函数查找失败的返回值，string的size_type的最大值；</li>
<li>queue在使用front()和pop()之前，要判断empty()；</li>
</ol>
<h1 id="简单数据结构"><a href="#简单数据结构" class="headerlink" title="简单数据结构"></a>简单数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>STL的stack；</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>STL的queue；</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> data;</span><br><span class="line">  node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>静态链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> data;</span><br><span class="line">  <span class="keyword">int</span> next;</span><br><span class="line">  <span class="comment">// 有时候需要加上其他标志</span></span><br><span class="line">  <span class="comment">// bool falg; //结点有效状态，排序可以剔除无效结点</span></span><br><span class="line">  <span class="comment">// int address; //记录结点地址</span></span><br><span class="line">&#125;node[size];</span><br></pre></td></tr></table></figure>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>常用递归解决；</p>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>在进入分支前，先进行限制条件的判断；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> nowK, <span class="keyword">int</span> nowSum,<span class="keyword">int</span> fSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowSum == n&amp;&amp;nowK == k) &#123;    <span class="comment">//递归边界（满足条件）</span></span><br><span class="line">        <span class="keyword">if</span> (fSum &gt; maxfSum) &#123;    <span class="comment">//题目条件</span></span><br><span class="line">            ans = temp;</span><br><span class="line">            maxfSum = fSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == sqr||nowK&gt;k||nowSum&gt;n) <span class="keyword">return</span>;    <span class="comment">//递归边界（剪枝）</span></span><br><span class="line">    temp.push_back(factor[index]);        <span class="comment">//选择加入</span></span><br><span class="line">    DFS(index , nowK + <span class="number">1</span>, nowSum + (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">1.0</span>*factor[index], p*<span class="number">1.0</span>), fSum + factor[index]); <span class="comment">// 如果不重复选，这里也该是index+1</span></span><br><span class="line">    temp.pop_back();    <span class="comment">//恢复，不加入</span></span><br><span class="line">    DFS(index + <span class="number">1</span>, nowK, nowSum, fSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>队列实现，按层次遍历；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(s);</span><br><span class="line">  falg[s] = <span class="literal">true</span>; <span class="comment">// 标记s入队</span></span><br><span class="line">  <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> top = q.front(); <span class="comment">// 取队首</span></span><br><span class="line">    <span class="comment">// 访问top，进行操作</span></span><br><span class="line">    q.pop(); <span class="comment">//队首出队</span></span><br><span class="line">    <span class="comment">//将top的下一层结点中，未曾入队的进行入队，并设置为已入队</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要对队列中元素修改时，队列存储最好是他们的编号而不是元素本身。</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><ul>
<li>二叉树结点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  BTNode *l, *r;</span><br><span class="line">  <span class="comment">// int layer;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="建立二叉树"><a href="#建立二叉树" class="headerlink" title="建立二叉树"></a>建立二叉树</h2><p>中序inorder+后序postorder </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">create</span><span class="params">(<span class="keyword">int</span> postL, <span class="keyword">int</span> postR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (postL &gt; postR||inL&gt;inR)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  BTNode *root = <span class="keyword">new</span> BTNode;</span><br><span class="line">  <span class="comment">//根据后序找到根结点</span></span><br><span class="line">  root-&gt;data = post[postR]; </span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = inL; i &lt;= inR; i++) &#123;</span><br><span class="line">    <span class="comment">//找到中序中的根结点位置</span></span><br><span class="line">    <span class="keyword">if</span> (in[i] == post[postR]) &#123;  </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当前根结点左子树的结点个数</span></span><br><span class="line">  <span class="keyword">int</span> leftnum = i - inL;  </span><br><span class="line">  root-&gt;l = create(postL,postL+leftnum<span class="number">-1</span> , inL, i<span class="number">-1</span>);</span><br><span class="line">  root-&gt;r = create(postL + leftnum, postR<span class="number">-1</span>, i + <span class="number">1</span>, inR);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树的结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">  <span class="comment">//int len,layer;</span></span><br><span class="line">&#125;Node[maxn];</span><br></pre></td></tr></table></figure>
<p>树的先根遍历-dfs，层序遍历-bfs</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子节点多于2个时，用静态链表方便</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;q,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">  sum += Node[root].w;</span><br><span class="line">  <span class="comment">//剪枝</span></span><br><span class="line">  <span class="keyword">if</span> (sum&gt;s)    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//加入</span></span><br><span class="line">  q.push_back(Node[root].w);    </span><br><span class="line"> <span class="comment">//递归边界（满足题目条件）</span></span><br><span class="line"> <span class="keyword">if</span> (Node[root].child.size()==<span class="number">0</span>&amp;&amp;sum == s) &#123;  </span><br><span class="line">    print(q);</span><br><span class="line">    <span class="comment">//恢复</span></span><br><span class="line">    q.pop_back();    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(Node[root].child.begin(),</span><br><span class="line">        Node[root].child.end(), cmp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Node[root].child.size(); i++) &#123;   </span><br><span class="line">     <span class="comment">//先根遍历的核心</span></span><br><span class="line">     preorder(Node[root].child[i], q,sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不加入</span></span><br><span class="line">  q.pop_back();        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerOrder</span><span class="params">(node *root)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;BTNode*&gt; q;</span><br><span class="line">	q.push(root);</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		node* p = q.front();</span><br><span class="line">		num++;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">		<span class="keyword">if</span> (num &lt; n)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;l)</span><br><span class="line">			q.push(p-&gt;l);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;r)</span><br><span class="line">			q.push(p-&gt;r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(root);</span><br><span class="line">  Node[root].layer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> front = q.front();</span><br><span class="line">    <span class="comment">// ...访问根结点</span></span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[front].child.size();i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> child = Node[front].child[i];</span><br><span class="line">      Node[child].layer = Node[front].layer + <span class="number">1</span>;</span><br><span class="line">      q.push(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>特点：中序遍历有序。</p>
<p>删除（1）root为空，直接返回；（2）root值为x，进入删除处理；（2.0）无左右孩子，直接删除；（2.1）root有左孩子，在左子树中找pre，让pre覆盖root，接着在左子树中删除pre；（2.2）root右孩子类似；（3）root-&gt;data 大于x，去root-&gt;l删；（4）root-&gt;data小于x，去root-&gt;r删；</p>
<p>判断给出序列求是否是BST：（1）根据给出序列构建二叉树(insert)；（2）用vector比较是否一样（直接用==）；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;root, <span class="keyword">int</span> x,<span class="keyword">bool</span> mirror)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node;</span><br><span class="line">      <span class="comment">//需要写这句，或者在struct node初始化里就写好</span></span><br><span class="line">        root-&gt;l = root-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;data = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mirror) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= root-&gt;data) insert(root-&gt;l, x, mirror);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            insert(root-&gt;r, x, mirror);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= root-&gt;data) insert(root-&gt;r, x, mirror);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            insert(root-&gt;l, x, mirror);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>完全二叉查找树：同时有两者的性质，用数组存储，父子结点之间的关系用下标表示，for循环即是层序遍历；完全二叉树的形状已经确定了，又因为是查找树，对数组进行一次中序遍历，即可构建出树。</li>
<li>给n个结点关系，建立二叉查找树：静态链表存储，建树，然后按中序遍历将排序后的数组填入；</li>
</ul>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, height;    <span class="comment">//记录当前树的高度</span></span><br><span class="line">    node* l,* r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    node *root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;l = root-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;height = <span class="number">1</span>;</span><br><span class="line">    root-&gt;data = data;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;l), getHeight(root-&gt;r)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;l) - getHeight(root-&gt;r);    <span class="comment">//一定是左-右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左旋，注意是引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">    node* temp = root-&gt;r;</span><br><span class="line">    root-&gt;r = temp-&gt;l;</span><br><span class="line">    temp-&gt;l = root;</span><br><span class="line">    updateHeight(root);    <span class="comment">//一定先更新更低层的结点高度</span></span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">    node* temp = root-&gt;l;</span><br><span class="line">    root-&gt;l = temp-&gt;r;</span><br><span class="line">    temp-&gt;r = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = newNode(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data &gt;= root-&gt;data) &#123;</span><br><span class="line">        insert(root-&gt;r, data);    <span class="comment">//递归插入，递归更新高度</span></span><br><span class="line">        updateHeight(root);        <span class="comment">//插入点先更新，然后往回退</span></span><br><span class="line">        <span class="keyword">if</span> (getBalance(root) == <span class="number">-2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//RR</span></span><br><span class="line">            <span class="keyword">if</span> (getBalance(root-&gt;r) == <span class="number">-1</span>) &#123;</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//RL</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (getBalance(root-&gt;r) == <span class="number">1</span>) &#123;</span><br><span class="line">                R(root-&gt;r);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(root-&gt;l, data);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span> (getBalance(root) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//LL</span></span><br><span class="line">            <span class="keyword">if</span> (getBalance(root-&gt;l) == <span class="number">1</span>) &#123;</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//LR</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (getBalance(root-&gt;l) == <span class="number">-1</span>) &#123;</span><br><span class="line">                L(root-&gt;l);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>求相同属性个数，树状结构找根结点却不关心中间其他结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//备份</span></span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">  <span class="comment">// 找到根</span></span><br><span class="line">    <span class="keyword">while</span> (x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径压缩</span></span><br><span class="line">    <span class="keyword">while</span> (a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = findRoot(a);</span><br><span class="line">    <span class="keyword">int</span> fb = findRoot(b);</span><br><span class="line">    <span class="keyword">if</span> (fa != fb) &#123;</span><br><span class="line">        father[fa] = fb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序（求第k大-小的数）"><a href="#堆排序（求第k大-小的数）" class="headerlink" title="堆排序（求第k大/小的数）"></a>堆排序（求第k大/小的数）</h2><ul>
<li>建堆时downAdjust，插入结点用upAdjust；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j=<span class="number">2</span>*i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j+<span class="number">1</span>&lt;=high&amp;&amp;initial[j + <span class="number">1</span>] &gt; initial[j])    <span class="comment">//与较大孩子比较</span></span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (initial[j] &gt; initial[i]) &#123;</span><br><span class="line">            swap(initial[i],initial[j]);</span><br><span class="line">            i = j;</span><br><span class="line">            j = j * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)    <span class="comment">//从最后一个非叶结点开始</span></span><br><span class="line">        downAdjust(i, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//deap sort，递增排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deap_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">        swap(initial[i], initial[<span class="number">1</span>]);    <span class="comment">//取出最大值</span></span><br><span class="line">        downAdjust(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>哈夫曼树（非前缀编码），用priority_queue<long long,vector<long long>,greater<long long>&gt; q;代表小顶堆，每次取出最小两个元素向上建树；</long></long></li>
</ul>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次DFS遍历一个连通块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    visit[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Node[u].adj.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Node[u].adj[i];</span><br><span class="line">        <span class="keyword">if</span> (visit[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        DFS(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; maxn; u++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        DFS(u);</span><br><span class="line">    ｝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;    <span class="comment">//顶点编号</span></span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    node(<span class="keyword">int</span> _v, <span class="keyword">int</span> _lay) :v(_v), layer(_lay) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; adj[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> query,<span class="keyword">int</span> l,<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> inq[maxn] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">    <span class="function">node <span class="title">u</span><span class="params">(query, <span class="number">0</span>)</span></span>;    <span class="comment">//初始点</span></span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[query] = <span class="literal">true</span>;    <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = now.v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[u].size(); i++) &#123;</span><br><span class="line">            node next = adj[u][i];</span><br><span class="line">            next.layer = now.layer + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (inq[next.v] == <span class="literal">false</span>&amp;&amp;next.layer&lt;=l)    <span class="comment">//题目条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.push(next);</span><br><span class="line">                inq[next.v] = <span class="literal">true</span>;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无向图添加x条边使其连通：x=连通块个数-1； 计算连通块个数：DFS或者并查集</li>
</ul>
<h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s：起点；D：题目要求的终点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// d[i]：起点到i点的最短路径长度</span></span><br><span class="line">    fill(d,d+maxn,INF);</span><br><span class="line">    fill(num,num+maxn,<span class="number">0</span>);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    c[s] = <span class="number">0</span>;    <span class="comment">//第二标尺</span></span><br><span class="line">    num[s]=<span class="number">1</span>;        <span class="comment">//经过该结点的最短路径条数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        pre[i] = i;        <span class="comment">//记录前驱结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN)    <span class="comment">//找出最短边</span></span><br><span class="line">            &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span> || u == D) <span class="keyword">return</span>;    <span class="comment">//退出</span></span><br><span class="line">        visit[u] = <span class="literal">true</span>;        <span class="comment">//加入集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + G[u][v];</span><br><span class="line">                    c[v] = c[u] + cost[u][v];</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                    num[v]=num[u];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c[u] + cost[u][v] &lt; c[v])</span><br><span class="line">                    &#123;</span><br><span class="line">                        c[v] = c[u] + cost[u][v];</span><br><span class="line">                        pre[v] = u;</span><br><span class="line">                        num[v]+=num[u];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == s) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(pre[v]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多标尺要求通用模板，用Dijkstra+DFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    fill(d, d+n, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span> || u == ed) <span class="keyword">return</span>;</span><br><span class="line">        visit[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + G[u][v];</span><br><span class="line">                    pre[v].clear();        <span class="comment">//pre是一个vector&lt;int&gt;</span></span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v]) &#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temppath, path;</span><br><span class="line"><span class="keyword">int</span> send = INF, back = INF;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;       <span class="comment">//到达源点</span></span><br><span class="line">        temppath.push_back(v);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 题目条件的第二标尺判断</span></span><br><span class="line">        <span class="keyword">int</span> need = <span class="number">0</span>, remain = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = temppath.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = temppath[i];</span><br><span class="line">            <span class="keyword">if</span> (ci[id] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                remain += ci[id];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (remain &gt; <span class="built_in">abs</span>(ci[id])) &#123;</span><br><span class="line">                    remain -= <span class="built_in">abs</span>(ci[id]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    need += <span class="built_in">abs</span>(ci[id]) - remain;</span><br><span class="line">                    remain = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (need &lt; send) &#123;        <span class="comment">//根据条件更新最佳路径</span></span><br><span class="line">            send = need;</span><br><span class="line">            back = remain;</span><br><span class="line">            path = temppath;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (need == send&amp;&amp;remain &lt; back) &#123;</span><br><span class="line">            back = remain;</span><br><span class="line">            path = temppath;</span><br><span class="line">        &#125;</span><br><span class="line">        temppath.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temppath.push_back(v);    <span class="comment">//加入v</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].size(); i++) &#123;</span><br><span class="line">        DFS(pre[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    temppath.pop_back();        <span class="comment">//不加入v</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印path</span></span><br></pre></td></tr></table></figure>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>判断是否有负环 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(inq,inq+maxn,<span class="literal">false</span>);</span><br><span class="line">    fill(num,num+maxn,<span class="number">0</span>);</span><br><span class="line">    fill(d,d+maxn,INF);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    inq[s]=<span class="literal">true</span>;</span><br><span class="line">    num[s]++;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis=adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                d[v]=d[u]+dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v]=<span class="literal">true</span>;</span><br><span class="line">                    num[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全源最短路径"><a href="#全源最短路径" class="headerlink" title="全源最短路径"></a>全源最短路径</h2><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;        <span class="comment">//依次加入中间结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;    <span class="comment">//更新i,j之间的最短距离</span></span><br><span class="line">                <span class="keyword">if</span>(dis[i][k]!=INF&amp;&amp;dis[k][j]!=INF&amp;&amp;</span><br><span class="line">                dis[i][k]+dis[k][j]&lt;dis[i][j])&#123;</span><br><span class="line">                    dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="prime算法"><a href="#prime算法" class="headerlink" title="prime算法"></a>prime算法</h3><p>从源点st开始，依次加入集合S的最短边和对应的结点，代码类似Dijkstra ; d[v]=G[u][v] ；//d[]表示与集合S的距离</p>
<h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3><p>不需要源点，边贪心，先对边排序，选择全图中最短边；用并查集，加入边的时候判断会不会构成回路；</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>判断有向无环图：用队列；<code>if(num==n) return true;</code></p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>拓扑排序，建立正拓扑，得到<code>ve</code>（最长路径）；逆拓扑，得到<code>vl</code>（较小值）；</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>主要是状态转移方程和边界。状态转移方程需要保证状态无后效性。</p>
<h2 id="数塔"><a href="#数塔" class="headerlink" title="数塔"></a>数塔</h2><p>状态转移方程：<code>dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j]</code></p>
<h2 id="序列问题"><a href="#序列问题" class="headerlink" title="序列问题"></a>序列问题</h2><p>注意：子序列可以不连续，子串必须是连续的。</p>
<h3 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h3><p>O(n^2) -&gt; O(n)</p>
<p>状态转移方程：<code>dp[i]=max&#123;A[i],dp[i-1]+A[i]&#125;</code>。</p>
<p>备注： <code>dp[i]</code>表示以<code>A[i]</code>结尾的连续子序列最大和。</p>
<p>边界：<code>dp[0]=A[0]</code>。</p>
<h3 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h3><p>Longest Increasing Sequence, LIS。O(2^n) -&gt; O(n^2)</p>
<p>状态转移方程：<code>dp[i]=max&#123;dp[i], dp[j]+1&#125;</code>。</p>
<p>备注：<code>dp[i]</code>表示以<code>A[i]</code>结尾的LIS长度。</p>
<p>边界：<code>dp[i]=1</code>。</p>
<p>应用：最爱的颜色，给出序列，子序列需要满足eva最爱的颜色序列，求满足要求的最长序列长度； 同样可以用最长公共子序列做（修改方程）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i] &gt;= A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>); <span class="comment">//状态转移方程</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>Longest Common Subsequence, LCS。O(2^(m+n) * max(m,n)) -&gt; O(nm)</p>
<p>状态转移方程：<code>dp[i][j]=dp[i-1][j-1]+1,A[i]==B[j]</code>；<code>dp[i][j]=max&#123;dp[i-1][j],dp[i][j-1]&#125;</code>,<code>A[i]!=B[j]</code>；</p>
<p>备注：<code>dp[i][j]</code>表示<code>A[i]</code>和<code>B[j]</code>之前的LCS长度。</p>
<p> 边界:<code>dp[i][0]</code>=<code>dp[0][j]</code>=0；</p>
<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>状态转移方程：<code>dp[i][j]</code>=<code>dp[i+1][j-1]</code>,<code>s[i]</code>==<code>s[j]</code>；<code>dp[i][j]</code>=0, <code>s[i]</code>!=<code>s[j]</code>； </p>
<p>备注：<code>dp[i][j]</code>表示<code>s[i]</code>到<code>s[j]</code>的子串是否回文，是为1，不是为0；</p>
<p>边界：<code>dp[i][i]</code>=1,<code>dp[i][i+1]</code>=(<code>s[i]</code>==<code>s[i+1]</code>)?1:0</p>
<p>枚举方式需要改变：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 长度为1和2的字符串进行初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == str[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                ans = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取到等号,l为字符串长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">3</span>; l &lt;= len; l++) &#123;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + l - <span class="number">1</span> &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == str[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                ans = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DAG最长路"><a href="#DAG最长路" class="headerlink" title="DAG最长路"></a>DAG最长路</h2><p>状态转移方程：<code>dp[i] = max&#123;dp[i], dp[j]+G[i][j]&#125;</code></p>
<p>备注：<code>dp[i]</code>表示从<code>i</code>号顶点出发能获得的最大路径长度。<code>j</code>为<code>i</code>能到达的顶点。</p>
<p>边界：出度为0的顶点<code>dp[k]=0</code>。当求到达终点T的最大路径长度时，边界为：dp初始化为-INF，<code>dp[T]=0</code>，还需要<code>visit</code>数组标识是否被计算过。</p>
<p>有向无环图：不使用拓扑排序，可以用递归DFS输出路径。</p>
<p> 矩形嵌套问题；</p>
<p>序列满足一定前后继关系，求最长序列；</p>
<h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>状态转移方程：<code>dp[i][v]=max&#123;dp[i-1][v],dp[i-1][v-w[i]]+c[i]&#125;</code></p>
<p>备注：<code>dp[i][v]</code>表示前<code>i</code>件物品恰好装入容量为v的背包中能获得的最大价值。可以把<code>i</code>纬去掉，但是v必须逆序，从V到0（为了保证<code>dp[v-w[i]]</code>是<code>i-1</code>的值）。</p>
<p>边界：<code>dp[v]=0</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fill(dp, dp + maxn, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 此处因为要按字典序顺序，需要字典序最小的元素最后更新choice</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v = V; v &gt;= w[i]; v--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[v] &lt;= dp[v - w[i]] + w[i]) &#123;</span><br><span class="line">      dp[v] = dp[v - w[i]] + w[i];</span><br><span class="line">      choice[i][v] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      choice[i][v] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>状态转移方程：<code>dp[i][v]=max&#123;dp[i-1][v], dp[i][v-w[i]]+c[i]&#125;</code></p>
<p>备注：<code>dp[i][v]</code>表示前<code>i</code>件物品恰好装入容量为v的背包中能获得的最大价值。把<code>i</code>维去掉，v需要正向枚举，因为<code>dp[i][v-w[i]]</code>是<code>i</code>时刻的值，需要已经计算过。</p>
]]></content>
      <categories>
        <category>考研</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Rust异步入门</title>
    <url>/blog/757e7540.html</url>
    <content><![CDATA[<h1 id="异步入门"><a href="#异步入门" class="headerlink" title="异步入门"></a>异步入门</h1><h2 id="为什么需要异步？"><a href="#为什么需要异步？" class="headerlink" title="为什么需要异步？"></a>为什么需要异步？</h2><p><em>异步</em>操作是在非阻塞方案中执行的操作，允许主程序流继续处理。<br><a id="more"></a><br>假设需求场景为客户端从多个服务器下载多个文件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">下载方式</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">依次按照顺序</td>
<td style="text-align:left">必须等待前一个完成</td>
</tr>
<tr>
<td style="text-align:left">多线程</td>
<td style="text-align:left">为每一个下载任务创建线程，导致内存占满</td>
</tr>
<tr>
<td style="text-align:left">线程池</td>
<td style="text-align:left">发起下载请求后，需要等待服务端的响应，当前线程会阻塞</td>
</tr>
</tbody>
</table>
</div>
<p>注意：多线程和线程池都可以是异步的一种实现方式。异步是和同步相对的概念。</p>
<h2 id="异步的优缺点"><a href="#异步的优缺点" class="headerlink" title="异步的优缺点"></a>异步的优缺点</h2><p>因为异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少共享变量的数量），减少了死锁的可能。当然异步操作也并非完美无暇。编写异步操作的复杂程度较高，程序主要使用回调方式进行处理，与普通人的思维方式有些初入，而且难以调试。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="comment">// use std::thread::sleep;</span></span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">use</span> futures::&#123; executor&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">learn_song</span></span>() &#123;</span><br><span class="line">    <span class="comment">//sleep(Duration::from_secs(5));</span></span><br><span class="line">    task::sleep(Duration::from_secs(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;learn song&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">sing_song</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sing song&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">dance</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;dance&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">learn_and_sing_song</span></span>() &#123;</span><br><span class="line">    learn_song().<span class="keyword">await</span>;</span><br><span class="line">    sing_song().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = learn_and_sing_song();</span><br><span class="line">    <span class="keyword">let</span> f2 = dance();</span><br><span class="line">    futures::join!(f1, f2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    executor::block_on(async_main());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dance</span><br><span class="line">learn song</span><br><span class="line">sing song</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>如果使用<code>sleep(Duration::from_secs(5))</code>，结果会是按照顺序执行。因为外部的阻塞不能主动唤醒异步内部的线程，所以直接在外部进行阻塞。如果使用异步的<code>sleep</code>，<code>learn song</code>会让出资源；</li>
<li>通过join，能等待多个Future完成，并发执行；</li>
<li><code>.await</code>是在代码块中按顺序执行，会阻塞后面的代码，但是此时会让出线程；<code>block_on</code>会阻塞直到Future执行完成。</li>
</ol>
<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><h2 id="标准库定义"><a href="#标准库定义" class="headerlink" title="标准库定义"></a>标准库定义</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::marker::Unpin;</span><br><span class="line"><span class="keyword">use</span> crate::ops;</span><br><span class="line"><span class="keyword">use</span> crate::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> crate::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: ?<span class="built_in">Sized</span> + Future + Unpin&gt; Future <span class="keyword">for</span> &amp;<span class="keyword">mut</span> F &#123; <span class="comment">// F 的可变引用实现 Future</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = F::Output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        F::poll(Pin::new(&amp;<span class="keyword">mut</span> **<span class="keyword">self</span>), cx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;P&gt; Future <span class="keyword">for</span> Pin&lt;P&gt; <span class="comment">// 为 Pin&lt;P=Unpin + ops::DerefMut&lt;Target: Future&gt;&gt; 实现Future</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    P: Unpin + ops::DerefMut&lt;Target: Future&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = &lt;&lt;P <span class="keyword">as</span> ops::Deref&gt;::Target <span class="keyword">as</span> Future&gt;::Output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        Pin::get_mut(<span class="keyword">self</span>).as_mut().poll(cx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poll</code>函数传递一个 <code>&amp;mut Context&lt;&#39;_&gt;</code> 类型参数， 返回一个 <code>Poll</code> 类型参数：</p>
<ul>
<li><p>Context 主要包含一个 <code>Waker</code> 对象，由执行器提供，用于告诉执行器，重新执行当前 <code>poll</code> 函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">&quot;futures_api&quot;</span>, since = <span class="meta-string">&quot;1.36.0&quot;</span>)]</span></span><br><span class="line"> <span class="comment">// Context的生命周期不会比它包含的waker引用更久</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Context</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    waker: &amp;<span class="symbol">&#x27;a</span> Waker,</span><br><span class="line">    <span class="comment">// Ensure we future-proof against variance changes by forcing</span></span><br><span class="line">    <span class="comment">// the lifetime to be invariant (argument-position lifetimes</span></span><br><span class="line">    <span class="comment">// are contravariant while return-position lifetimes are</span></span><br><span class="line">    <span class="comment">// covariant).</span></span><br><span class="line">    _marker: PhantomData&lt;<span class="function"><span class="keyword">fn</span></span>(&amp;<span class="symbol">&#x27;a</span> ()) -&gt; &amp;<span class="symbol">&#x27;a</span> ()&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Poll 是一个枚举类型包含两个枚举</p>
<ul>
<li><code>Ready&lt;Output&gt;</code> 当任务已经就绪，返回该对象</li>
<li><code>Pending</code> 任务没有就绪时返回该对象，此Future将让出CPU，直到在其他线程或者任务执行调用<code>Waker</code>为止</li>
</ul>
</li>
<li><p>实现者需要保证 poll 是非阻塞，如果是阻塞的话会导致循环进行不下去</p>
</li>
</ul>
<p>实现一个 Future 类型的方式</p>
<ul>
<li>方式1：使用 <code>async fn</code>，编译器会自动生成实现 Future Trait的类型</li>
<li>方式2：自定义结构体，并实现 Future Trait</li>
</ul>
<h1 id="Pin"><a href="#Pin" class="headerlink" title="Pin"></a>Pin</h1><p>默认情况下，Rust中所有类型都是可以 <code>move</code> 的，Rust允许按值传递所有类型，并且像 <code>Box&lt;T&gt;</code> 、<code>&amp;mut T</code> 之类的智能指针或者引用允许你通过 <code>mem::swap</code> 进行拷贝交换（移动），这样，如果存在结构体存在自引用，将导致引用失效。</p>
<p>而 async 编译后的结构可能就会出现一种自引用的结构，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = [<span class="number">0</span>; <span class="number">128</span>];</span><br><span class="line">    <span class="keyword">let</span> read_into_buf_fut = read_into_buf(&amp;<span class="keyword">mut</span> x);</span><br><span class="line">    read_into_buf_fut.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后的伪代码如下</span></span><br><span class="line"><span class="comment">// 这是 最外层的 async &#123;&#125;</span></span><br><span class="line"><span class="comment">// struct AsyncFuture &#123;</span></span><br><span class="line"><span class="comment">//    x: [u8; 128],</span></span><br><span class="line"><span class="comment">//    read_into_buf_fut: ReadIntoBuf&lt;&#x27;what_lifetime?&gt;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是 read_into_buf_fut 的Future</span></span><br><span class="line"><span class="comment">// struct ReadIntoBuf&lt;&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="comment">//    buf: &amp;&#x27;a mut [u8], // points to `x` below</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>这样 AsyncFuture 构造出来后，就存在自引用（<code>AsyncFuture.read_into_buf_fut.buf</code> 指向 <code>AsyncFuture.x</code>）。但是如果AsyncFuture发生移动，x肯定也会发生移动，如果<code>read_into_buf_fut.buf</code>还是指向原来的值的话，则会变成无效。而Pin就是为了解决此问题的。</p>
<p>Pin 类型包着指针类型，保证指针背后的值将不被移动。例如 <code>Pin&lt;&amp;mut T&gt;</code>，<code>Pin&lt;&amp;T&gt;</code>， <code>Pin&lt;Box&lt;T&gt;&gt;</code> 都保证 <code>T</code> 不会移动（move）。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pin</span></span>&lt;P&gt; &#123;</span><br><span class="line">    pointer: P,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先 <code>Pin&lt;T&gt;</code> 和 <code>Box&lt;T&gt;</code> 类似都是一种智能指针。不同点在于<code>Pin&lt;&amp;mut T&gt;</code>不能通过safe代码拿到<code>&amp;mut T</code>，因此保证<code>mem::swap</code>无法调用，也就是<code>P</code>所指向的<code>T</code>在内存中固定住，不能移动。</p>
<ul>
<li><p><code>Pin::as_mut</code> 返回的仍是 <code>Pin&lt;T&gt;</code></p>
</li>
<li><p>只有 <code>Pin&lt;DerefMut&lt;T: Unpin&gt;&gt;</code> 或者 <code>Pin&lt;Deref&lt;T: Unpin&gt;&gt;</code> 或者 <code>Pin&lt;T: Unpin&gt;</code> 可以通过 <code>get_mut</code> 或者 <code>get_ref</code> 拿到 <code>T</code> 的引用</p>
</li>
<li><p><code>Pin::new</code> 只能是针对实现了 <code>Unpin</code> 的类型（重要）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">    <span class="comment">/// Construct a new `Pin&lt;P&gt;` around a pointer to some data of a type that</span></span><br><span class="line">    <span class="comment">/// implements [`Unpin`].</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Unlike `Pin::new_unchecked`, this method is safe because the pointer</span></span><br><span class="line">    <span class="comment">/// `P` dereferences to an [`Unpin`] type, which cancels the pinning guarantees.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">&quot;pin&quot;</span>, since = <span class="meta-string">&quot;1.33.0&quot;</span>)]</span></span><br><span class="line">    <span class="meta">#[inline(always)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(pointer: P) -&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">        <span class="comment">// Safety: the value pointed to is `Unpin`, and so has no requirements</span></span><br><span class="line">        <span class="comment">// around pinning.</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(pointer) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Unwraps this `Pin&lt;P&gt;` returning the underlying pointer.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// This requires that the data inside this `Pin` is [`Unpin`] so that we</span></span><br><span class="line">    <span class="comment">/// can ignore the pinning invariants when unwrapping it.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">&quot;pin_into_inner&quot;</span>, since = <span class="meta-string">&quot;1.39.0&quot;</span>)]</span></span><br><span class="line">    <span class="meta">#[inline(always)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">into_inner</span></span>(pin: Pin&lt;P&gt;) -&gt; P &#123;</span><br><span class="line">        pin.pointer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有<code>P&lt;T&gt;</code>的<code>T: Unpin</code>，才可以new出一个<code>Pin&lt;P&lt;T&gt;&gt;</code>。这里的T就是应该被pin的实例，可是由于<code>T: Unpin</code>实际上T的实例并不会被pin。</p>
</li>
<li><p>如果要创建不实现<code>Unpin</code>的<code>Pin&lt;P&lt;T&gt;&gt;</code>，可以使用<code>unsafe&#123; Pin::new_unchecked(&amp;mut t) &#125;</code>。</p>
</li>
</ul>
</li>
<li><p>本质上实现不移动就是加了一层指针，并未违反任意值都是可以移动的规则。</p>
<ul>
<li>比如 <code>Pin&lt;T&gt;</code> 发生移动时，仅仅是 <code>Pin</code> 这个结构发生了移动，但是 <code>T</code> 对象并没有移动</li>
</ul>
</li>
</ul>
<h2 id="Unpin"><a href="#Unpin" class="headerlink" title="Unpin"></a>Unpin</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> auto <span class="class"><span class="keyword">trait</span> <span class="title">Unpin</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>定义在<code>std::marker</code>中，如果<code>T: Unpin</code>，那么<code>T</code>在<code>pin</code>后可以安全地移动，可以拿到<code>&amp;mut T</code>。<code>Unpin</code>只对<code>Pin&lt;P&lt;T&gt;&gt;</code>的<code>T</code>起作用，不对<code>P</code>本身起效，例如对<code>Pin&lt;Box&lt;T&gt;&gt;</code>的<code>Box&lt;T&gt;</code>是无效的。</p>
<p>默认为以下类型实现了<code>Unpin</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T: ?<span class="built_in">Sized</span> + <span class="symbol">&#x27;a</span>&gt; Unpin <span class="keyword">for</span> &amp;<span class="symbol">&#x27;a</span> T &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T: ?<span class="built_in">Sized</span> + <span class="symbol">&#x27;a</span>&gt; Unpin <span class="keyword">for</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; Unpin <span class="keyword">for</span> *<span class="keyword">const</span> T &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; Unpin <span class="keyword">for</span> *<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>async</code>生成的匿名结构体（<code>impl Future&lt;Output=()&gt;</code>）没有实现<code>Unpin</code>。</p>
<h3 id="Unpin-1"><a href="#Unpin-1" class="headerlink" title="!Unpin"></a>!Unpin</h3><p>对Unpin取反，!Unpin的双重否定就是pin。如果一个类型中包含了PhantomPinned，那么这个类型就是!Unpin。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PhantomPinned</span></span>;</span><br><span class="line"><span class="keyword">impl</span> !Unpin <span class="keyword">for</span> PhantomPinned &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一般在结构体中使用<code>_marker: PhantomPinned</code>来实现<code>!Unpin</code>。</p>
<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::marker::PhantomPinned;</span><br><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">    b: *<span class="keyword">const</span> <span class="built_in">String</span>,</span><br><span class="line">    _marker: PhantomPinned</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(txt: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">//此指针指向栈对象， 必须慎重考虑其生命长短，避免出现`悬指针`。</span></span><br><span class="line">        Test &#123;</span><br><span class="line">            a: <span class="built_in">String</span>::from(txt),</span><br><span class="line">            b: std::ptr::null(),</span><br><span class="line">            _marker: PhantomPinned</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(<span class="keyword">self</span>: Pin&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> self_ptr: *<span class="keyword">const</span> <span class="built_in">String</span> = &amp;<span class="keyword">self</span>.a;</span><br><span class="line">        <span class="keyword">let</span> this = <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.get_unchecked_mut() &#125;;</span><br><span class="line">        this.b = self_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">a</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(<span class="keyword">self</span>: Pin&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">Self</span>&gt;) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.get_ref().a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">b</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(<span class="keyword">self</span>: Pin&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">Self</span>&gt;) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*(<span class="keyword">self</span>.b) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="comment">// test1 is safe to move before we initialize it</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> test1 = Test::new(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"><span class="comment">// Notice how we shadow `test1` to prevent it from being accessed again</span></span><br><span class="line"><span class="comment">//同名的新指针变量屏蔽了原来的test1, 以此确保只能通过Pin来访问到Test.</span></span><br><span class="line"><span class="comment">//这样确保不可能再访问到旧test1指针！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> test1 = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="keyword">mut</span> test1) &#125;;</span><br><span class="line">    Test::init(test1.as_mut());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> test2 = Test::new(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> test2 = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="keyword">mut</span> test2) &#125;;</span><br><span class="line">    Test::init(test2.as_mut());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, Test::a(test1.as_ref()), Test::b(test1.as_ref()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//swap导致编译错误， 因为Pin实质上就是禁止获得&amp;mut T引用(指针) ，</span></span><br><span class="line"><span class="comment">//无法获得&amp;mut T指针，则无法Move , 比如：swap等。</span></span><br><span class="line"><span class="comment">//之所以用Pin 包裹原来的裸指针，目的就是禁止获取到：&amp;mut T.</span></span><br><span class="line"><span class="comment">//     std::mem::swap(test1.get_mut(), test2.get_mut());</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, Test::a(test2.as_ref()), Test::b(test2.as_ref()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// a: test1, b: test1</span></span><br><span class="line"><span class="comment">// a: test2, b: test2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> test1 = Test::new(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> test1_pin = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="keyword">mut</span> test1) &#125;;</span><br><span class="line">    Test::init(test1_pin.as_mut());</span><br><span class="line">    <span class="built_in">drop</span>(test1_pin); <span class="comment">//Pin指针被提前drop , 因为test1未被遮蔽， 后面代码仍然可以访问到， 但是test1已被析构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> test2 = Test::new(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    mem::swap(&amp;<span class="keyword">mut</span> test1, &amp;<span class="keyword">mut</span> test2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Not self referential anymore: &#123;:?&#125;&quot;</span>, test1.b); <span class="comment">//test1.b == 0x00 ， Pin析构时析构了test1 所指的Test Struct, 其内部指针归0，</span></span><br><span class="line"><span class="comment">//所以说不再是自引用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>Box::pin(t)</code>创建<code>Pin&lt;Box&lt;T&gt;&gt;</code>，则会将数据固定到堆上。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> Test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(txt: &amp;<span class="built_in">str</span>) -&gt; Pin&lt;<span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> t = Test &#123;</span><br><span class="line">         a: <span class="built_in">String</span>::from(txt),</span><br><span class="line">         b: std::ptr::null(),</span><br><span class="line">         _marker: PhantomPinned,</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="comment">//Constructs a new Pin&lt;Box&lt;T&gt;&gt;. If T does not implement Unpin, then x will be pinned in memory and unable to be moved.</span></span><br><span class="line">     <span class="keyword">let</span> <span class="keyword">mut</span> boxed = <span class="built_in">Box</span>::pin(t);</span><br><span class="line">     <span class="keyword">let</span> self_ptr: *<span class="keyword">const</span> <span class="built_in">String</span> = &amp;boxed.as_ref().a;</span><br><span class="line">      <span class="comment">// boxed.as_mut() -&gt; Pin&lt;&amp;mut Test&gt;</span></span><br><span class="line">      <span class="comment">// boxed.as_mut().get_unchecked_mut() -&gt; &amp;mut Test</span></span><br><span class="line">     <span class="keyword">unsafe</span> &#123; boxed.as_mut().get_unchecked_mut().b = self_ptr &#125;;</span><br><span class="line">     boxed</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> test1 = Test::new(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> test2 = Test::new(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, test1.as_ref().a(), test1.as_ref().b());</span><br><span class="line">    std::mem::swap(&amp;<span class="keyword">mut</span> test1, &amp;<span class="keyword">mut</span> test2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, test2.as_ref().a(), test2.as_ref().b()); </span><br><span class="line">  <span class="comment">// 结果</span></span><br><span class="line">  <span class="comment">// a: test1, b: test1</span></span><br><span class="line">	<span class="comment">// a: test1, b: test1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么堆上的<code>pin</code>对象可以进行<code>swap</code>？</p>
<p><code>boxed</code>只是一个栈变量，所指的对象在堆上。通过<code>swap</code>仅仅<code>bitcopy and swap</code>两个栈变量<code>test1</code>和<code>test2</code>，相当于两者交换了所有权，交换了指向，而堆上的数据不受影响。<code>T</code>类型对象内存位置固定，所有没有违反<code>Pin</code>的语义要求。</p>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h1><p>async转化的Future对象和其它Future一样是具有惰性的，即在运行之前什么也不做。运行Future最常见的方式是<code>.await</code>。</p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>有如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = async_function1();</span><br><span class="line">    <span class="keyword">let</span> f2 = async_function2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        f1.<span class="keyword">await</span>;</span><br><span class="line">        f2.<span class="keyword">await</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    f.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么实际上会生成一个匿名的<code>Future trait object</code>，包裹一个 <code>Generator</code>。也就是一个实现了 <code>Future</code> 的 <code>Generator</code>。<code>Generator</code>实际上是一个状态机，配合<code>.await</code>当每次<code>async</code> 代码块中任何返回 <code>Poll::Pending</code>则即调用<code>generator yeild</code>，让出执行权，一旦恢复执行，<code>generator resume</code> 继续执行剩余流程。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_generator</span></span>&lt;T&gt;(gen: T) -&gt; <span class="keyword">impl</span> Future&lt;Output = T::Return&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Generator&lt;ResumeTy, Yield = ()&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#[rustc_diagnostic_item = <span class="meta-string">&quot;gen_future&quot;</span>]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GenFuture</span></span>&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We rely on the fact that async/await futures are immovable in order to create</span></span><br><span class="line">    <span class="comment">// self-referential borrows in the underlying generator.</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin <span class="keyword">for</span> GenFuture&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; Future <span class="keyword">for</span> GenFuture&lt;T&gt; &#123;</span><br><span class="line">        <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = T::Return;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">            <span class="comment">// Safety: Safe because we&#x27;re !Unpin + !Drop, and this is just a field projection.</span></span><br><span class="line">            <span class="keyword">let</span> gen = <span class="keyword">unsafe</span> &#123; Pin::map_unchecked_mut(<span class="keyword">self</span>, |s| &amp;<span class="keyword">mut</span> s.<span class="number">0</span>) &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Resume the generator, turning the `&amp;mut Context` into a `NonNull` raw pointer. The</span></span><br><span class="line">            <span class="comment">// `.await` lowering will safely cast that back to a `&amp;mut Context`.</span></span><br><span class="line">            <span class="keyword">match</span> gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;<span class="symbol">&#x27;static</span>&gt;&gt;())) &#123;</span><br><span class="line">                GeneratorState::Yielded(()) =&gt; Poll::Pending,</span><br><span class="line">                GeneratorState::Complete(x) =&gt; Poll::Ready(x),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GenFuture(gen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次<code>gen.resume(）</code>会顺序执行<code>async block</code>中代码直到遇到<code>yield</code>。<code>async block</code>中的<code>.await</code>语句在无法立即完成时会调用<code>yield</code>交出控制权等待下一次<code>resume</code>。而当所有代码执行完，也就是状态机入<code>Complete</code>，<code>async block</code>返回<code>Poll::Ready</code>，代表<code>Future</code>执行完毕。</p>
<p>生成的匿名对象类似如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncFuture</span></span> &#123;</span><br><span class="line">    fut_one: FutFunction1,</span><br><span class="line">    fut_two: FutFunction2,</span><br><span class="line">    state: State,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//state的定义可能如下</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    AwaitingFutFunction1,</span><br><span class="line">    AwaitingFutFunction2,</span><br><span class="line">    Done,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poll</code>进行轮询每个<code>Future</code>的状态，如果<code>Poll::Ready()</code>则进入下一个<code>State</code>，直到<code>Done</code>。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: &amp;<span class="built_in">u8</span>) -&gt; <span class="built_in">u8</span> &#123; *x &#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">good</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = ()&gt; &#123;</span><br><span class="line">    <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">        foo(&amp;x).<span class="keyword">await</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将<code>x</code>移动到<code>async</code>中，延长<code>x</code>的生命周期和<code>foo</code>返回的Future生命周期一致。</p>
<h2 id="move"><a href="#move" class="headerlink" title="move"></a>move</h2><p>async 块和闭包允许 move 关键字，就像普通的闭包一样。一个 async move 块将获取它引用变量的所有权，允许它活得比目前的范围长，但放弃了与其它代码分享那些变量的能力。</p>
<h2 id="线程间移动"><a href="#线程间移动" class="headerlink" title="线程间移动"></a>线程间移动</h2><p>在使用多线程Future的excutor时，Future可能在线程之间移动，因此在async主体中使用的任何变量都必须能够在线程之间传输，因为任何.await变量都可能导致切换到新线程。</p>
<p>async fn Future是否为Send的取决于是否在.await点上保留非Send类型。编译器尽其所能地估计值在.await点上的保存时间。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x = Rc&lt;()&gt;; <span class="comment">// Rc&lt;T&gt;不可Send</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>x</code>不在<code>await</code>前drop，那么该Future是非Send的。而Future的异步特性要求需要有<code>Send</code>约束。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p><code>Stream</code>是由一系列的<code>Future</code>组成，我们可以从<code>Stream</code>读取各个<code>Future</code>的结果，直到<code>Stream</code>结束。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Stream</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_next</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, lw: &amp;LocalWaker)</span><br><span class="line">        -&gt; Poll&lt;<span class="built_in">Option</span>&lt;Self::Item&gt;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poll_next</code>函数有三种可能的返回值，分别如下：</p>
<ul>
<li><code>Poll::Pending</code> 说明下一个值还没有就绪，仍然需要等待。</li>
<li><code>Poll::Ready(Some(val))</code> 已经就绪，成功返回一个值，程序可以通过调用<code>poll_next</code>再获取下一个值。</li>
<li><code>Poll::Ready(None)</code> 表示<code>Stream</code>已经结束，不应该在调用<code>poll_next</code>。</li>
</ul>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><code>Stream</code>不支持使用<code>for</code>，而<code>while let</code>和 <code>next/try_next</code>则是允许的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">sum_with_next</span></span>(<span class="keyword">mut</span> stream: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Stream&lt;Item = <span class="built_in">i32</span>&gt;&gt;) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">use</span> futures::stream::StreamExt; <span class="comment">// for `next`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(item) = stream.next().<span class="keyword">await</span> &#123;</span><br><span class="line">        sum += item;</span><br><span class="line">    &#125;</span><br><span class="line">    sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">sum_with_try_next</span></span>(<span class="keyword">mut</span> stream: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Stream&lt;Item = <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, io::Error&gt;&gt;&gt;</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> futures::stream::TryStreamExt; <span class="comment">// for `try_next`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(item) = stream.try_next().<span class="keyword">await</span>? &#123;</span><br><span class="line">        sum += item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">jump_around</span></span>(</span><br><span class="line">    <span class="keyword">mut</span> stream: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Stream&lt;Item = <span class="built_in">Result</span>&lt;<span class="built_in">u8</span>, io::Error&gt;&gt;&gt;,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;(), io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> futures::stream::TryStreamExt; <span class="comment">// for `try_for_each_concurrent`</span></span><br><span class="line">    <span class="keyword">const</span> MAX_CONCURRENT_JUMPERS: <span class="built_in">usize</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    stream.try_for_each_concurrent(MAX_CONCURRENT_JUMPERS, |num| <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        jump_n_times(num).<span class="keyword">await</span>?;</span><br><span class="line">        report_n_jumps(num).<span class="keyword">await</span>?;</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h1><p>select宏也允许并发的执行Future，但是和join、try_join不同的是，select宏只要有一个Future返回，就会返回。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::&#123;select, future::FutureExt, pin_mut&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::runtime::Runtime;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">function1</span></span>() -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    tokio::time::delay_for(tokio::time::Duration::from_secs(<span class="number">10</span>)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;function1 ++++ &quot;</span>);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">function2</span></span>() -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;function2 ++++ &quot;</span>);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_main</span></span>() &#123;</span><br><span class="line">  <span class="comment">// Fuse：基础迭代器一次返回None后，就一直返回None</span></span><br><span class="line">    <span class="keyword">let</span> f1 = function1().fuse();</span><br><span class="line">    <span class="keyword">let</span> f2 = function2().fuse();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在栈上pin</span></span><br><span class="line">    pin_mut!(f1, f2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">select!</span> &#123;</span><br><span class="line">        _ = f1 =&gt; <span class="built_in">println!</span>(<span class="string">&quot;task one completed first&quot;</span>),</span><br><span class="line">        _ = f2 =&gt; <span class="built_in">println!</span>(<span class="string">&quot;task two completed first&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> runtime = Runtime::new().unwrap();</span><br><span class="line">    runtime.block_on(async_main());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="BoxFuture"><a href="#BoxFuture" class="headerlink" title="BoxFuture"></a>BoxFuture</h1><p>一个拥有的动态类型[‘ Future ‘]，在不是静态输入或需要添加一些间接类型的情况下使用。</p>
<p>比如在递归使用Future时：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::future::&#123;BoxFuture, FutureExt&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">re</span></span>() -&gt; BoxFuture&lt;<span class="symbol">&#x27;static</span>, ()&gt; &#123;</span><br><span class="line">	<span class="keyword">async</span> <span class="keyword">move</span>&#123;</span><br><span class="line">		re().<span class="keyword">await</span>;</span><br><span class="line">		re().<span class="keyword">await</span>;</span><br><span class="line">	&#125;.boxed()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	re();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">boxed</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(<span class="keyword">self</span>) -&gt; BoxFuture&lt;<span class="symbol">&#x27;a</span>, Self::Output&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span> + <span class="built_in">Send</span> + <span class="symbol">&#x27;a</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Box</span>::pin(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.rectcircle.cn/posts/rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">Rust异步编程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/157348723">Rust 异步编程，Pin 介绍</a></li>
<li><a href="https://rustcc.cn/article?id=1d0a46fa-da56-40ae-bb4e-fe1b85f68751">Pin Unpin学习笔记</a></li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
        <category>异步</category>
      </categories>
  </entry>
  <entry>
    <title>java8</title>
    <url>/blog/92a2fe0d.html</url>
    <content><![CDATA[<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>语法格式：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><br>使用 Lambda 表达式需要注意以下两点：</p>
<ul>
<li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。</li>
<li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>
<p>lambda 表达式引用的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用通过方法的名字来指向一个方法。</p>
<p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>方法引用使用一对冒号 <strong>::</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">(<span class="keyword">final</span> Supplier&lt;Car&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(<span class="keyword">final</span> Car car)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Collided &quot;</span> + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">final</span> Car another)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Following the &quot;</span> + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Repaired &quot;</span> + <span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>构造器引用：</strong>它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Car car = Car.create( Car::<span class="keyword">new</span> ); </span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法引用：</strong>它的语法是Class::static_method，实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特定类的任意对象的方法引用：</strong>它的语法是Class::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特定对象的方法引用：</strong>它的语法是instance::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> ); cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>
<p>函数式接口可以被隐式转换为 lambda 表达式。</p>
<p>JDK 1.8 新增加的函数接口：</p>
<ul>
<li>java.util.function</li>
</ul>
<h2 id="函数式接口实例"><a href="#函数式接口实例" class="headerlink" title="函数式接口实例"></a>函数式接口实例</h2><p>Predicate \<T\> 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。</T\></p>
<p>该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。</p>
<p>该接口用于测试对象是 true 或 false。</p>
<p>我们可以通过以下实例（Java8Tester.java）来了解函数式接口 Predicate \<T\> 的使用：</T\></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Predicate&lt;Integer&gt; predicate = n -&gt; true</span></span><br><span class="line">      <span class="comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span></span><br><span class="line">      <span class="comment">// n 如果存在则 test 方法返回 true</span></span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">&quot;输出所有数据:&quot;</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 传递参数 n</span></span><br><span class="line">      eval(list, n-&gt;<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span></span><br><span class="line">      <span class="comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span></span><br><span class="line">      <span class="comment">// 如果 n%2 为 0 test 方法返回 true</span></span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">&quot;输出所有偶数:&quot;</span>);</span><br><span class="line">      eval(list, n-&gt; n%<span class="number">2</span> == <span class="number">0</span> );</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span></span><br><span class="line">      <span class="comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span></span><br><span class="line">      <span class="comment">// 如果 n 大于 3 test 方法返回 true</span></span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">&quot;输出大于 3 的所有数字:&quot;</span>);</span><br><span class="line">      eval(list, n-&gt; n &gt; <span class="number">3</span> );</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eval</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(Integer n: list) &#123;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span>(predicate.test(n)) &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; &quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h1><blockquote>
<p>为什么要有这个特性？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以前创建了一个接口，并且已经被大量的类实现。</span><br><span class="line">如果需要再扩充这个接口的功能加新的方法，就会导致所有已经实现的子类需要重写这个方法。</span><br><span class="line">如果在接口中使用默认方法就不会有这个问题。</span><br><span class="line">所以从 JDK8 开始新加了接口默认方法，便于接口的扩展。</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="多个默认方法"><a href="#多个默认方法" class="headerlink" title="多个默认方法"></a>多个默认方法</h2><p>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法，第二种解决方案可以使用 super 来调用指定接口的默认方法。</p>
<h2 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h2><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h2 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<h2 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h2><p>在 Java 8 中, 集合接口有两个方法来生成流：</p>
<ul>
<li><strong>stream()</strong> − 为集合创建串行流。</li>
<li><strong>parallelStream()</strong> − 为集合创建并行流。</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 方法用于映射每个元素到对应的结果。以下代码片段使用 map 输出了元素对应的平方数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">long</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h3><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>
<h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;筛选列表: &quot;</span> + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br></pre></td></tr></table></figure>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>
<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>Optional 类的引入很好的解决空指针异常。</p>
<blockquote>
<p>类似Rust中Option类型</p>
</blockquote>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>static  Optional empty()</strong>返回空的 Optional 实例。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>boolean equals(Object obj)</strong>判断其他对象是否等于 Optional。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>Optional filter(Predicate predicate)</strong>如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong> Optional flatMap(Function&gt; mapper)</strong>如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>T get()</strong>如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>int hashCode()</strong>返回存在值的哈希码，如果值不存在 返回 0。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>void ifPresent(Consumer consumer)</strong>如果值存在则使用该值调用 consumer , 否则不做任何事情。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>boolean isPresent()</strong>如果值存在则方法会返回true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>Optional map(Function mapper)</strong>如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>static  Optional of(T value)</strong>返回一个指定非null值的Optional。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>static  Optional ofNullable(T value)</strong>如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>T orElse(T other)</strong>如果存在该值，返回值， 否则返回 other。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>T orElseGet(Supplier other)</strong>如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>T orElseThrow(Supplier exceptionSupplier)</strong> 如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>String toString()</strong>返回一个Optional的非空字符串，用来调试</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意：</strong> 这些方法是从 <strong>java.lang.Object</strong> 类继承来的。</p>
<h1 id="Nashorn-JavaScript"><a href="#Nashorn-JavaScript" class="headerlink" title="Nashorn JavaScript"></a>Nashorn JavaScript</h1><p>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</p>
<p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p>
<h2 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h2><p>jjs是个基于Nashorn引擎的<strong>命令行</strong>工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。</p>
<h2 id="Java-中调用-JavaScript"><a href="#Java-中调用-JavaScript" class="headerlink" title="Java 中调用 JavaScript"></a>Java 中调用 JavaScript</h2><p>使用 ScriptEngineManager, JavaScript 代码可以在 Java 中执行，实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">      ScriptEngineManager scriptEngineManager = <span class="keyword">new</span> ScriptEngineManager();</span><br><span class="line">      ScriptEngine nashorn = scriptEngineManager.getEngineByName(<span class="string">&quot;nashorn&quot;</span>);</span><br><span class="line">        </span><br><span class="line">      String name = <span class="string">&quot;Runoob&quot;</span>;</span><br><span class="line">      Integer result = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         nashorn.eval(<span class="string">&quot;print(&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line">         result = (Integer) nashorn.eval(<span class="string">&quot;10 + 2&quot;</span>);</span><br><span class="line">         </span><br><span class="line">      &#125;<span class="keyword">catch</span>(ScriptException e)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;执行脚本错误: &quot;</span>+ e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      System.out.println(result.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript-中调用-Java"><a href="#JavaScript-中调用-Java" class="headerlink" title="JavaScript 中调用 Java"></a>JavaScript 中调用 Java</h2><p>以下实例演示了如何在 JavaScript 中引用 Java 类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> BigDecimal = Java.type(<span class="string">&#x27;java.math.BigDecimal&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params">amount, percentage</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> result = <span class="keyword">new</span> BigDecimal(amount).multiply(</span><br><span class="line">   <span class="keyword">new</span> BigDecimal(percentage)).divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;100&quot;</span>), <span class="number">2</span>, BigDecimal.ROUND_HALF_EVEN);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> result.toPlainString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = calculate(<span class="number">568000000000000000023</span>,<span class="number">13.9</span>);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure>
<p>使用 jjs 命令执行以上脚本。</p>
<h1 id="日期时间api"><a href="#日期时间api" class="headerlink" title="日期时间api"></a>日期时间api</h1><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。</p>
<p>在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：</p>
<ul>
<li><strong>非线程安全</strong> − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li><strong>设计很差</strong> − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li>
<li><strong>时区处理麻烦</strong> − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li>
</ul>
<p>Java 8 在 <strong>java.time</strong> 包下提供了很多新的 API。以下为两个比较重要的 API：</p>
<ul>
<li><strong>Local(本地)</strong> − 简化了日期时间的处理，没有时区的问题。</li>
<li><strong>Zoned(时区)</strong> − 通过制定的时区处理日期时间。</li>
</ul>
<p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p>
<p>在<code>java.time</code>包中。</p>
<h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><p>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p>
<ul>
<li><strong>基本：</strong>输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li>
<li><strong>URL：</strong>输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li>
<li><strong>MIME：</strong>输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li>
</ul>
<h2 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">内嵌类 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>static class Base64.Decoder</strong>该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>static class Base64.Encoder</strong>该类实现一个编码器，使用 Base64 编码来编码字节数据。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法名 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>static Base64.Decoder getDecoder()</strong>返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>static Base64.Encoder getEncoder()</strong>返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>static Base64.Decoder getMimeDecoder()</strong>返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>static Base64.Encoder getMimeEncoder()</strong>返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)</strong>返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>static Base64.Decoder getUrlDecoder()</strong>返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>static Base64.Encoder getUrlEncoder()</strong>返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意：</strong>Base64 类的很多方法从 <strong>java.lang.Object</strong> 类继承。</p>
<h2 id="Base64-实例"><a href="#Base64-实例" class="headerlink" title="Base64 实例"></a>Base64 实例</h2><p>以下实例演示了 Base64 的使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 使用基本编码</span></span><br><span class="line">         String base64encodedString = Base64.getEncoder().encodeToString(<span class="string">&quot;runoob?java8&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">         System.out.println(<span class="string">&quot;Base64 编码字符串 (基本) :&quot;</span> + base64encodedString);</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 解码</span></span><br><span class="line">         <span class="keyword">byte</span>[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">        </span><br><span class="line">         System.out.println(<span class="string">&quot;原始字符串: &quot;</span> + <span class="keyword">new</span> String(base64decodedBytes, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">         base64encodedString = Base64.getUrlEncoder().encodeToString(<span class="string">&quot;runoob?java8&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">         System.out.println(<span class="string">&quot;Base64 编码字符串 (URL) :&quot;</span> + base64encodedString);</span><br><span class="line">        </span><br><span class="line">         StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">byte</span>[] mimeBytes = stringBuilder.toString().getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">         String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">         System.out.println(<span class="string">&quot;Base64 编码字符串 (MIME) :&quot;</span> + mimeEncodedString);</span><br><span class="line">         </span><br><span class="line">      &#125;<span class="keyword">catch</span>(UnsupportedEncodingException e)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Error :&quot;</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>路线与基础</category>
      </categories>
  </entry>
  <entry>
    <title>java语言基础</title>
    <url>/blog/8ab7cabf.html</url>
    <content><![CDATA[<p>记录Java基础<br><a id="more"></a></p>
<h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><h2 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h2><ul>
<li>一个源文件中只能有一个public类</li>
<li>一个源文件可以有多个非public类</li>
<li>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li>
<li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li>
<li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.abmatrix.bool.main.controller;</span><br><span class="line"><span class="keyword">import</span> com.abmatrix.bool.common.bean.PagingInfo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakerController</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、数组都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用任何与之兼容的类型。</li>
<li>例子：Site site = new Site(“Runoob”)。</li>
</ul>
<h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>（<span class="number">8</span>）,<span class="keyword">short</span>（<span class="number">16</span>）,<span class="keyword">char</span>（<span class="number">16</span>）—&gt; <span class="keyword">int</span>（<span class="number">32</span>） —&gt; <span class="keyword">long</span>（<span class="number">64</span>）—&gt; <span class="keyword">float</span>（<span class="number">32</span>） —&gt; <span class="keyword">double</span> （<span class="number">64</span>）</span><br></pre></td></tr></table></figure>
<p>虽然float只有32位，但是是用阶数表示的，舍弃了一部分精度，来保存更大的浮点型数据。所有long类型可以自动转换为float类型。</p>
<ul>
<li><ol>
<li>不能对boolean类型进行类型转换。</li>
</ol>
</li>
<li><ol>
<li>不能把对象类型转换成不相关类的对象</li>
</ol>
</li>
<li><ol>
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
</ol>
</li>
<li><ol>
<li>转换过程中可能导致溢出或损失精度，例如：</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">128</span>;   </span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br></pre></td></tr></table></figure>
<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
<ul>
<li><ol>
<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span>)<span class="number">23.7</span> == <span class="number">23</span>;        </span><br><span class="line">(<span class="keyword">int</span>)-<span class="number">45.89f</span> == -<span class="number">45</span></span><br></pre></td></tr></table></figure>
<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ul>
<li>局部变量声明在方法、构造方法或者语句块中；</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li>
<li>访问修饰符不能用于局部变量；</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
<li>实例变量可以声明在使用前或者使用后；</li>
<li>访问修饰符可以修饰实例变量；</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>
</ul>
<h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><ul>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li>
<li>静态变量在第一次被访问时创建，在程序结束时销毁。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：ClassName.VariableName的方式访问。</li>
<li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
</ul>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p><img src="http://image-jennerblog.test.upcdn.net/img/image-20200325153359075.png" alt="image-20200325153359075"></p>
<h3 id="默认访问修饰符-不使用任何关键字"><a href="#默认访问修饰符-不使用任何关键字" class="headerlink" title="默认访问修饰符-不使用任何关键字"></a>默认访问修饰符-不使用任何关键字</h3><p>使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 <strong>public static final</strong>,而接口里的方法默认情况下访问权限为 <strong>public</strong>。</p>
<h3 id="private修饰符代表的可见性说明"><a href="#private修饰符代表的可见性说明" class="headerlink" title="private修饰符代表的可见性说明"></a>private修饰符代表的可见性说明</h3><p>如果一个成员被声明为private，它就只能在<strong>定义该成员的最外层类的范围</strong>之内访问。具体地，有两点容易被忽略。</p>
<h4 id="可见性是针对于类来说的，不是对象"><a href="#可见性是针对于类来说的，不是对象" class="headerlink" title="可见性是针对于类来说的，不是对象"></a>可见性是针对于类来说的，不是对象</h4><p>在类内可以直接访问private成员。</p>
<h4 id="内部类的私有成员可以在内部类的外面访问"><a href="#内部类的私有成员可以在内部类的外面访问" class="headerlink" title="内部类的私有成员可以在内部类的外面访问"></a>内部类的私有成员可以在内部类的外面访问</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        A.B xx = <span class="keyword">new</span> A().<span class="function">new <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello :: &quot;</span>+xx.x); <span class="comment">//This is allowed!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见：private这种修饰符并不能阻止外部类直接访问到内部类中的private属性；反之，内部类可以访问外部类private属性。</p>
<h3 id="受保护的访问修饰符-protected"><a href="#受保护的访问修饰符-protected" class="headerlink" title="受保护的访问修饰符-protected"></a>受保护的访问修饰符-protected</h3><p>protected 需要从以下两个点来分析说明：</p>
<ul>
<li><strong>子类与基类在同一包中</strong>：基类的 protected 成员是包内可见的，并且对子类可见，被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li>
<li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li>
</ul>
<p>protected 可以修饰数据成员，构造方法，方法成员，<strong>不能修饰类（内部类除外）</strong>。</p>
<p>接口及接口的成员变量和成员方法不能声明为 protected。</p>
<p>子类能访问 protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p>
<h3 id="protected关键字详解"><a href="#protected关键字详解" class="headerlink" title="protected关键字详解"></a>protected关键字详解</h3><blockquote>
<p>基类的 protected 成员是包内可见的，并且对子类可见</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;    <span class="comment">// 父类Father1中的protected方法</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father1</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> p11;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son11</span> <span class="keyword">extends</span> <span class="title">Father1</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son1 son1 = <span class="keyword">new</span> Son1();</span><br><span class="line">        son1.f(); <span class="comment">// Compile OK     ----（1）</span></span><br><span class="line">        son1.clone(); <span class="comment">// Compile Error     ----（2）</span></span><br><span class="line"> </span><br><span class="line">        Son11 son = <span class="keyword">new</span> Son11();    </span><br><span class="line">        son11.f(); <span class="comment">// Compile OK     ----（3）</span></span><br><span class="line">        son11.clone(); <span class="comment">// Compile Error     ----（4）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的示例，首先看(1)(3)，其中的f()方法从类Father1继承而来，其可见性是包p1及其子类Son1和Son11，而由于调用f()方法的类Test1所在的包也是p1，因此（1）(3)处编译通过。其次看(2)(4)，其中的clone()方法的可见性是java.lang包及其所有子类，对于语句”son1.clone();”和”son11.clone();”，二者的clone()在类Son1、Son11中是可见的，但对Test1是不可见的，因此（2）(4)处编译不通过。</p>
<blockquote>
<p>若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> p2;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> p22;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">MyObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       MyObject2 obj = <span class="keyword">new</span> MyObject2();</span><br><span class="line">       obj.clone(); <span class="comment">// Compile Error         ----（1）</span></span><br><span class="line"> </span><br><span class="line">       Test2 tobj = <span class="keyword">new</span> Test2();</span><br><span class="line">       tobj.clone(); <span class="comment">// Complie OK         ----（2）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于(1)而言，clone()方法来自于类MyObject2本身，因此其可见性为包p2及MyObject2的子类，虽然Test2是MyObject2的子类，但在Test2中不能访问基类MyObject2的protected方法clone()，因此编译不通过;对于(2)而言，由于在Test2中访问的是其本身实例的从基类MyObject2继承来的的clone()，因此编译通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> p3;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject3</span> <span class="keyword">extends</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> p33;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    MyObject3 obj = <span class="keyword">new</span> MyObject3();</span><br><span class="line">    obj.clone();   <span class="comment">// Compile OK     ------（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于(1)而言，clone()方法来自于Object，因此其可见性为包java.lang及其子类Test3，而（1）正是在类Test3中调用，编译通过。</p>
<p>更多例子：<a href="https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html">https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html</a></p>
<h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><p>请注意以下方法继承的规则：</p>
<ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被继承。</li>
</ul>
<h3 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h3><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p>
<h3 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h3><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p>
<p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>
<h3 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h3><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>一个 volatile 对象引用可能是 null。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p>
<p>下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">&quot;James&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> result = name <span class="keyword">instanceof</span> String; <span class="comment">// 由于 name 是 String 类型，所以返回真</span></span><br></pre></td></tr></table></figure>
<p>如果被比较的对象兼容于右侧类型,该运算符仍然返回true。</p>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="Java-增强-for-循环"><a href="#Java-增强-for-循环" class="headerlink" title="Java 增强 for 循环"></a>Java 增强 for 循环</h2><p><u>Java5</u> 引入了一种主要用于数组的增强型 for 循环。</p>
<p>Java 增强 for 循环语法格式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式) &#123;   </span><br><span class="line">  <span class="comment">//代码句子 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>声明语句：</strong>声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p>
<p><strong>表达式：</strong>表达式是要访问的数组名，或者是返回值为数组的方法。</p>
<h1 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h1><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>StringBuilder 类在 <u>Java 5</u> 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<h1 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h1><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按<u>升序</u>。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<h1 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h1><h2 id="使用printf格式化日期"><a href="#使用printf格式化日期" class="headerlink" title="使用printf格式化日期"></a>使用printf格式化日期</h2><p>printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 <strong>%t</strong> 开头并且以下面表格中的一个字母结尾。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">转 换 符</th>
<th style="text-align:left">说  明</th>
<th style="text-align:left">示  例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">包括全部日期和时间信息</td>
<td style="text-align:left">星期六 十月 27 14:21:20 CST 2007</td>
</tr>
<tr>
<td style="text-align:left">F</td>
<td style="text-align:left">“年-月-日”格式</td>
<td style="text-align:left">2007-10-27</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:left">“月/日/年”格式</td>
<td style="text-align:left">10/27/07</td>
</tr>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">“HH:MM:SS PM”格式（12时制）</td>
<td style="text-align:left">02:25:51 下午</td>
</tr>
<tr>
<td style="text-align:left">T</td>
<td style="text-align:left">“HH:MM:SS”格式（24时制）</td>
<td style="text-align:left">14:28:16</td>
</tr>
<tr>
<td style="text-align:left">R</td>
<td style="text-align:left">“HH:MM”格式（24时制）</td>
<td style="text-align:left">14:28</td>
</tr>
<tr>
<td style="text-align:left">B/b</td>
<td style="text-align:left">月份全称/简称</td>
<td style="text-align:left">March/Mar</td>
</tr>
<tr>
<td style="text-align:left">A/a</td>
<td style="text-align:left">星期全称/简称</td>
<td style="text-align:left">Thursday/Thu</td>
</tr>
<tr>
<td style="text-align:left">e</td>
<td style="text-align:left">月份的日（前面不补0）</td>
<td style="text-align:left">4</td>
</tr>
</tbody>
</table>
</div>
<h2 id="解析字符串为时间"><a href="#解析字符串为时间" class="headerlink" title="解析字符串为时间"></a>解析字符串为时间</h2><p>SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat ft = <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;yyyy-MM-dd&quot;</span>); </span><br><span class="line">t = ft.parse(input); </span><br></pre></td></tr></table></figure>
<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。</p>
<h3 id="创建一个代表系统当前日期的Calendar对象"><a href="#创建一个代表系统当前日期的Calendar对象" class="headerlink" title="创建一个代表系统当前日期的Calendar对象"></a>创建一个代表系统当前日期的Calendar对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();<span class="comment">//默认是当前日期</span></span><br></pre></td></tr></table></figure>
<h1 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h1><p><a href="https://www.runoob.com/java/java-regular-expressions.html">https://www.runoob.com/java/java-regular-expressions.html</a></p>
<h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>
<p>方法的可变参数的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">typeName... parameterName</span><br></pre></td></tr></table></figure>
<p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p>
<p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h2><p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p>
<p>例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。</p>
<p>在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p>
<p>finalize() 一般格式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">  <span class="comment">// 在这里终结代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。</p>
<p>当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。</p>
<h1 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h1><h2 id="从控制台读取输入"><a href="#从控制台读取输入" class="headerlink" title="从控制台读取输入"></a>从控制台读取输入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BufferedReader类</span></span><br><span class="line"><span class="comment">// 每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>) br.read();</span><br><span class="line"><span class="comment">// String readLine( ) throws IOException  读取一行</span></span><br></pre></td></tr></table></figure>
<p><em>JDK 5 后的版本我们也可以使用</em> <a href="https://www.runoob.com/java/java-scanner-class.html">Java Scanner</a> <em>类来获取控制台的输入。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>
<p>在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105940.png" alt="iostream2xx"></p>
<h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029105949.jpg" alt="exception"></p>
<p>java中的异常分为两大类，强制性异常(CheckedException)和非强制性异常(UncheckedException)。而java中除了RuntimeException外，都是强制性异常。 </p>
<p>强制性异常：所谓强制性异常就是在编写程序的过程中必需在抛出异常的部分try catch 或者向上throws异常。 </p>
<p>非强制性异常：所谓非强制性异常就和上面相反了。不过你当然也可以try catch或者thows，只不过这不是强制性的。 </p>
<h2 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h2><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p>
<p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p>
<p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>异常</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ArithmeticException</td>
<td style="text-align:left">当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td>
</tr>
<tr>
<td style="text-align:left">ArrayIndexOutOfBoundsException</td>
<td style="text-align:left">用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td>
</tr>
<tr>
<td style="text-align:left">ArrayStoreException</td>
<td style="text-align:left">试图将错误类型的对象存储到一个对象数组时抛出的异常。</td>
</tr>
<tr>
<td style="text-align:left">ClassCastException</td>
<td style="text-align:left">当试图将对象强制转换为不是实例的子类时，抛出该异常。</td>
</tr>
<tr>
<td style="text-align:left">IllegalArgumentException</td>
<td style="text-align:left">抛出的异常表明向方法传递了一个不合法或不正确的参数。</td>
</tr>
<tr>
<td style="text-align:left">IllegalMonitorStateException</td>
<td style="text-align:left">抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td>
</tr>
<tr>
<td style="text-align:left">IllegalStateException</td>
<td style="text-align:left">在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td>
</tr>
<tr>
<td style="text-align:left">IllegalThreadStateException</td>
<td style="text-align:left">线程没有处于请求操作所要求的适当状态时抛出的异常。</td>
</tr>
<tr>
<td style="text-align:left">IndexOutOfBoundsException</td>
<td style="text-align:left">指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td>
</tr>
<tr>
<td style="text-align:left">NegativeArraySizeException</td>
<td style="text-align:left">如果应用程序试图创建大小为负的数组，则抛出该异常。</td>
</tr>
<tr>
<td style="text-align:left">NullPointerException</td>
<td style="text-align:left">当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</td>
</tr>
<tr>
<td style="text-align:left">NumberFormatException</td>
<td style="text-align:left">当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td>
</tr>
<tr>
<td style="text-align:left">SecurityException</td>
<td style="text-align:left">由安全管理器抛出的异常，指示存在安全侵犯。</td>
</tr>
<tr>
<td style="text-align:left">StringIndexOutOfBoundsException</td>
<td style="text-align:left">此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小。</td>
</tr>
<tr>
<td style="text-align:left">UnsupportedOperationException</td>
<td style="text-align:left">当不支持请求的操作时，抛出该异常。</td>
</tr>
</tbody>
</table>
</div>
<p>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>异常</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ClassNotFoundException</td>
<td style="text-align:left">应用程序试图加载类时，找不到相应的类，抛出该异常。</td>
</tr>
<tr>
<td style="text-align:left">CloneNotSupportedException</td>
<td style="text-align:left">当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常。</td>
</tr>
<tr>
<td style="text-align:left">IllegalAccessException</td>
<td style="text-align:left">拒绝访问一个类的时候，抛出该异常。</td>
</tr>
<tr>
<td style="text-align:left">InstantiationException</td>
<td style="text-align:left">当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td>
</tr>
<tr>
<td style="text-align:left">InterruptedException</td>
<td style="text-align:left">一个线程被另一个线程中断，抛出该异常。</td>
</tr>
<tr>
<td style="text-align:left">NoSuchFieldException</td>
<td style="text-align:left">请求的变量不存在</td>
</tr>
<tr>
<td style="text-align:left">NoSuchMethodException</td>
<td style="text-align:left">请求的方法不存在</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><p>下面的列表是 Throwable 类的主要方法:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>序号</strong></th>
<th style="text-align:left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>public String getMessage()</strong> 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>public Throwable getCause()</strong> 返回一个Throwable 对象代表异常原因。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>public String toString()</strong> 使用getMessage()的结果返回类的串级名字。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>public void printStackTrace()</strong> 打印toString()结果和栈层次到System.err，即错误输出流。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>public StackTraceElement [] getStackTrace()</strong> 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>public Throwable fillInStackTrace()</strong> 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p>
<p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p>
<p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p>
<h2 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h2><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p>
<p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException,</span></span><br><span class="line"><span class="function">                              InsufficientFundsException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// Method implementation</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><p>finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>路线与基础</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/blog/5729df21.html</url>
    <content><![CDATA[<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><ol>
<li>New：尚未启动；<a id="more"></a></li>
<li>Runnable：可运行，等待cpu调度；</li>
<li>Blocked：阻塞，处于synchronized同步代码或方法中被阻塞；</li>
<li>Waiting：等待，Object.wait、Thread.join、LockSupport.park；</li>
<li>Timed Waiting：具有指定等待时间的等待线程，Thread.sleep、Object.wait、Thread.join、LockSupport.parkNanos、LockSupport.parkUntil；</li>
<li>Terminated：终止。</li>
</ol>
<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><ul>
<li>线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行</li>
<li>在 Thread 源码中和线程优先级相关的属性有 3 个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<ul>
<li>在程序中我们可以通过 Thread.setPriority() 来设置优先级</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    <span class="comment">// 检查当前线程是否有权限修改优先级</span></span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 先验证优先级的合理性</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程中止"><a href="#线程中止" class="headerlink" title="线程中止"></a>线程中止</h1><p>stop（弃用）：强制中止线程，并且清除监控器锁<code>monitor</code>的信息，因而可能造成这些对象处于不一致的状态，而且这个方法造成的 <code>ThreadDeath</code> 异常不像其他的检查期异常一样被捕获<br>interrupt：</p>
<ul>
<li>通知线程停止，而不是强制停止，线程可以进行停止前的释放资源, 完成必要的处理任务</li>
<li>在线程内可通过 <code>isInterrupted()</code> 判断终端并进行相应处理</li>
<li>若线程处于等待或堵塞状态, 则会抛出<code>InterruptedException</code></li>
</ul>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>Java 提供了三种创建线程的方法：</p>
<ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<h2 id="通过实现-Runnable-接口来创建线程"><a href="#通过实现-Runnable-接口来创建线程" class="headerlink" title="通过实现 Runnable 接口来创建线程"></a>通过实现 Runnable 接口来创建线程</h2><p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p>
<p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>你可以重写该方法，重要的是理解的 <code>run()</code>可以调用其他方法，使用其他类，并声明变量，就像主线程一样。</p>
<p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。</p>
<p>Thread 定义了几个构造方法，下面的这个是我们经常使用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread(Runnable threadOb,String threadName);</span><br></pre></td></tr></table></figure>
<p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p>
<p>新线程创建之后，你调用它的 start() 方法它才会运行。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Thread t;</span><br><span class="line">   <span class="keyword">private</span> String threadName;</span><br><span class="line">   </span><br><span class="line">   RunnableDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(<span class="string">&quot;Creating &quot;</span> +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Running &quot;</span> +  threadName );</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">            <span class="comment">// 让线程睡眠一会</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Thread &quot;</span> +  threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Thread &quot;</span> +  threadName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Starting &quot;</span> +  threadName );</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">         t = <span class="keyword">new</span> Thread (<span class="keyword">this</span>, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      RunnableDemo R1 = <span class="keyword">new</span> RunnableDemo( <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">      R1.start();</span><br><span class="line">      </span><br><span class="line">      RunnableDemo R2 = <span class="keyword">new</span> RunnableDemo( <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line">      R2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过继承Thread来创建线程"><a href="#通过继承Thread来创建线程" class="headerlink" title="通过继承Thread来创建线程"></a>通过继承Thread来创建线程</h2><p>创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p>
<p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p>
<p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p>
<h2 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h2><ul>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ul>
<h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
</ul>
<ul>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程，但是在多线程时受到局限。</li>
</ul>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>文件共享、网络共享、共享变量、JDK提供的线程协调API。</p>
<h2 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h2><h3 id="suspend-resume-弃用）"><a href="#suspend-resume-弃用）" class="headerlink" title="suspend,resume(弃用）"></a>suspend,resume(弃用）</h3><p>死锁示例：</p>
<ol>
<li>消费者和生产者使用同一把锁（同步）；suspend不会释放<code>monitor</code>；</li>
<li>生产者执行比消费者快；</li>
</ol>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><p>只能由同一对象锁的持有者线程调用，也就是卸载同步块里面，否则会抛出IllegalMonitorStateException异常。<br>wait：使线程进入等待队列，并且释放对象锁；<br>notify/notifyAll：唤醒。<br><strong>注意</strong>：虽然wait会自动解锁，但是对顺序有要求，要在notify之前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyCase</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread A is waiting to get lock&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;thread A get lock&quot;</span>);</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;thread A do wait method&quot;</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;wait end&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread B is waiting to get lock&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread B get lock&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread B do notify method&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thread A is waiting to get lock</span><br><span class="line">thread A get lock</span><br><span class="line">thread B is waiting to get lock</span><br><span class="line">thread A <span class="keyword">do</span> <span class="built_in">wait</span> method</span><br><span class="line">thread B get lock</span><br><span class="line">thread B <span class="keyword">do</span> notify method</span><br><span class="line"><span class="built_in">wait</span> end</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li><code>synchronized</code> 代码块通过 <code>javap</code> 生成的字节码中包含 <code>monitorenter</code> 和 <code>monitorexit</code>指令, 执行 <code>monitorenter</code> 指令可以获取对象的 <code>monitor</code> , 在 <code>wait()</code> 接口注释中有标明 <code>The current thread must own this object&#39;s monitor</code> , 所以通过 <code>synchronized</code> 该线程持有了对象的 <code>monitor</code> 的情况下才能调用对象的 <code>wait()</code>方法</li>
<li><code>wait()</code> 接口注释中还提到调用 <code>wait()</code> 后该线程会释放持有的 <code>monitor</code> 进入等待状态直到被唤醒, 被唤醒的线程还要等到能重新持有 <code>monitor</code> 才会继续执行</li>
<li>线程状态变化:<ol>
<li>调用 <code>wait()</code>: RUNNABLE -&gt; WAITING</li>
<li>调用 <code>notify()</code>: <ul>
<li>WAITING -&gt; BLOCKED -&gt; RUNNABLE</li>
<li>WAITING -&gt; RUNNABLE</li>
<li>具体看 JVM 实现和策略配置</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h4><p>在 <code>HotSpot</code> 虚拟机中 (1.7 版本)，<code>monitor</code> 采用 <code>ObjectMonitor</code> 实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header       = NULL;</span><br><span class="line">  _count        = <span class="number">0</span>;    <span class="comment">// 用来记录该线程获取锁的次数</span></span><br><span class="line">  _waiters      = <span class="number">0</span>,</span><br><span class="line">  _recursions   = <span class="number">0</span>;    <span class="comment">// 锁的重入次数</span></span><br><span class="line">  _object       = NULL; <span class="comment">// 对应的对象</span></span><br><span class="line">  _owner        = NULL;    <span class="comment">// 指向持有 ObjectMonitor 对象的线程</span></span><br><span class="line">  _WaitSet      = NULL; <span class="comment">// 处于 WAITING 状态的线程，会被加入到 _WaitSet</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = NULL ;</span><br><span class="line">  _succ         = NULL ;</span><br><span class="line">  _cxq          = NULL ; <span class="comment">// 竞争锁的线程都会先通过互斥同步或 CAS 操作进入 cxq，队首的对象会进入到 EntryList 中，进行 tryLock 操作</span></span><br><span class="line">  FreeNext      = NULL ;</span><br><span class="line">  _EntryList    = NULL ; <span class="comment">// 处于 BLOCKED 状态的线程，会被加入到 _EntryList</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个线程都有两个 <code>ObjectMonitor</code> 对象列表，分别为 <code>free</code> 和 <code>used</code>列表，如果当前 <code>free</code>列表为空，线程将向全局 <code>global ListLock</code> 请求分配 <code>ObjectMonitor</code></li>
<li><code>ObjectMonitor</code> 对象中有两个队列：<code>_WaitSet</code> 和 <code>_EntryList</code>，用来保存 <code>ObjectWaiter</code> 对象列表；<code>_owner</code> 指向获得 <code>ObjectMonitor</code>对象的线程<br><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110105.png" alt="objectMonitor"></li>
<li>每个等待锁的线程都会被封装成 <code>ObjectWaiter</code> 对象<ul>
<li>ObjectWaiter 对象是双向链表结构，保存了_thread（当前线程）以及当前的状态 TState等数据<br><img src="http://image-jennerblog.test.upcdn.net/img/objectWaiter.png" alt="objectWaiter"></li>
</ul>
</li>
<li><code>ObjectMonitor</code> 获得锁是通过 <code>void ATTR enter(TRAPS)</code> 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ATTR ObjectMonitor::enter(TRAPS) &#123;</span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">  <span class="keyword">void</span> * cur ;</span><br><span class="line">  <span class="comment">// 通过 CAS 尝试把 monitor 的 _owner 设置为当前线程</span></span><br><span class="line">  cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ;</span><br><span class="line">  <span class="comment">// 获取锁失败</span></span><br><span class="line">  <span class="keyword">if</span> (cur == NULL) &#123;         </span><br><span class="line">     <span class="keyword">assert</span> (_recursions == <span class="number">0</span>   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">assert</span> (_owner      == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions 自增即可</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123; </span><br><span class="line">     <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span><br><span class="line">     _recursions ++ ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前线程是第一次进入该 monitor，设置 _recursions 为 1，_owner 为当前线程</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123; </span><br><span class="line">    <span class="keyword">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// Commute owner from a thread-specific on-stack BasicLockObject address to</span></span><br><span class="line">    <span class="comment">// a full-fledged &quot;Thread *&quot;.</span></span><br><span class="line">    _owner = Self ;</span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过自旋执行 ObjectMonitor::EnterI 方法等待锁的释放</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    jt-&gt;set_suspend_equivalent();</span><br><span class="line">    <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span><br><span class="line">    <span class="comment">// or java_suspend_self()</span></span><br><span class="line"></span><br><span class="line">    EnterI (THREAD) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ExitSuspendEquivalent(jt)) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We have acquired the contended monitor, but while we were</span></span><br><span class="line">    <span class="comment">// waiting another thread suspended us. We don&#x27;t want to enter</span></span><br><span class="line">    <span class="comment">// the monitor while suspended because that would surprise the</span></span><br><span class="line">    <span class="comment">// thread that suspended us.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _recursions = <span class="number">0</span> ;</span><br><span class="line">    _succ = NULL ;</span><br><span class="line">    exit (Self) ;</span><br><span class="line"></span><br><span class="line">    jt-&gt;java_suspend_self();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110112.png" alt="lockenter"></p>
<ul>
<li><code>ObjectMonitor</code> 释放锁是通过 <code>void ATTR exit(TRAPS)</code> 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ATTR ObjectMonitor::exit(TRAPS) &#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line">   <span class="comment">// 如果当前线程不是 Monitor 的所有者</span></span><br><span class="line">   <span class="keyword">if</span> (THREAD != _owner) &#123; </span><br><span class="line">     <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) _owner)) &#123;</span><br><span class="line">       <span class="comment">// Transmute _owner from a BasicLock pointer to a Thread address.</span></span><br><span class="line">       <span class="comment">// We don&#x27;t need to hold _mutex for this transition.</span></span><br><span class="line">       <span class="comment">// Non-null to Non-null is safe as long as all readers can</span></span><br><span class="line">       <span class="comment">// tolerate either flavor.</span></span><br><span class="line">       <span class="keyword">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">       _owner = THREAD ;</span><br><span class="line">       _recursions = <span class="number">0</span> ;</span><br><span class="line">       OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// <span class="doctag">NOTE:</span> we need to handle unbalanced monitor enter/exit</span></span><br><span class="line">       <span class="comment">// in native code by throwing an exception.</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Throw an IllegalMonitorStateException ?</span></span><br><span class="line">       TEVENT (Exit - Throw IMSX) ;</span><br><span class="line">       <span class="keyword">assert</span>(<span class="keyword">false</span>, <span class="string">&quot;Non-balanced monitor enter/exit!&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">          THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 如果 _recursions 次数不为 0.自减</span></span><br><span class="line">   <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">     _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">     TEVENT (Inflated exit - recursive) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略部分代码，根据不同的策略（由 QMode 指定），从 cxq 或 EntryList 中获取头节点，通过ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作最终由 unpark 完成。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110121.png" alt="lockexit"></p>
<ul>
<li><code>lock.wait()</code> 方法最终通过 <code>ObjectMonitor</code> 的 <code>void wait(jlong millis, bool interruptable, TRAPS)</code> 实现:<ol>
<li>将当前线程封装成 <code>ObjectWaiter</code> 对象 node</li>
<li>通过 <code>ObjectMonitor::AddWaiter</code> 方法将 node 添加到 <code>_WaitSet</code> 列表中</li>
<li>通过 <code>ObjectMonitor::exit</code> 方法释放当前的 <code>ObjectMonitor</code> 对象，这样其它竞争线程就可以获取该 <code>ObjectMonitor</code> 对象</li>
<li>最终底层的 <code>park</code>方法会挂起线程</li>
</ol>
</li>
<li><code>lock.notify()</code> 方法最终通过 <code>ObjectMonitor</code> 的 <code>void notify(TRAPS)</code> 实现:<ol>
<li>如果当前 <code>_WaitSet</code> 为空，即没有正在等待的线程，则直接返回</li>
<li>通过 <code>ObjectMonitor::DequeueWaiter</code> 方法，获取 <code>_WaitSet</code> 列表中的第一个 <code>ObjectWaiter</code>节点</li>
<li>根据不同的策略，将取出来的 <code>ObjectWaiter</code> 节点加入到 <code>_EntryList</code> 或则通过<code>Atomic::cmpxchg_ptr</code> 指令进行自旋操作<code>_cxq</code></li>
</ol>
</li>
</ul>
<h3 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park/unpark"></a>park/unpark</h3><p>park：线程等待“许可”；<br>unpark：为指定线程提供“许可”。<br>不要求调用顺序。<br>多次调用unpark之后，再调用park，线程会直接运行，但不会叠加。<br><strong>注意</strong>：同样有同步锁问题。</p>
<h3 id="伪唤醒"><a href="#伪唤醒" class="headerlink" title="伪唤醒"></a>伪唤醒</h3><p>为防止伪唤醒，需要用while循环来检查等待条件。</p>
<h1 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h1><h2 id="非静态方法"><a href="#非静态方法" class="headerlink" title="非静态方法"></a>非静态方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>序号</strong></th>
<th style="text-align:center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:center"><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:center"><strong>public void interrupt()</strong> 中断线程。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:center"><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>序号</strong></th>
<th style="text-align:center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。让线程进入到 TIMED_WAITING 状态，并停止占用 CPU 资源，但是不释放持有的 monitor ，直到规定事件后再执行，休眠期间如果被中断，会抛出异常并清除中断状态。<code>TimeUnit.SECONDS.sleep()</code> 比 <code>Thread.sleep()</code>多了非负数判断</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a>start与run</h3><ul>
<li><code>start()</code> 方法属于 <code>Thread</code> 自身的方法，并且使用了<code>synchronized</code> 来保证线程安全</li>
<li><code>run()</code> 方法为 <code>Runnable</code> 的抽象方法，重写的 <code>run()</code> 方法其实就是此线程要执行的业务方法</li>
<li>调用 <code>start()</code> 方法是另起线程来运行 <code>run()</code> 方法中的内容</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">      <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      wait(delay);</span><br><span class="line">      now = System.currentTimeMillis() - base;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>本质是用<code>wait()</code>实现</li>
<li>JVM 的 Thread 执行完毕会自动执行一次<code>notifyAll()</code></li>
<li>所以不建议在程序中对 Thread 对象调用 wait/notify, 可能会造成干扰</li>
</ul>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ol>
<li>状态依旧是 RUNNABLE, 不保证释放 CPU 资源。<code>yield</code>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。</li>
<li><code>Thread.sleep(0)</code>可以重新触发 CPU 的竞争, 而<code>yield</code>不一定</li>
</ol>
<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>数据被封闭在各自线程中，避免被同步。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>线程级别变量，在每个线程都有独立的副本。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>局部变量固有属性，存储在执行线程的栈中。</p>
<h1 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h1><h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><p>L1 Cache，L2 CPU外部放置高速存储器，L3 多核共享的内置缓存。CPU读取数据，L1-&gt;L2-&gt;L3-&gt;内存-&gt;外存储器。</p>
<h2 id="缓存同步协议"><a href="#缓存同步协议" class="headerlink" title="缓存同步协议"></a>缓存同步协议</h2><p>MESI协议，对每条缓存有状态位：</p>
<ol>
<li>修改态；</li>
<li>专有态；</li>
<li>共享态；</li>
<li>无效态。</li>
</ol>
<h2 id="CPU性能优化"><a href="#CPU性能优化" class="headerlink" title="CPU性能优化"></a>CPU性能优化</h2><p>运行时指令重排，可能将读缓存命令优先执行，因为写缓存时可能区块正被其他CPU占用。</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>写内存屏障：在指令后插入Store Barrier，能让写入缓存中的最新数据更新到主内存，让其他线程可见，CPU就不会因为性能考虑而去对指令重排。<br>读内存屏障：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h2><p>描述线程之间如何通过内存(memory)来进行交互，描述了java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。<br>具体说来，JVM中存在一个主存区（Main Memory或Java Heap Memory），对于所有线程进行共享，但线程不能直接操作主内存中的变量，每个线程都有自己独立的工作内存（Working Memory），里面保存该线程使用到的变量的副本（ 主内存中该变量的一份拷贝）<br>规定：线程对共享变量的读写都必须在自己的工作内存中进行，而不能直接在主内存中读写。不同线程不能直接访问其他线程的工作内存中的变量，线程间变量值的传递需要主内存作为桥梁。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><strong>可见性：</strong> 一个线程对共享变量值的修改，能够及时的被其他线程看到<br><strong>线程可见性原理：</strong><br>线程一对共享变量的改变想要被线程二看见，就必须执行下面两个步骤：<br>①将工作内存1中的共享变量的改变更新到主内存中<br>②将主内存中最新的共享变量的变化更新到工作内存2中。<br><strong>指令重排序：</strong> 代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化。<br>1.编译器优化的重排序（编译器优化）<br>2.指令级并行重排序（处理器优化）<br>3.内存系统的重排序（处理器优化）<br>指令重排序在多线程中会造成可见性问题。<br>导致共享变量在线程间不可见的原因：</p>
<ol>
<li>线程的交叉执行</li>
<li>重排序结合线程交叉执行</li>
<li>共享变量更新后的值没有在工作内存与主内存间及时更新</li>
</ol>
<p>查看重排序：</p>
<blockquote>
<p>class-&gt;jit运行时编译-&gt;汇编指令-&gt;指令重排序<br>通过设置JVM参数，打印出jit编译的内容：<br><code>-server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log</code><br>汇编指令可以通过<code>jitwatch</code>查看。</p>
</blockquote>
<p>保证可见性，需要满足happens-before关系：</p>
<blockquote>
<p>1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；<br>2.锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；<br>3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；<br>4.传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；<br>5.线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；<br>6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；<br>7.线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；<br>8.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</p>
</blockquote>
<p>根据上面的happens-before规则，显然，一般只需要使用volatile关键字，或者使用锁的机制，就能实现内存的可见性了。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>JMM规定synchronized在线程解锁前，把共享变量的最新值刷新到主存，加锁时，清空工作内存（缓存）中共享变量的值，从主存重新读取。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile变量每次被线程访问时，都强迫从主内存中读取该变量的值，而当变量发生变化的时候都会强迫线程将最新的值刷新到主内存中。<br>深入来说：通过加入内存屏障和禁止重排序优化来实现的。</p>
<ul>
<li>对volatile变量执行写操作时，会在写操作后加入一条store屏障指令<ul>
<li>store指令会在写操作后把最新的值强制刷新到主内存中。同时还会禁止cpu对代码进行重排序优化。这样就保证了值在主内存中是最新的。</li>
</ul>
</li>
<li>对volatile变量执行读操作时，会在读操作前加入一条load屏障指令<ul>
<li>load指令会在读操作前把内存缓存中的值清空后，再从主内存中读取最新的值。<br><strong>注意</strong>：volatile实现可见性有一个条件，就是对共享变量的操作必须具有原子性。例如num++这些复合操作是3步组成，不符合原子性。</li>
</ul>
</li>
</ul>
<h3 id="synchronized和volatile的比较"><a href="#synchronized和volatile的比较" class="headerlink" title="synchronized和volatile的比较"></a>synchronized和volatile的比较</h3><ul>
<li>synchronized锁住的是变量和变量的操作，而volatile锁住的只是变量，而且该变量的值不能依赖它本身的值，volatile算是一种轻量级的同步锁</li>
<li>volatile不需要加锁，比synchronized更加轻量级，不会阻塞线程。</li>
<li>从内存可见性角度讲，volatile读相当于加锁，volatilexie相当于解锁。</li>
<li>synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</li>
</ul>
<p>注：由于voaltile比synchronized更加轻量级，所以执行的效率肯定是比synchroized更高。在可以保证原子性操作时，可以尽量的选择使用volatile。在其他不能保证其操作的原子性时，再去考虑使用synchronized。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>重排序会影响有序性。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>JDK 5之前使用synchronized保证同步，JDK 5新增了Atomic包。例如，AtomicInteger代替int，getAndIncrement()以及getAndDecrement()实现原子操作的加减。<br>锁机制存在以下问题：<br>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。<br>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。<br>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。<br>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>悲观锁（Pessimistic Lock）：<br>每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。<br>乐观锁（Optimistic Lock）：<br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。利用CAS。<br>自旋锁：为了不放弃CPU执行事件，循环地使用CAS技术对数据尝试进行更新，直至成功。</p>
<blockquote>
<p>CAS算法 即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</p>
</blockquote>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<h3 id="synchronized-关键字-监视器锁monitor-lock"><a href="#synchronized-关键字-监视器锁monitor-lock" class="headerlink" title="synchronized 关键字-监视器锁monitor lock"></a>synchronized 关键字-监视器锁monitor lock</h3><p>synchronized的底层是使用操作系统的mutex lock实现的。<br>synchronized 关键字的使用<br>1、同步代码块<br>1)可以定义一个常量作为锁对象<br>2)只要是同一个锁对象，同步代码块可以在不同的方法体中也能同步<br>2、同步实例方法<br>直接使用synchronized修饰实例方法<br>把整个方法体作为同步代码块，默认的锁对象就是this对象<br>3、同步静态方法<br>就是使用synchronized修饰静态方法<br>把整个方法体作为同步代码块，默认的锁对象是——当前类的运行时类对象，简单的理解为把当前类的字节码文件作为锁</p>
<p>synchronized用的锁是存在Java对象里的<br>锁的是SynchronizedDemo 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo demo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">        demo.methond(); <span class="comment">// 进入方法会锁 demo 指向对象中的锁；出方法会释放 demo 指向的对象中的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谁调用的这个方法锁的就是哪个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进入代码块会锁 this 指向对象中的锁；</span></span><br><span class="line">        <span class="comment">// 出代码块会释放 this 指向的对象中的锁         </span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo demo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">        demo.methond();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>平行链系统架构</title>
    <url>/blog/8e017055.html</url>
    <content><![CDATA[<p>这篇文章基于Polkadot的6be14014提交（2020/12），目的是介绍Polkadot在平行链角度上的系统架构。<br><a id="more"></a></p>
<h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p><img src="https://wiki.polkadot.network/docs/assets/network/one_parachain.png" alt="架构图"></p>
<h2 id="链"><a href="#链" class="headerlink" title="链"></a>链</h2><ul>
<li>Relay chain：中继链，负责平台安全性。</li>
<li>Parachain：平行链，拥有自己独立的状态与业务逻辑，共享中继链提供的安全性。<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2></li>
<li>validator：验证人，负责中继链的出块，同时验证来自收集者的证明，与其他验证人进行共识投票。中继链全节点，需要抵押DOT。</li>
<li>collator：收集者，为验证人收集平行链的交易和状态转移证明（collation）。平行链全节点，同时内嵌中继链全节点服务，不一定需要抵押DOT，可以由平行链自行激励。注意，平行线程的 collator 需要持有DOT，以便参与出块资格的拍卖。</li>
<li>fishermen：渔民，监控验证人和收集者，检查无效的候选收据。collator 或者 validator 都可以作为 fishermen，需要抵押DOT。</li>
</ul>
<h1 id="平行链节点结构"><a href="#平行链节点结构" class="headerlink" title="平行链节点结构"></a>平行链节点结构</h1><p>平行链节点主要有以下两点变动。</p>
<h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><p>collator 在平行链上的角色类似于以往的独立链上的 validator。<br>但是 collator 只提供候选区块，然后交由中继链上的 validator 进行共识。所以，平行链不再需要自己的共识机制。当然，可以保留对 collator 的选择机制。</p>
<h2 id="双服务"><a href="#双服务" class="headerlink" title="双服务"></a>双服务</h2><p>平行链节点与以往单链节点的不同在于：需要启动一个中继链全节点服务。<br>内嵌的中继链全节点服务中，包含了 overseer （关于 overseer 在“中继链节点结构”部分介绍）与子系统服务，并且将 overseer_handle 共享给 collator，在<code>collator_protocol</code>上注册为 <code>collator_side</code>。因此，collator 能与 validator 通过 overseer 进行消息交互，例如传递候选区块相关消息。<br>另外，平行链全节点还需要通过内嵌的中继链节点来“跟随”中继链的出块。所谓“跟随”，指的是平行链全节点的最佳区块为中继链上最佳区块包含的相应平行链区块，终结区块亦如此。</p>
<h1 id="中继链节点结构"><a href="#中继链节点结构" class="headerlink" title="中继链节点结构"></a>中继链节点结构</h1><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201216170820.png" alt="relay_chain"></p>
<p>中继链上除了必须的基础组件外，比较重要的就是<code>overseer</code>与子系统。</p>
<h2 id="overseer"><a href="#overseer" class="headerlink" title="overseer"></a>overseer</h2><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201106103000.png" alt="overseer"></p>
<p>Overseer 主要有以下功能：</p>
<ul>
<li>启动和关闭一系列子系统；</li>
<li>作为子系统之间的消息总线，避免消息争用；</li>
<li>监听外部事件，触发子系统相应任务。</li>
</ul>
<h3 id="消息协议"><a href="#消息协议" class="headerlink" title="消息协议"></a>消息协议</h3><p>overseer 向子系统发送两种类型的消息：<code>Communication</code>, <code>Signal</code>。</p>
<ul>
<li><code>Communication</code>：子系统之间交互的消息被封装在<code>Communication</code>类型中，根据被封装的消息类型传递到指定的子系统。例如子系统A向子系统B发送一个消息M：1. A向overseer发送<code>AllMessages::B&#123;M&#125;</code>；2. overseer收到后，向B发送<code>FromOverseer::Communication&#123;M&#125;</code>。</li>
<li><code>Signal</code>：系统消息，例如块导入、块终结、关闭子系统，被封装在<code>Signal</code>中。系统消息会被广播到所有子系统。</li>
</ul>
<h2 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h2><p>目前设计上共有18个子系统。</p>
<h3 id="Collator相关"><a href="#Collator相关" class="headerlink" title="Collator相关"></a>Collator相关</h3><ul>
<li><strong>collation_generation_subsystem</strong>：collator在块更新时生成collation</li>
<li>collator_protocol_subsystem：collation的请求与回应，根据validator/collator的角色执行对应的任务</li>
</ul>
<h3 id="候选区块共识"><a href="#候选区块共识" class="headerlink" title="候选区块共识"></a>候选区块共识</h3><ul>
<li><strong>candidate_selection_subsystem</strong>：触发对collation的请求，收到collation后请求投票</li>
<li><strong>candidate_backing_subsystem</strong>：对collation投票，签署<code>statement</code></li>
<li>statement_distribution_subsystem：广播<code>statement</code></li>
<li>pov_distribution_subsystem：广播<code>PoV</code></li>
<li>apporoval_subsystems：在finalize前对候选区块的再次检查</li>
</ul>
<h3 id="可用性相关"><a href="#可用性相关" class="headerlink" title="可用性相关"></a>可用性相关</h3><ul>
<li>availability_distribution_subsystem</li>
<li>bitfield_signing_subsystem</li>
<li>bitfield_distribution_subsystem</li>
<li>availability_recovery</li>
</ul>
<h3 id="工具类子系统"><a href="#工具类子系统" class="headerlink" title="工具类子系统"></a>工具类子系统</h3><ul>
<li>candidate_validation_subsystem：验证候选区块</li>
<li><strong>provisioner_subsystem</strong>：提供平行链相关的出块打包数据</li>
<li>runtime_api_subsystem：调用runtime api</li>
<li>availability_store_subsystem：存储可用性数据</li>
<li>network_bridge_subsystem：与collation相关数据在节点间传递的网桥协议</li>
<li>chain_api_subsystem</li>
<li>misbehavior_arbitration</li>
</ul>
<h1 id="Collator"><a href="#Collator" class="headerlink" title="Collator"></a>Collator</h1><p>以平行链上的Collator为例，介绍节点如何与子系统协作。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul>
<li>平行链启动时，<code>build_polkadot_full_node</code>启动一个中继链全节点，包含overseer和子系统，并且在 collator_protocol_subsystem 注册为<code>collator_side</code>。如果要以collator的身份启动节点，启动时需要设定<code>--collator</code>，类似于以往独立链设定<code>--validator</code>启动验证人节点。中继链全节点持有平行链的<code>client</code>，即平行链嵌套在中继链全节点中运行。<ul>
<li><code>start_collator</code>：<code>polkadot_full_node.client.execute_with(StartCollator&#125;</code>，collator和polkadot_full_node共享一个<code>overseer_handler</code>。<ul>
<li><code>cumulus_consensus::run_parachain_consensus</code>：根据中继链的出块来更新平行链<ul>
<li><code>follow_new_best</code>：1. 中继链监听到中继链的best区块包含新的平行链区块后，<code>handle_new_best_parachain_head</code>：如果collator已经导入了该区块，就把它当做best并且广播给平行链节点。如果还没有导入，存到<code>unset_best_header</code>中；2. collator导入区块时，优先导入<code>unset_best_header</code>。</li>
<li><code>follow_finalized_head</code>：中继链监听到中继链的finalize区块包含新的平行链区块后，collator进行<code>finalize_block</code>。</li>
</ul>
</li>
<li>初始化<strong>collation_generation_subsystem</strong>，在此时注册<code>collator.produce_candidate</code>方法，用来生成<code>collation</code>，同时注册para_id，collatorId（公钥）。</li>
<li>在 collator_protocol_subsystem 上注册 Collator 所在的para_id，在<code>advertise_collation</code>需要用到该id。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="准备候选区块"><a href="#准备候选区块" class="headerlink" title="准备候选区块"></a>准备候选区块</h2><ul>
<li><strong>collation_generation_subsystem</strong> 启动后会循环<code>handle_incoming</code>。接受到<code>Signal(ActiveLeaves(ActiveLeavesUpdate&#123;..&#125;)</code>后触发<code>handle_new_activations</code>。<ul>
<li>获取availability_cores：core的数量为max(n_parachains + config.parathread_cores, validators.len() / config.max_validators_per_core)，第i个parachain分配第i个core。调用<code>request_availability_cores_ctx</code> -&gt; <code>runtime_api_impl/v1::availability_cores</code> 得到CoreState。</li>
<li>仅匹配CoreState::Scheduled；</li>
<li>检查scheduled_core.para_id；</li>
<li><code>request_full_validation_data_ctx</code> 会触发中继链调用runtime api获取<code>ValidationData</code>，实际调用<code>make_persisted_validation_data</code>构造辅助验证的数据，最终被打包进平行链的<code>SystemInherentData</code>。这时的<code>ValidationData</code>是平行链父区块所对应的；</li>
<li><code>task_config.collator</code> -&gt; <code>produce_candidate</code><ul>
<li>500ms内<code>propose</code>一个候选区块；</li>
<li><code>build_collation</code>：构建候选区块的<code>Collation</code>；</li>
<li>开启<code>wait_to_announce</code>任务，注册成为<code>StatementListener</code>。当收到validator发来的<code>Statement::Seconded</code>就广播当前候选区块。</li>
</ul>
</li>
<li><code>collator_signature_payload</code>签名，payload包括：relay_parent，para_id，persisted_validation_data_hash，pov_hash；</li>
<li><code>erasure_root</code>：将<code>available_data</code>分成chunks，组合成 merkle trie，erasure_root为树根哈希。</li>
<li>生成<code>CandidateReceipt</code>，发送<code>CollatorProtocolMessage::DistributeCollation(CandidateReceipt, PoV)</code>给 collator_protocol_subsystem。</li>
</ul>
</li>
</ul>
<h3 id="schedule-core"><a href="#schedule-core" class="headerlink" title="schedule_core"></a>schedule_core</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AvailabilityCores</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">CoreOccupied</span></span> &#123;</span><br><span class="line">	<span class="comment">/// A parathread.</span></span><br><span class="line">	Parathread(ParathreadEntry),</span><br><span class="line">	<span class="comment">/// A parachain.</span></span><br><span class="line">	Parachain,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheduled</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">AssignmentKind</span></span> &#123;</span><br><span class="line">	<span class="comment">/// A parachain.</span></span><br><span class="line">	Parachain,</span><br><span class="line">	<span class="comment">/// A parathread.</span></span><br><span class="line">	Parathread(CollatorId, <span class="built_in">u32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CoreAssignment</span></span> &#123;</span><br><span class="line">	<span class="comment">/// The core that is assigned.</span></span><br><span class="line">	<span class="keyword">pub</span> core: CoreIndex,</span><br><span class="line">	<span class="comment">/// The unique ID of the para that is assigned to the core.</span></span><br><span class="line">	<span class="keyword">pub</span> para_id: ParaId,</span><br><span class="line">	<span class="comment">/// The kind of the assignment.</span></span><br><span class="line">	<span class="keyword">pub</span> kind: AssignmentKind,</span><br><span class="line">	<span class="comment">/// The index of the validator group assigned to the core.</span></span><br><span class="line">	<span class="keyword">pub</span> group_idx: GroupIndex,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="request-availability-cores"><a href="#request-availability-cores" class="headerlink" title="request_availability_cores"></a>request_availability_cores</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OccupiedCore</span></span>&lt;H = Hash, N = BlockNumber&gt; &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> this has no ParaId as it can be deduced from the candidate descriptor.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/// If this core is freed by availability, this is the assignment that is next up on this</span></span><br><span class="line">	<span class="comment">/// core, if any. None if there is nothing queued for this core.</span></span><br><span class="line">	<span class="keyword">pub</span> next_up_on_available: <span class="built_in">Option</span>&lt;ScheduledCore&gt;,</span><br><span class="line">	<span class="comment">/// The relay-chain block number this began occupying the core at.</span></span><br><span class="line">	<span class="keyword">pub</span> occupied_since: N,</span><br><span class="line">	<span class="comment">/// The relay-chain block this will time-out at, if any.</span></span><br><span class="line">	<span class="keyword">pub</span> time_out_at: N,</span><br><span class="line">	<span class="comment">/// If this core is freed by being timed-out, this is the assignment that is next up on this</span></span><br><span class="line">	<span class="comment">/// core. None if there is nothing queued for this core or there is no possibility of timing</span></span><br><span class="line">	<span class="comment">/// out.</span></span><br><span class="line">	<span class="keyword">pub</span> next_up_on_time_out: <span class="built_in">Option</span>&lt;ScheduledCore&gt;,</span><br><span class="line">	<span class="comment">/// A bitfield with 1 bit for each validator in the set. `1` bits mean that the corresponding</span></span><br><span class="line">	<span class="comment">/// validators has attested to availability on-chain. A 2/3+ majority of `1` bits means that</span></span><br><span class="line">	<span class="comment">/// this will be available.</span></span><br><span class="line">	<span class="meta">#[cfg_attr(feature = <span class="meta-string">&quot;std&quot;</span>, ignore_malloc_size_of = <span class="meta-string">&quot;outside type&quot;</span>)]</span></span><br><span class="line">	<span class="keyword">pub</span> availability: BitVec&lt;bitvec::order::Lsb0, <span class="built_in">u8</span>&gt;,</span><br><span class="line">	<span class="comment">/// The group assigned to distribute availability pieces of this candidate.</span></span><br><span class="line">	<span class="keyword">pub</span> group_responsible: GroupIndex,</span><br><span class="line">	<span class="comment">/// The hash of the candidate occupying the core.</span></span><br><span class="line">	<span class="keyword">pub</span> candidate_hash: CandidateHash,</span><br><span class="line">	<span class="comment">/// The descriptor of the candidate occupying the core.</span></span><br><span class="line">	<span class="keyword">pub</span> candidate_descriptor: CandidateDescriptor&lt;H&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ScheduledCore</span></span> &#123;</span><br><span class="line">	<span class="comment">/// The ID of a para scheduled.</span></span><br><span class="line">	<span class="keyword">pub</span> para_id: Id,</span><br><span class="line">	<span class="comment">/// The collator required to author the block, if any.</span></span><br><span class="line">	<span class="keyword">pub</span> collator: <span class="built_in">Option</span>&lt;CollatorId&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">CoreState</span></span>&lt;H = Hash, N = BlockNumber&gt; &#123;</span><br><span class="line">	<span class="comment">/// The core is currently occupied.</span></span><br><span class="line">	Occupied(OccupiedCore&lt;H, N&gt;),</span><br><span class="line">	<span class="comment">/// The core is currently free, with a para scheduled and given the opportunity</span></span><br><span class="line">	<span class="comment">/// to occupy.</span></span><br><span class="line">	<span class="comment">/// If a particular Collator is required to author this block, that is also present in this</span></span><br><span class="line">	<span class="comment">/// variant.</span></span><br><span class="line">	Scheduled(ScheduledCore),</span><br><span class="line">	<span class="comment">/// The core is currently free and there is nothing scheduled. This can be the case for parathread</span></span><br><span class="line">	<span class="comment">/// cores when there are no parathread blocks queued. Parachain cores will never be left idle.</span></span><br><span class="line">	Free,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PersistedValidationData"><a href="#PersistedValidationData" class="headerlink" title="PersistedValidationData"></a>PersistedValidationData</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PersistedValidationData</span></span>&lt;N = BlockNumber&gt; &#123;</span><br><span class="line">	<span class="comment">/// The parent head-data.</span></span><br><span class="line">	<span class="keyword">pub</span> parent_head: HeadData,</span><br><span class="line">	<span class="comment">/// The relay-chain block number this is in the context of.</span></span><br><span class="line">	<span class="keyword">pub</span> block_number: N,</span><br><span class="line">	<span class="comment">/// The relay-chain block storage root this is in the context of.</span></span><br><span class="line">	<span class="keyword">pub</span> relay_storage_root: Hash,</span><br><span class="line">	<span class="comment">/// The list of MQC heads for the inbound channels paired with the sender para ids. This</span></span><br><span class="line">	<span class="comment">/// vector is sorted ascending by the para id and doesn&#x27;t contain multiple entries with the same</span></span><br><span class="line">	<span class="comment">/// sender.</span></span><br><span class="line">	<span class="keyword">pub</span> hrmp_mqc_heads: <span class="built_in">Vec</span>&lt;(Id, Hash)&gt;,</span><br><span class="line">	<span class="comment">/// The MQC head for the DMQ.</span></span><br><span class="line">	<span class="comment">///</span></span><br><span class="line">	<span class="comment">/// The DMQ MQC head will be used by the validation function to authorize the downward messages</span></span><br><span class="line">	<span class="comment">/// passed by the collator.</span></span><br><span class="line">	<span class="keyword">pub</span> dmq_mqc_head: Hash,</span><br><span class="line">	<span class="comment">/// The maximum legal size of a POV block, in bytes.</span></span><br><span class="line">	<span class="keyword">pub</span> max_pov_size: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平行链的SystemInherentData"><a href="#平行链的SystemInherentData" class="headerlink" title="平行链的SystemInherentData"></a>平行链的SystemInherentData</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/// The payload that system inherent carries.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SystemInherentData</span></span> &#123;</span><br><span class="line">	<span class="keyword">pub</span> validation_data: crate::PersistedValidationData,</span><br><span class="line">	<span class="comment">/// A storage proof of a predefined set of keys from the relay-chain.</span></span><br><span class="line">	<span class="comment">///</span></span><br><span class="line">	<span class="comment">/// Specifically this witness contains the data for:</span></span><br><span class="line">	<span class="comment">///</span></span><br><span class="line">	<span class="comment">/// - active host configuration as per the relay parent,</span></span><br><span class="line">	<span class="comment">/// - the relay dispatch queue sizes</span></span><br><span class="line">	<span class="comment">/// - the list of egress HRMP channels (in the list of recipients form)</span></span><br><span class="line">	<span class="comment">/// - the metadata for the egress HRMP channels</span></span><br><span class="line">	<span class="keyword">pub</span> relay_chain_state: sp_trie::StorageProof,</span><br><span class="line">	<span class="comment">/// Downward messages in the order they were sent.</span></span><br><span class="line">	<span class="keyword">pub</span> downward_messages: <span class="built_in">Vec</span>&lt;InboundDownwardMessage&gt;,</span><br><span class="line">	<span class="comment">/// HRMP messages grouped by channels. The messages in the inner vec must be in order they</span></span><br><span class="line">	<span class="comment">/// were sent. In combination with the rule of no more than one message in a channel per block,</span></span><br><span class="line">	<span class="comment">/// this means `sent_at` is **strictly** greater than the previous one (if any).</span></span><br><span class="line">	<span class="keyword">pub</span> horizontal_messages: BTreeMap&lt;ParaId, <span class="built_in">Vec</span>&lt;InboundHrmpMessage&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对SystemInherentData创建的Inherent交易为<code>set_validation_data</code>：可更新parachain的runtime wasm，更新[存储中的PersistedValidationData，RelevantMessagingState，HostConfiguration，processed_downward_messages，hrmp_watermark]，处理数据[<code>on_validation_data</code>，<code>DownwardMessageHandlers::handle_downward_message</code>，<code>HrmpMessageHandlers::handle_hrmp_message</code>]</p>
<h3 id="Collation"><a href="#Collation" class="headerlink" title="Collation"></a>Collation</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Collation</span></span>&lt;BlockNumber = polkadot_primitives::v1::BlockNumber&gt; &#123;</span><br><span class="line">	<span class="comment">/// Messages destined to be interpreted by the Relay chain itself.</span></span><br><span class="line">	<span class="keyword">pub</span> upward_messages: <span class="built_in">Vec</span>&lt;UpwardMessage&gt;,</span><br><span class="line">	<span class="comment">/// The horizontal messages sent by the parachain.</span></span><br><span class="line">	<span class="keyword">pub</span> horizontal_messages: <span class="built_in">Vec</span>&lt;OutboundHrmpMessage&lt;ParaId&gt;&gt;,</span><br><span class="line">	<span class="comment">/// New validation code. Used by upgrade</span></span><br><span class="line">	<span class="keyword">pub</span> new_validation_code: <span class="built_in">Option</span>&lt;ValidationCode&gt;,</span><br><span class="line">	<span class="comment">/// The head-data produced as a result of execution.</span></span><br><span class="line">    <span class="comment">// HeadData(ParachainBlockData.header.encode())</span></span><br><span class="line">	<span class="keyword">pub</span> head_data: HeadData,</span><br><span class="line">	<span class="comment">/// Proof to verify the state transition of the parachain.</span></span><br><span class="line">	<span class="keyword">pub</span> proof_of_validity: PoV,</span><br><span class="line">	<span class="comment">/// The number of messages processed from the DMQ.</span></span><br><span class="line">	<span class="keyword">pub</span> processed_downward_messages: <span class="built_in">u32</span>,</span><br><span class="line">	<span class="comment">/// The mark which specifies the block number up to which all inbound HRMP messages are processed.</span></span><br><span class="line">	<span class="keyword">pub</span> hrmp_watermark: BlockNumber,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PoV</span></span> &#123;</span><br><span class="line">	<span class="comment">/// The block witness data.</span></span><br><span class="line">	<span class="keyword">pub</span> block_data: BlockData,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PoV = BlockData(ParachainBlockData.encode())</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ParachainBlockData</span></span>&lt;B: BlockT&gt; &#123;</span><br><span class="line">	<span class="comment">/// The header of the parachain block.</span></span><br><span class="line">	header: &lt;B <span class="keyword">as</span> BlockT&gt;::Header,</span><br><span class="line">	<span class="comment">/// The extrinsics of the parachain block without the `PolkadotInherent`.</span></span><br><span class="line">	extrinsics: <span class="built_in">Vec</span>&lt;&lt;B <span class="keyword">as</span> BlockT&gt;::Extrinsic&gt;,</span><br><span class="line">	<span class="comment">/// The data that is required to emulate the storage accesses executed by all extrinsics.</span></span><br><span class="line">	storage_proof: StorageProof,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">StorageProof</span></span> &#123;</span><br><span class="line">	trie_nodes: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ensure-Code的available-data"><a href="#Ensure-Code的available-data" class="headerlink" title="Ensure Code的available_data"></a>Ensure Code的available_data</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvailableData</span></span> &#123;</span><br><span class="line">	<span class="comment">/// The Proof-of-Validation of the candidate.</span></span><br><span class="line">	<span class="keyword">pub</span> pov: std::sync::Arc&lt;PoV&gt;,</span><br><span class="line">	<span class="comment">/// The persisted validation data needed for secondary checks.</span></span><br><span class="line">	<span class="keyword">pub</span> validation_data: PersistedValidationData,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连接并通知validator"><a href="#连接并通知validator" class="headerlink" title="连接并通知validator"></a>连接并通知validator</h2><ul>
<li>collator_protocol_subsystem 监听Communication(CollatorProtocolMessage)，<code>process_msg</code>处理消息。收到<code>DistributeCollation</code>后，检查para_id，然后<code>distribute_collation</code>向validator广播。<ul>
<li><code>distribute_collation</code>：要求collation在active-leaves上，collation未被发送<ul>
<li><code>determine_core</code>：计算当前平行链分配到的core</li>
<li><code>determine_our_validators</code>：计算分配到该平行链的validator集合，包括当前集合和下一次分配的集合。每个session会依据<code>n_cores</code>和<code>validators.len()</code>重新排列ValidatorGroups，但是不一定是一个session才更换分配给平行链的group。</li>
<li><code>connect_to_validators</code>：同时连接当前validators和下一组validators。</li>
</ul>
</li>
</ul>
</li>
<li>连接上新的validator后，在collator protocol子系统中<code>handle_validator_connected</code><ul>
<li>发送一个<code>CollatorProtocolMessage::Declare(CollatorId)</code>给validator，注册collator</li>
<li>如果validator是属于该平行链的验证人集合，那么<code>add_peer_id_for_validator</code>记录validators的peer_id，<code>advertise_collation</code>，向validator 发送<code>CollatorProtocolMessage::AdvertiseCollation(relay_parent, collating_on)</code> ，通知validator准备发送collation了。</li>
</ul>
</li>
</ul>
<h3 id="Candidate"><a href="#Candidate" class="headerlink" title="Candidate"></a>Candidate</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CandidateReceipt</span></span>&lt;H = Hash&gt; &#123;</span><br><span class="line">	<span class="comment">/// The descriptor of the candidate.</span></span><br><span class="line">	<span class="keyword">pub</span> descriptor: CandidateDescriptor&lt;H&gt;,</span><br><span class="line">	<span class="comment">/// The hash of the encoded commitments made as a result of candidate execution.</span></span><br><span class="line">	<span class="keyword">pub</span> commitments_hash: Hash,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CandidateDescriptor</span></span>&lt;H = Hash&gt; &#123;</span><br><span class="line">	<span class="comment">/// The ID of the para this is a candidate for.</span></span><br><span class="line">	<span class="keyword">pub</span> para_id: Id,</span><br><span class="line">	<span class="comment">/// The hash of the relay-chain block this is executed in the context of.</span></span><br><span class="line">	<span class="keyword">pub</span> relay_parent: H,</span><br><span class="line">	<span class="comment">/// The collator&#x27;s sr25519 public key.</span></span><br><span class="line">	<span class="keyword">pub</span> collator: CollatorId,</span><br><span class="line">	<span class="comment">/// The blake2-256 hash of the persisted validation data. This is extra data derived from</span></span><br><span class="line">	<span class="comment">/// relay-chain state which may vary based on bitfields included before the candidate.</span></span><br><span class="line">	<span class="comment">/// Thus it cannot be derived entirely from the relay-parent.</span></span><br><span class="line">	<span class="keyword">pub</span> persisted_validation_data_hash: Hash,</span><br><span class="line">	<span class="comment">/// The blake2-256 hash of the pov.</span></span><br><span class="line">	<span class="keyword">pub</span> pov_hash: Hash,</span><br><span class="line">	<span class="comment">/// The root of a block&#x27;s erasure encoding Merkle tree.</span></span><br><span class="line">	<span class="keyword">pub</span> erasure_root: Hash,</span><br><span class="line">	<span class="comment">/// Signature on blake2-256 of components of this receipt:</span></span><br><span class="line">	<span class="comment">/// The parachain index, the relay parent, the validation data hash, and the pov_hash.</span></span><br><span class="line">	<span class="keyword">pub</span> signature: CollatorSignature,</span><br><span class="line">	<span class="comment">/// Hash of the para header that is being generated by this candidate.</span></span><br><span class="line">	<span class="keyword">pub</span> para_head: Hash,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CandidateCommitments = Collation - PoV</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CandidateCommitments</span></span>&lt;N = BlockNumber&gt; &#123;</span><br><span class="line">	<span class="comment">/// Messages destined to be interpreted by the Relay chain itself.</span></span><br><span class="line">	<span class="keyword">pub</span> upward_messages: <span class="built_in">Vec</span>&lt;UpwardMessage&gt;,</span><br><span class="line">	<span class="comment">/// Horizontal messages sent by the parachain.</span></span><br><span class="line">	<span class="keyword">pub</span> horizontal_messages: <span class="built_in">Vec</span>&lt;OutboundHrmpMessage&lt;Id&gt;&gt;,</span><br><span class="line">	<span class="comment">/// New validation code.</span></span><br><span class="line">	<span class="keyword">pub</span> new_validation_code: <span class="built_in">Option</span>&lt;ValidationCode&gt;,</span><br><span class="line">	<span class="comment">/// The head-data produced as a result of execution.</span></span><br><span class="line">	<span class="keyword">pub</span> head_data: HeadData,</span><br><span class="line">	<span class="comment">/// The number of messages processed from the DMQ.</span></span><br><span class="line">	<span class="keyword">pub</span> processed_downward_messages: <span class="built_in">u32</span>,</span><br><span class="line">	<span class="comment">/// The mark which specifies the block number up to which all inbound HRMP messages are processed.</span></span><br><span class="line">	<span class="keyword">pub</span> hrmp_watermark: N,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回应validator的请求"><a href="#回应validator的请求" class="headerlink" title="回应validator的请求"></a>回应validator的请求</h2><ul>
<li>收到validator消息<code>CollatorProtocolMessage::RequestCollation</code><ul>
<li><code>send_collation</code>：回应validtor，发送<code>CollatorProtocolMessage::Collation(request_id,receipt,pov)</code>给validator。对PoV进行<code>compress</code>再发送，减少通信压力。CandidateReceipt中只存储commitments_hash，validator在验证时从PoV中重新组装出commitments，最后验证hash是否一致。<br>由于这是节点间通信，overseer的中继只能作用于节点内的子系统之间，所以这个消息是被封装在<code>NetworkBridgeMessage::SendCollationMessage</code>中的，通过 network_bridge_subsystem 向validator转发消息（一对一，非广播）。</li>
</ul>
</li>
</ul>
<h2 id="出块"><a href="#出块" class="headerlink" title="出块"></a>出块</h2><ul>
<li>当中继链上statement被checked后（状态为seconded），collator在平行链上<code>announce_block</code>，此时为暂时同步。</li>
<li>最佳区块和终结区块跟随中继链的出块。</li>
</ul>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><p>实际上，以上所描述的Collator与子系统的交互也可以说是以Collator角度的平行链出块流程。关于以Validator角度的平行链出块流程将在《平行链节点的出块流程》中介绍。</p>
]]></content>
      <categories>
        <category>Polkadot</category>
        <category>平行链</category>
      </categories>
  </entry>
  <entry>
    <title>平行链节点的出块流程</title>
    <url>/blog/494d34b2.html</url>
    <content><![CDATA[<h1 id="出块流程"><a href="#出块流程" class="headerlink" title="出块流程"></a>出块流程</h1><a id="more"></a>
<ol>
<li>为平行链尽可能平均地分配validator group；</li>
<li>collator生成一个平行链区块，和该区块的PoV一起组成collation/candidate；</li>
<li>collator将candidate通过Collator Protocol传递给group内的validator（1 to 1， 非广播）；</li>
<li>group内的validators通过Candidate Backing对candidate进行验证和共识。collation通过共识后状态变更为”backable”；</li>
<li>中继链出块人将backable candidate打包上链，此时candidate状态为”pending availability”，此时不会更新parachain的head；</li>
<li>在后续的中继链区块中，validators会通过Availability Distribution子系统使得candidate变为available（所有validators的2/3以上持有candidate的PoV）；</li>
<li>中继链出块人将available的candidate打包上链，此时更新parachain的head，并对candidate中包含的消息（主要是跨链消息）进行处理；</li>
<li>类似于finalize，对candidate也有Approval Process的过程，来对candidate进行二次检查，如果有validator报告检查不通过，那么触发所有validators对该candidate进行重新验证。</li>
</ol>
<h1 id="中继链"><a href="#中继链" class="headerlink" title="中继链"></a>中继链</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul>
<li>中继链启动时，启动overseer，包含一些子系统：candidate_backing，candidate_selection，statement_distribution，availability_distribution等,<code>route_message</code>为子系统进行<code>AllMessages</code>消息中继，发送到指定的子系统。中继链<code>forward_events</code>将中继链主系统的消息传递给overseer。</li>
<li>中继链节点与overseer交互由事件触发，主要的事件是块导入，块终结，send_msg。<code>Event::BlockImported</code>和<code>Event::BlockFinalized</code>会更改<code>active_leaves</code>，<code>send_msg</code>主要用来初始化collation_generation子系统，激活CollatorProtocol，向provisioner请求候选区块。<ul>
<li>OverseerHandler{events_tx} 外部发送事件，overseer.events_rx接收外部消息。</li>
<li>子系统持有OverseerSubsystemContext 与overseer 交互</li>
<li>子系统A，B交互，A发送AllMessages::B，overseer转换为Fromoverseer::Communication{B}发送给B。</li>
</ul>
</li>
</ul>
<h2 id="请求候选区块"><a href="#请求候选区块" class="headerlink" title="请求候选区块"></a>请求候选区块</h2><p>CollatorProtocol::validator_side：</p>
<ul>
<li>接受到来自collator的<code>Declare</code>，将collator的信息（peer_id, collatorId）保存到State.known_collators。collatorId是collator的公钥。</li>
<li>接受到来自collator的<code>AdvertiseCollation</code>，触发<code>notify_candidate_selection</code>：通知CandidateSelectionSubsystem。</li>
<li>CandidateSelectionSubsystem <code>handle_collation</code>:<ul>
<li>检查<code>para_id</code>是否是该validator负责的，如果不是，<code>forward_invalidity_note</code> -&gt; <code>report_collator</code> 降低collator的信誉。</li>
<li><code>get_collation</code>发送CollatorProtocolMessage::FetchCollation，触发<code>fetch_collation</code>，等待回应：<ul>
<li><code>request_collation</code>发送CollatorProtocolMessage::RequestCollation(relay_parent, para_id)，向<code>known_collators</code>请求collation。</li>
<li>收到collator发来的protocol_v1::CollatorProtocolMessage::Collation，触发<code>received_collation</code>：取消仍然正在进行的request_collation（第一次选择了Collation的地方，先到先得，还没准备好发送的collator被排除），唤醒requests_in_progress（如果超时，惩罚collator），回复请求一个元组(candidate_receipt, pov)唤醒<code>get_collation</code>，存储collation。如果是过时的collation，会降低collator的声誉。</li>
</ul>
</li>
<li><code>second_candidate</code>：发送<code>CandidateBackingMessage::Second(relay_parent,candidate_receipt,pov)</code> 给 candidate backing子系统；</li>
</ul>
</li>
</ul>
<h2 id="验证、支持候选区块"><a href="#验证、支持候选区块" class="headerlink" title="验证、支持候选区块"></a>验证、支持候选区块</h2><ul>
<li>candidate backing子系统 <code>process_msg</code>处理 CandidateBackingMessage::Second。<ul>
<li>检查<code>para_id</code>是否是<code>self.assignment</code>；</li>
<li>检查是否second（支持）过其他candidate；</li>
<li>检查是否对该candidate已经有issued_statements；</li>
<li><code>validate_and_second</code><ul>
<li>检查candidate中的collator是否为schdule计划中的，如果无效，惩罚collator；</li>
<li>background_validate_and_make_available：将candidate加入<code>awaiting_validation</code>，启动异步任务<code>validate_and_make_available</code>：<ul>
<li>从params获取到PoV（Second消息中携带了PoV）；</li>
<li><code>request_candidate_validation</code>发送<code>CandidateValidationMessage::ValidateFromChainState</code>，candidate validation子系统<code>spawn_validate_from_chain_state</code><ul>
<li><code>find_assumed_validation_data</code>检查candidate的<code>PersistedValidationData</code>是否与中继链上一致，这里也检查了parent_head；</li>
<li><code>spawn_validate_exhaustive</code> -&gt; <code>validate_candidate_exhaustive</code>，<ul>
<li><code>perform_basic_checks</code>基础检查：pov大小是否超过max_pov_size，candidate.descriptor.pov_hash与pov.hash是否一致，<code>check_collator_signature</code>；</li>
<li><code>validate</code> -&gt; <code>wasm_executor::validate_candidate</code> -&gt; <code>pool.validate_candidate</code> -&gt; <code>validate_candidate_custom</code> -&gt; <code>ValidationHost::validate_candidate</code>: <code>start_worker</code>通过<code>process::Command::new</code>子命令创建子进程执行<code>run_worker</code>，父子进程通过共享内存进行通信<ul>
<li><code>run_worker</code> -&gt; <code>validate_candidate_internal</code><ul>
<li>调用validation_code中的<code>validate_block(ValidationParams)</code>： <code>E::execute_block(block)</code>执行区块，然后读取变更后的存储组装成ValidationResult（数据结构与CandidateCommitments一致）</li>
</ul>
</li>
</ul>
</li>
<li>检查ValidationResult.head_data.hash() == descriptor.para_head ?</li>
<li>将ValidationResult组装成CandidateCommitments，返回验证结果(CandidateCommitments, persisted_validation_data)</li>
</ul>
</li>
<li><code>runtime_api_request</code>发送<code>RuntimeApiRequest::CheckValidationOutputs</code>，Runtime api子系统调用inclusion模块的<code>check_validation_outputs_for_runtime_api</code>，主要是检查<code>CandidateCommitments</code>是否满足接受标准：数据大小，消息数量。</li>
</ul>
</li>
<li>检查commitments_hash是否与ValidationResuld的一致；</li>
<li><code>make_pov_available</code>：生成纠删码，验证<code>erasure_root</code>。<code>store_available_data</code>：发送AvailabilityStoreMessage::StoreAvailableData(CandidateReceipt.hash, self.ValidatorIndex, n_validators, AvailableData, tx)，av store存储可用数据available_data和整个纠删码。</li>
<li>发送<code>ValidatedCandidateCommand::Second(candidate, commitments, pov)</code><h3 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要是persisted_validation_data的数据</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ValidationParams</span></span> &#123;</span><br><span class="line">	<span class="comment">/// Previous head-data.</span></span><br><span class="line">	<span class="keyword">pub</span> parent_head: HeadData,  <span class="comment">// persisted_validation_data.parent_head</span></span><br><span class="line">	<span class="comment">/// The collation body.</span></span><br><span class="line">	<span class="keyword">pub</span> block_data: BlockData,  <span class="comment">// pov.block_data</span></span><br><span class="line">	<span class="comment">/// The current relay-chain block number.</span></span><br><span class="line">	<span class="keyword">pub</span> relay_chain_height: RelayChainBlockNumber,</span><br><span class="line">	<span class="comment">/// The relay-chain block&#x27;s storage root.</span></span><br><span class="line">	<span class="keyword">pub</span> relay_storage_root: Hash,</span><br><span class="line">	<span class="comment">/// The MQC head for the DMQ.</span></span><br><span class="line">	<span class="comment">///</span></span><br><span class="line">	<span class="comment">/// The DMQ MQC head will be used by the validation function to authorize the downward messages</span></span><br><span class="line">	<span class="comment">/// passed by the collator.</span></span><br><span class="line">	<span class="keyword">pub</span> dmq_mqc_head: Hash,</span><br><span class="line">	<span class="comment">/// The list of MQC heads for the inbound HRMP channels paired with the sender para ids. This</span></span><br><span class="line">	<span class="comment">/// vector is sorted ascending by the para id and doesn&#x27;t contain multiple entries with the same</span></span><br><span class="line">	<span class="comment">/// sender.</span></span><br><span class="line">	<span class="keyword">pub</span> hrmp_mqc_heads: <span class="built_in">Vec</span>&lt;(Id, Hash)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ValidationResult</span></span> &#123;</span><br><span class="line">	<span class="comment">/// New head data that should be included in the relay chain state.</span></span><br><span class="line">	<span class="keyword">pub</span> head_data: HeadData,</span><br><span class="line">	<span class="comment">/// An update to the validation code that should be scheduled in the relay chain.</span></span><br><span class="line">	<span class="keyword">pub</span> new_validation_code: <span class="built_in">Option</span>&lt;ValidationCode&gt;,</span><br><span class="line">	<span class="comment">/// Upward messages send by the Parachain.</span></span><br><span class="line">	<span class="keyword">pub</span> upward_messages: <span class="built_in">Vec</span>&lt;UpwardMessage&gt;,</span><br><span class="line">	<span class="comment">/// Outbound horizontal messages sent by the parachain.</span></span><br><span class="line">	<span class="keyword">pub</span> horizontal_messages: <span class="built_in">Vec</span>&lt;OutboundHrmpMessage&lt;Id&gt;&gt;,</span><br><span class="line">	<span class="comment">/// Number of downward messages that were processed by the Parachain.</span></span><br><span class="line">	<span class="comment">///</span></span><br><span class="line">	<span class="comment">/// It is expected that the Parachain processes them from first to last.</span></span><br><span class="line">	<span class="keyword">pub</span> processed_downward_messages: <span class="built_in">u32</span>,</span><br><span class="line">	<span class="comment">/// The mark which specifies the block number up to which all inbound HRMP messages are processed.</span></span><br><span class="line">	<span class="keyword">pub</span> hrmp_watermark: RelayChainBlockNumber,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AvailableData"><a href="#AvailableData" class="headerlink" title="AvailableData"></a>AvailableData</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvailableData</span></span> &#123;</span><br><span class="line">	<span class="comment">/// The Proof-of-Validation of the candidate.</span></span><br><span class="line">	<span class="keyword">pub</span> pov: std::sync::Arc&lt;PoV&gt;,</span><br><span class="line">	<span class="comment">/// The persisted validation data needed for secondary checks.</span></span><br><span class="line">	<span class="keyword">pub</span> validation_data: PersistedValidationData,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对候选区块共识"><a href="#对候选区块共识" class="headerlink" title="对候选区块共识"></a>对候选区块共识</h2><ul>
<li><p>CandidateBackingJob监听任务，<code>handle_validated_candidate_command</code>接受命令<code>ValidatedCandidateCommand::Second</code>：将candidate_hash插入self.seconded和self.issued_statements，组装Statement::Seconded(CommittedCandidateReceipt)</p>
<ul>
<li><p><code>sign_import_and_distribute_statement</code>对statement共识</p>
<ul>
<li><code>sign_statement</code>对statement签名</li>
<li><code>import_statement</code><ul>
<li><code>primitive_statement_to_table</code>转换statement为SignedStatement</li>
<li><code>Table::import_statement</code><ul>
<li><code>import_candidate</code>：导入Statement::Candidate状态的candidate。digest = CommittedCandidateReceipt.hash()。如果Table.authority_data已经有proposal，验证digest，如果不相符，要报告Misbehavior::MultipleCandidates。Table::candidate_votes插入CandidateData。进行投票ValidityVote::Issued。</li>
<li><code>validity_vote</code><ul>
<li><code>requisite_votes</code>：计算至少需要的票数，group.validators.len()/2 + 1；</li>
<li>检查本validator是否是group内，如果不是，报告Misbehavior::UnauthorizedStatement；</li>
<li>如果已经投票过，报告Misbehavior::ValidityDoubleVote或者Misbehavior::DoubleSign；</li>
<li>如果是第一次投票，<code>insert(vote)</code>。当票数足够时（大于该group的1/2），<code>update_includable_count</code>更新<code>Table::includable_count</code>，记录parachain是否通过。返回<code>Summary</code>。</li>
</ul>
</li>
<li><code>attested_candidate</code>：仅当<code>can_be_included</code>为true时，才返回AttestedCandidate</li>
<li>将<code>summary.candidate</code>(digest)插入CandidateBackingJob的backed集合，<code>table_attested_to_backed</code>将AttestedCandidate转换为BackedCandidate，<code>send_to_provisioner</code>将(relay_parent, CommittedCandidateReceipt) 通过封装在ProvisionableData::BackedCandidate消息中存储到provisioner_subsystem。当<code>can_be_included</code>为false时，不会存储到provisioner_subsystem，中继链就不会打包这个候选区块。</li>
<li><code>issue_new_misbehaviors</code>报告之前出现的misbehaviors。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>distribute_signed_statement</code>：发送StatementDistributionMessage::Share。statement distribution子系统收到后：</p>
<ul>
<li><code>inform_statement_listeners</code>（collator在<code>wait_to_announce</code>时注册成为listener）</li>
<li><p><code>circulate_statement_and_dependents</code>(更新后）广播statement：active_head在之前收到OverseerSignal::ActiveLeaves时创建</p>
<ul>
<li><code>note_statement</code>：做一些简单检查，标记statement的状态，比如如果可以接受并且是未存到active_head的，那么返回NotedStatement::Fresh。</li>
<li>如果是NotedStatement::Fresh，<code>circulate_statement</code>查找其他还未拥有该statement的validators，返回peers_needing_dependents。</li>
<li><p><code>send_statements_about</code>给peers_needing_dependents发送statements。</p>
</li>
<li><p>其他validator <code>handle_network_update</code> 收到NetworkBridgeEvent::PeerMessage后，<code>handle_incoming_message</code>：</p>
<ul>
<li>如果是不需要的statement, <code>report_peer</code>降低peer的信誉；</li>
<li><code>check_statement_signature</code>，签名错误<code>report_peer</code>；</li>
<li>检查statement是否真的存在于收到的peer data，不存在则<code>report_peer</code>；</li>
<li>如果该statement不在该validator的known_candidates中，<code>send_statements_about</code>发送该candidate的statements给peer。所以group内的validator不一定需要直连，通过p2p网络最终也能收到其他的statement。</li>
<li>inform_statement_listeners</li>
<li>note_statement：如果是NotedStatement::Fresh，发送CandidateBackingMessage::Statement。</li>
<li>CandidateBacking子系统收到后：<ul>
<li>check_statement_signature</li>
<li><code>maybe_validate_and_import</code><ul>
<li><code>import_statement</code></li>
<li><code>kick_off_validation_work</code>：如果已经在issued_statements中则直接退出。检查group_id。如果candidate的collator与required_collator不一致，将其直接插入到issued_statements，然后返回。否则<ul>
<li><code>background_validate_and_make_available</code>：此时传入的PoV为None，在<code>validate_and_make_available</code>中会触发<code>request_pov_from_distribution</code>，向所有拥有当前relay_parent的peers广播awaiting pov状态，最后发送ValidatedCandidateCommand::Attest给CandidateBackingJob。</li>
<li>CandidateBackingJob收到Attest后，检查issued_statements，未issue的话插入其中，然后<code>sign_import_and_distribute_statement</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果是fresh的，<code>circulate_statement</code>，但是忽略peers_needing_dependents。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>distribute_pov</code>：发送PoVDistributionMessage::DistributePoV。</p>
<ul>
<li>子系统pov distribution接受DistributePoV后<code>handle_distribute</code>：<code>distribute_to_awaiting</code>把pov发给等待该relay_parent的validator（之前有<code>request_pov_from_distribution</code>），发送PoVDistributionMessage::SendPoV，其他validator收到后<code>handle_incoming_pov</code>继续<code>distribute_to_awaiting</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CommittedCandidateReceipt"><a href="#CommittedCandidateReceipt" class="headerlink" title="CommittedCandidateReceipt"></a>CommittedCandidateReceipt</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CommittedCandidateReceipt</span></span>&lt;H = Hash&gt; &#123;</span><br><span class="line">	<span class="comment">/// The descriptor of the candidate.</span></span><br><span class="line">	<span class="keyword">pub</span> descriptor: CandidateDescriptor&lt;H&gt;,</span><br><span class="line">	<span class="comment">/// The commitments of the candidate receipt.</span></span><br><span class="line">	<span class="keyword">pub</span> commitments: CandidateCommitments,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CandidateData"><a href="#CandidateData" class="headerlink" title="CandidateData"></a>CandidateData</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CandidateData</span></span>&lt;Ctx: Context&gt; &#123;</span><br><span class="line">	group_id: Ctx::GroupId, <span class="comment">// para_id</span></span><br><span class="line">	candidate: Ctx::Candidate,  <span class="comment">// CommittedCandidateReceipt</span></span><br><span class="line">	validity_votes: HashMap&lt;Ctx::AuthorityId, ValidityVote&lt;Ctx::Signature&gt;&gt;,</span><br><span class="line">	indicated_bad_by: <span class="built_in">Vec</span>&lt;Ctx::AuthorityId&gt;, <span class="comment">// count ValidityVote::Invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Summary</span></span>&lt;Digest, Group&gt; &#123;</span><br><span class="line">	<span class="comment">/// The digest of the candidate referenced.</span></span><br><span class="line">	<span class="keyword">pub</span> candidate: Digest,</span><br><span class="line">	<span class="comment">/// The group that the candidate is in.</span></span><br><span class="line">	<span class="keyword">pub</span> group_id: Group,</span><br><span class="line">	<span class="comment">/// How many validity votes are currently witnessed.</span></span><br><span class="line">	<span class="keyword">pub</span> validity_votes: <span class="built_in">usize</span>,</span><br><span class="line">	<span class="comment">/// Whether this has been signalled bad by at least one participant.</span></span><br><span class="line">	<span class="keyword">pub</span> signalled_bad: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AttestedCandidate"><a href="#AttestedCandidate" class="headerlink" title="AttestedCandidate"></a>AttestedCandidate</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AttestedCandidate</span></span>&lt;Group, Candidate, AuthorityId, Signature&gt; &#123;</span><br><span class="line">	<span class="comment">/// The group ID that the candidate is in.</span></span><br><span class="line">	<span class="keyword">pub</span> group_id: Group,</span><br><span class="line">	<span class="comment">/// The candidate data.</span></span><br><span class="line">	<span class="keyword">pub</span> candidate: Candidate,</span><br><span class="line">	<span class="comment">/// Validity attestations.</span></span><br><span class="line">	<span class="keyword">pub</span> validity_votes: <span class="built_in">Vec</span>&lt;(AuthorityId, ValidityAttestation&lt;Signature&gt;)&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BackedCandidate"><a href="#BackedCandidate" class="headerlink" title="BackedCandidate"></a>BackedCandidate</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BackedCandidate</span></span>&lt;H = Hash&gt; &#123;</span><br><span class="line">	<span class="comment">/// The candidate referred to.</span></span><br><span class="line">	<span class="keyword">pub</span> candidate: CommittedCandidateReceipt&lt;H&gt;,</span><br><span class="line">	<span class="comment">/// The validity votes themselves, expressed as signatures.</span></span><br><span class="line">	<span class="keyword">pub</span> validity_votes: <span class="built_in">Vec</span>&lt;ValidityAttestation&gt;,</span><br><span class="line">	<span class="comment">/// The indices of the validators within the group, expressed as a bitfield.</span></span><br><span class="line">	<span class="keyword">pub</span> validator_indices: BitVec&lt;bitvec::order::Lsb0, <span class="built_in">u8</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可用性检查"><a href="#可用性检查" class="headerlink" title="可用性检查"></a>可用性检查</h2><ul>
<li><p>Availability Distribution子系统:</p>
<ul>
<li><code>handle_our_view_change</code>：将处于pending availability队列中（根据core获得，core的状态是根据链上存储计算的）的backed candidates对应的ErasureChunk广播给peers（如果拥有的话）。遍历所有validator获取chunk_index，获取对应的ErasureChunk；</li>
<li><code>process_incoming_peer_message</code>：发送<code>StoreChunk</code>给av store来保存与本validator_index对应的chunk。</li>
<li><code>handle_peer_view_change</code>：将所有活跃信息重新发送给该peer；</li>
</ul>
</li>
<li><p>BitfieldSigning子系统：每次收到ActiveLeaves(ActiveLeavesUpdate)都会派发一个BitfieldSigningJob，延迟1.5秒后<code>construct_availability_bitfield</code>：</p>
<ul>
<li><code>get_availability_cores</code>；</li>
<li><code>get_core_availability</code>：发送AvailabilityStoreMessage::QueryChunkAvailability(candidate, validator_index, tx)向Availability Store查询对于该validator对某个Core是否拥有availability chunk</li>
<li>遍历所有availability_cores，得到bitfield: Vec<bool>；</bool></li>
</ul>
</li>
<li><code>validator.sign</code>对bitfield签名；</li>
<li><p>发送BitfieldDistributionMessage::DistributeBitfield(relay_parent, signed_bitfield)。</p>
</li>
<li><p>bitfield distribution收到后，<code>handle_bitfield_distribution</code>处理signed_bitfield：</p>
<ul>
<li><code>validator_index</code>从签名中获取validator_index，再从ProtocolState::per_relay_parent::validator_set中得到validatorId；</li>
<li><code>relay_message</code>将bitfield发送ProvisionableData::Bitfield给Provisioner记录到signed_bitfields。</li>
</ul>
</li>
</ul>
<h3 id="ErasureChunk"><a href="#ErasureChunk" class="headerlink" title="ErasureChunk"></a>ErasureChunk</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ErasureChunk</span></span> &#123;</span><br><span class="line">	<span class="comment">/// The erasure-encoded chunk of data belonging to the candidate block.</span></span><br><span class="line">	<span class="keyword">pub</span> chunk: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">	<span class="comment">/// The index of this erasure-encoded chunk of data.</span></span><br><span class="line">	<span class="keyword">pub</span> index: <span class="built_in">u32</span>,</span><br><span class="line">	<span class="comment">/// Proof for this chunk&#x27;s branch in the Merkle tree.</span></span><br><span class="line">	<span class="keyword">pub</span> proof: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出块"><a href="#出块" class="headerlink" title="出块"></a>出块</h2><ul>
<li>中继链<code>propose</code><ul>
<li><code>get_provisioner_data</code><ul>
<li>overseer.<code>wait_for_activation</code>等待relay_parent为中继链父哈希的叶子在overseer上激活，发送ProvisionerMessage::RequestInherentData请求数据，PROPOSE_TIMEOUT(2.5秒)内需要收到数据；</li>
</ul>
</li>
<li>打包进inherent_data。</li>
</ul>
</li>
<li>Provisioner子系统启动job时，ProvisioningJob::inherent_after设置为Delay(PRE_PROPOSE_TIMEOUT) 2秒；</li>
<li><p>收到RequestInherentData消息后，等待inherent_after空闲，然后</p>
<ul>
<li><code>send_inherent_data</code>：回应RequestInherentData请求<ul>
<li><code>request_availability_cores</code></li>
<li><code>select_availability_bitfields</code>：此时存储在signed_bitfields中的可能有多个bitfields。选择规则：对每个validator，选择通过可用性检查最多的bitfields；</li>
<li><code>select_candidates</code>：<ul>
<li>转换availability_cores为(ScheduledCore, OccupiedCoreAssumption)</li>
<li><code>request_persisted_validation_data</code>：向RuntimeApi请求；</li>
<li>比对para_id和persisted_validation_data_hash；</li>
<li>发送CandidateBackingMessage::GetBackedCandidates获取candidates: Vec<BackedCandidate>；</BackedCandidate></li>
<li>检查candidates的顺序是否与selected_candidates一致；</li>
</ul>
</li>
<li>返回(bitfields, candidates)。</li>
</ul>
</li>
</ul>
</li>
<li><p>inclusion_inherent模块中<code>create_inherent</code>，调用<code>Call::inclusion(signed_bitfields, backed_candidates, parent_header)</code>。</p>
<ul>
<li>每个块只能执行一次<code>inclusion</code>；</li>
<li>检查parent_header；</li>
<li><code>process_bitfields</code>：处理bitfields，返回已经处理完置为free的core队列，对应的candidates一定已经是baked：<ul>
<li>读取PendingAvailability存储（<code>process_candidates</code>中会插入）</li>
<li>根据signed_bitfields签名的validator_index更新pending_availability中的availability_votes[val_idx]为true；</li>
<li>AvailabilityBitfields::insert(validator_index, record)；</li>
<li>检查pending_availability::availability_votes是否大于2/3的validators.len()；</li>
<li><code>enact_candidate</code>:<ul>
<li><code>T::RewardValidators::reward_backing</code></li>
<li><code>T::RewardValidators::reward_bitfields</code></li>
<li><code>schedule_code_upgrade</code></li>
<li><code>prune_dmq</code></li>
<li><code>enact_upward_messages</code></li>
<li><code>prune_hrmp</code></li>
<li><code>queue_outbound_hrmp</code></li>
<li><code>note_new_head</code>更新平行链head；</li>
</ul>
</li>
<li>pending_availability.core插入freed队列；</li>
</ul>
</li>
<li><code>&lt;scheduler::Module&lt;T&gt;&gt;::clear()</code>；</li>
<li><code>&lt;scheduler::Module&lt;T&gt;&gt;::schedule(freed,block_number)</code>；</li>
<li><code>process_candidates</code>：处理backed的candidates，<code>PendingAvailability::insert(para_id, CandidatePendingAvailability)</code>，返回来自scheduled的Vec&lt;(core_index, bakers)&gt;；</li>
<li><code>scheduler::Module::occupied</code>：backed candidates将<code>process_candidates</code>返回的cores进行占用，然后才能进行Availability Distribution与BitfieldSigning；</li>
<li><code>&lt;ump::Module&lt;T&gt;&gt;::process_pending_upward_messages()</code>。</li>
</ul>
</li>
</ul>
<h2 id="Approval-Check"><a href="#Approval-Check" class="headerlink" title="Approval Check"></a>Approval Check</h2><p>group内的validator可能作恶，需要二次检查（类似finalized)。随机选取一些validator来再次验证平行链区块，如果验证失败，触发escalation，要求所有的validator来验证这个平行链区块。Approval Process是可以一次最终确认多个平行链区块的。</p>
<p>进入中继链出块的共识流程，直到被GRANDPA确认。</p>
]]></content>
      <categories>
        <category>Polkadot</category>
        <category>平行链</category>
      </categories>
  </entry>
  <entry>
    <title>Rust语言精要</title>
    <url>/blog/23c8ad1e.html</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>声明变量关键字：<code>let</code><br><a id="more"></a><br>变量值分为两种类型：</p>
<ul>
<li>可变的（<code>mut</code>）</li>
<li>不可变</li>
</ul>
<p>变量类型：</p>
<ul>
<li>布尔型 - <code>bool</code> 表示 true 或 false</li>
<li>无符号整型- <code>u8</code> <code>u32</code> <code>u64</code> <code>u128</code> 表示正整数</li>
<li>有符号整型 - <code>i8</code> <code>i32</code> <code>i64</code> <code>i128</code> 表示正负整数</li>
<li>指针大小的整数 - <code>usize</code> <code>isize</code> 表示内存中内容的索引和大小</li>
<li>浮点数 - <code>f32</code> <code>f64</code></li>
<li>元组（tuple） - <code>(value, value, ...)</code> 用于在栈上传递固定序列的值</li>
<li>数组 - 在编译时已知的具有固定长度的相同元素的集合</li>
<li>切片（slice） - 在运行时已知长度的相同元素的集合</li>
<li><code>str</code>(string slice) - 在运行时已知长度的文本</li>
</ul>
<p>可以通过将类型附加到数字的末尾来明确指定数字类型（如 <code>13u32</code> 和 <code>2u8</code>）。</p>
<p>使用<code>as</code>进行类型转换：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">13u8</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">7u32</span>;</span><br><span class="line"><span class="keyword">let</span> c = a <span class="keyword">as</span> <span class="built_in">u32</span> + b;</span><br></pre></td></tr></table></figure>
<h2 id="元组-amp-数组"><a href="#元组-amp-数组" class="headerlink" title="元组 &amp; 数组"></a>元组 &amp; 数组</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>数组初始就固定了长度，即使声明为mut也只能修改索引上的元素，而不是数组本身。数组的长度是其类型的一部分。可用于数组的方法（例如排序、搜索、筛选等），其实都是切片的方法，使用时会隐式地把数组转换为对切片的引用。</p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: (&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>, <span class="built_in">i32</span>, <span class="built_in">char</span>) = (<span class="string">&quot;hello&quot;</span>, <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y ,z) = tuple;</span><br></pre></td></tr></table></figure>
<p>当元组只有一个值的时候，需要写成(x, )，这是为了和括号中的其他值进行区分。</p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = (<span class="keyword">let</span> y = <span class="number">6</span>);	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>没有右值语义，Rust中不允许这么用，可以这么写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> y = &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">	x</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="与C-引用比较"><a href="#与C-引用比较" class="headerlink" title="与C++引用比较"></a>与C++引用比较</h2><ol>
<li>Rust中，必须使用&amp;和*来创建和解引用，只有 . 操作符例外，它会隐式地借用和解引用。</li>
<li>给Rust引用赋值会导致它指向新值，而给C++引用赋值会将值存储在引用中，而且指向地址固定为初始值的地址。</li>
</ol>
<h2 id="引用安全"><a href="#引用安全" class="headerlink" title="引用安全"></a>引用安全</h2><p>Rust会给每个引用类型附加一个<strong>生命周期</strong>。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><p>函数可以通过<strong>元组</strong>来返回多个值。</p>
<p>元组元素可以通过他们的索引来获取。</p>
<p>支持各种形式的解构，允许我们以符合人类工程学的方式提取数据结构的子片段。</p>
<h3 id="返回空"><a href="#返回空" class="headerlink" title="返回空"></a>返回空</h3><p>如果没有为函数指定返回类型，它将返回一个空的元组，也称为<em>单元</em>。</p>
<p>一个空的元组用 <code>()</code> 表示。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针实现了所有三个闭包 trait（Fn、FnMut 和 FnOnce），所以总是可以在调用期望闭包的函数时传递函数指针作为参数。倾向于编写使用泛型和闭包 trait 的函数，这样它就能接受函数或闭包作为参数。</p>
<h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">math</span></span>(op: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>, a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a =<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> b =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(math(sum, a, ,b), <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_true</span></span>() -&gt; <span class="built_in">bool</span> &#123; <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">true_maker</span></span>() -&gt; <span class="function"><span class="keyword">fn</span></span>() -&gt; <span class="built_in">bool</span> &#123; is_true &#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(true_maker()(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包在函数中的应用，常常与<code>trait</code>结合。</p>
<h3 id="闭包作为参数"><a href="#闭包作为参数" class="headerlink" title="闭包作为参数"></a>闭包作为参数</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">closure_math</span></span>&lt;F: <span class="built_in">Fn</span>() -&gt; <span class="built_in">i32</span>&gt;(op: F) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    op()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(closure_math(|| a + b ), <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包作为返回值"><a href="#闭包作为返回值" class="headerlink" title="闭包作为返回值"></a>闭包作为返回值</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">two_times_impl</span></span>() -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">move</span> |j| j * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = two_times_impl();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result(<span class="number">2</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包默认会按<strong><em>引用</em></strong>捕获变量（在此例中为 <code>i</code> ）。如果将此闭包返回，则引用也会跟着返回。而 i 会被销毁，所以引用变为悬垂指针。因此要加上move关键字，移动所有权。</p>
<p>或者如下写法，用<code>Box&lt;T&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">return_clo</span></span>() -&gt; <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>)-&gt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="built_in">Box</span>::new(|x| x+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = return_clo();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 + 1 = &#123;&#125;&quot;</span>, c(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 + 1 = &#123;&#125;&quot;</span>, (*c)(<span class="number">1</span>)); <span class="comment">//解引用多态</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="捕获环境值"><a href="#捕获环境值" class="headerlink" title="捕获环境值"></a>捕获环境值</h3><p>闭包可以通过三种方式捕获其环境，它们对应函数的三种获取参数的方式，分别是获取所有权、可变借用、不可变借用。这三种捕获值的方式被编码为如下三个Fn trait：<br>（1）FnOnce消费从周围作用域捕获的变量，闭包周围的作用域被称为其环境。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移进闭包。其名称的Once部分代表了闭包不能多次获取相同变量的所有权。<br>（2）FnMut获取可变的借用值，所以可以改变其环境。<br>（3）Fn从其环境获取不可变的借用值。<br>当创建一个闭包时，rust会根据其如何使用环境中的变量来推断我们希望如何引用环境。由于所有闭包都可以被调用至少一次，因此所有闭包都实现了FnOnce。没有移动被捕获变量的所有权到闭包的闭包也实现了FnMut，而不需要对捕获的变量进行可变访问的闭包实现了Fn。</p>
<h3 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h3><p>闭包会为每个参数和返回类型推导一个具体类型，但是不能推导两次。如下错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> example_closure = |x| x;</span><br><span class="line"><span class="keyword">let</span> s = example_closure(<span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> n = example_closure(<span class="number">5</span>); <span class="comment">//报错，尝试推导两次，变成了不同的类型</span></span><br></pre></td></tr></table></figure>
<h3 id="与trait结合"><a href="#与trait结合" class="headerlink" title="与trait结合"></a>与trait结合</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt; </span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calcuation: T,</span><br><span class="line">    value: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(calcuation: T) -&gt; Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calcuation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c = Cacher::new(|x| x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition &#123;</span><br><span class="line">    block</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span>&#123;</span><br><span class="line">  printfln!(<span class="string">&quot;&#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0..=5 包含5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> number&#123;&#125;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>Rust不能从<code>number</code>推断出<code>bool</code>值。另，<code>if</code>后的判断表达式不需要括号。<br>循环可以加上生命期标签，从而直接退出外部循环。例如：<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">`tag</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array &#123;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition &#123;</span><br><span class="line">            <span class="keyword">break</span> `tag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="从块表达式返回值"><a href="#从块表达式返回值" class="headerlink" title="从块表达式返回值"></a>从块表达式返回值</h2><h3 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>if</code>、<code>else</code>返回值的类型必须是相同的。当所有<code>if</code>，<code>else if</code>块无法匹配时，调用任何一个<code>else</code>块，如果无<code>else</code>，则返回<code>()</code>。因此，此代码中的<code>if</code>表达式的<code>else</code>块（虽然没有显式写出）返回值为<code>()</code>，与<code>if</code>块中的<code>i32</code>类型不一致，报<code>E0308</code>错误。举例如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">r</span></span>(n: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="match-let"><a href="#match-let" class="headerlink" title="match let"></a>match let</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="keyword">match</span> food &#123;</span><br><span class="line">        <span class="string">&quot;hotdog&quot;</span> =&gt; <span class="string">&quot;is hotdog&quot;</span>,</span><br><span class="line">        <span class="comment">// 注意，当它只是一个返回表达式时，大括号是可选的</span></span><br><span class="line">        _ =&gt; <span class="string">&quot;is not hotdog&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="comment">// loop 可以被中断以返回一个值。</span></span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//result等于20。</span></span><br></pre></td></tr></table></figure>
<p>避免使用<code>while true &#123;...&#125;</code>，使用<code>loop</code>。Rust使用LLVM，而LLVM没有表达无限循环的方式，因此在某些时候会出错。如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123; x = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>
<p>编译器报错，”use of possibly uninitialised variable”。</p>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p><code>match</code> 是穷尽的，意为所有可能的值都必须被考虑到。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;found zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我们可以匹配多个值</span></span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;found 1 or 2!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我们可以匹配迭代器</span></span><br><span class="line">        <span class="number">3</span>..=<span class="number">9</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;found a number 3 to 9 inclusively&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我们可以将匹配数值绑定到变量</span></span><br><span class="line">        matched_num @ <span class="number">10</span>..=<span class="number">100</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;found &#123;&#125; number between 10 to 100!&quot;</span>, matched_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是默认匹配，如果没有处理所有情况，则必须存在该匹配</span></span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;found something else!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>编译器可以使用跳转表（jump table）来优化match表达式，除了边界检查，在编译后的代码中根本没有分支。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Rust中结构体有：具名结构体、元组结构体、单元结构体。</p>
<h2 id="具名结构体"><a href="#具名结构体" class="headerlink" title="具名结构体"></a>具名结构体</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeaCreature</span></span> &#123;</span><br><span class="line">    animal_type: <span class="built_in">String</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元祖结构体"><a href="#元祖结构体" class="headerlink" title="元祖结构体"></a>元祖结构体</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这仍然是一个在栈上的结构体</span></span><br><span class="line"><span class="keyword">let</span> loc = Location(<span class="number">42</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure>
<h2 id="单元结构体"><a href="#单元结构体" class="headerlink" title="单元结构体"></a>单元结构体</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Marker</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，元组结构体只有一个字段时，称之为<code>New Type</code>模式。</p>
<h1 id="方法（封装特性）"><a href="#方法（封装特性）" class="headerlink" title="方法（封装特性）"></a>方法（封装特性）</h1><p>与函数（function）不同，方法（method）是与特定数据类型关联的函数。</p>
<p><strong>静态方法</strong> — 属于某个类型，调用时使用 <code>::</code> 运算符。</p>
<p><strong>实例方法</strong> — 属于某个类型的实例，调用时使用 <code>.</code> 运算符。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeaCreature</span></span> &#123;</span><br><span class="line">    noise: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> SeaCreature &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_sound</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.noise</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> creature = SeaCreature &#123;</span><br><span class="line">      <span class="comment">// 静态方法</span></span><br><span class="line">        noise: <span class="built_in">String</span>::from(<span class="string">&quot;blub&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, creature.get_sound());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Species</span></span> &#123;</span><br><span class="line">    Crab,</span><br><span class="line">    Octopus,</span><br><span class="line">    Fish,</span><br><span class="line">    Clam</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> ferris.species &#123;</span><br><span class="line">        Species::Crab =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is a crab&quot;</span>,ferris.name),</span><br><span class="line">  			_ =&gt; xxx,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>enum</code> 的元素可以有一个或多个数据类型，从而使其表现得像 C 语言中的<em>联合</em>。</p>
<p>当使用 <code>match</code> 对一个 <code>enum</code> 进行模式匹配时，可以将变量名称绑定到每个数据值。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weapon</span></span> &#123;</span><br><span class="line">    Claw(<span class="built_in">i32</span>, Size),</span><br><span class="line">    Poison(PoisonType),</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line">...&#123;</span><br><span class="line">  ...</span><br><span class="line">  weapon: Weapon::Claw(<span class="number">2</span>, Size::Small),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> ferris.weapon &#123;</span><br><span class="line">  <span class="comment">// num_claws 获取 2</span></span><br><span class="line">    Weapon::Claw(num_claws,size) =&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个部分定义的结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BagOfHolding</span></span>&lt;T&gt; &#123;</span><br><span class="line">    item: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 注意：通过使用泛型，我们创建了编译时创建的类型，使代码更大</span></span><br><span class="line">    <span class="comment">// Turbofish 使之显式化</span></span><br><span class="line">    <span class="keyword">let</span> i32_bag = BagOfHolding::&lt;<span class="built_in">i32</span>&gt; &#123; item: <span class="number">42</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> bool_bag = BagOfHolding::&lt;<span class="built_in">bool</span>&gt; &#123; item: <span class="literal">true</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Rust 也可以推断出泛型的类型！</span></span><br><span class="line">    <span class="keyword">let</span> float_bag = BagOfHolding &#123; item: <span class="number">3.14</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bag_in_bag = BagOfHolding &#123;</span><br><span class="line">        item: BagOfHolding &#123; item: <span class="string">&quot;boom!&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="常用的内置泛型："><a href="#常用的内置泛型：" class="headerlink" title="常用的内置泛型："></a>常用的内置泛型：</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Result</code> 如此常见以至于 Rust 有个强大的操作符 <code>?</code> 来与之配合。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>通常用于函数调用或方法调用的语法不能用于泛型。例如Vec<T>。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;::with_capacity(<span class="number">100</span>); <span class="comment">//error</span></span><br><span class="line">(<span class="number">0</span>..n).collect&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;(); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><br>Rust编译器会建议使用::<T>而不是<T>：<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Vec</span>::&lt;<span class="built_in">i32</span>&gt;::with_capacity(<span class="number">100</span>);</span><br><span class="line">(<span class="number">0</span>..n).collect::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;(); </span><br></pre></td></tr></table></figure><br>符号::&lt;..&gt;称为极速鱼（turbofish）。<br>如果可以推断出类型，推荐使用省略类型参数：<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = (<span class="number">0</span>..n).collect(); </span><br></pre></td></tr></table></figure></T></T></T></p>
<h2 id="option"><a href="#option" class="headerlink" title="option"></a>option</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>Option主要有以下一些用法：</p>
<ul>
<li>初始化值；</li>
<li>作为在整个输入范围内没有定义的函数的返回值；</li>
<li>作为返回值，用<code>None</code>表示出现的简单错误；</li>
<li>作为结构体的可选字段；</li>
<li>作为结构体中可借出或者是可载入的字段；</li>
<li>作为函数的可选参数；</li>
<li>代表空指针；</li>
<li>用作复杂情况的返回值。</li>
</ul>
<h3 id="值复制方法"><a href="#值复制方法" class="headerlink" title="值复制方法"></a>值复制方法</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">123u8</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;&amp;<span class="built_in">u8</span>&gt; = <span class="literal">Some</span>(&amp;x);</span><br><span class="line"><span class="keyword">let</span> z = y.copied();</span><br></pre></td></tr></table></figure>
<p>copied将引用转换为值。</p>
<h1 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h1><p><code>Vec</code> 有一个形如 <code>iter()</code> 的方法可以为一个 vector 创建迭代器，这允许我们可以轻松地将 vector 用到 <code>for</code> 循环中去。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 我们可以显式确定类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i32_vec = <span class="built_in">Vec</span>::&lt;<span class="built_in">i32</span>&gt;::new(); <span class="comment">// turbofish &lt;3</span></span><br><span class="line">    i32_vec.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动检测类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> float_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">    float_vec.push(<span class="number">1.3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宏！</span></span><br><span class="line">    <span class="keyword">let</span> string_vec = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;World&quot;</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> string_vec.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内存细节：</p>
<ul>
<li><code>Vec</code> 是一个结构体，但是内部其实保存了在堆上固定长度数据的引用。</li>
<li>一个 vector 开始有默认大小容量，当更多的元素被添加进来后，它会重新在堆上分配一个新的并具有更大容量的定长列表。（类似 C++ 的 vector）。所以使用<code>Vec::with_capacity</code>而不是<code>Vec::new</code>可以从速度上改进。</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器实现了<code>Iterator</code>（<code>trait</code>），定义于标准库中。该<code>trait</code>定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">	<span class="comment">//省略其它内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果希望迭代可变引用，可以使用<code>iter_mut</code>。</p>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>Slice是对一个数组的引用片段，代表一个指向数组起始位置的指针和数组长度。</p>
<p>Slice是一种新的类型，而不是简单的一个引用而已。slice写作不指定长度的[T]，而&amp;[T]是对切片的引用，只是通常把&amp;[T]和&amp;str这样的引用类型直接称为引用 。切片永远只能按照引用传递。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: [<span class="built_in">i32</span>;<span class="number">2</span>]=[<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>((&amp;arr).len(), <span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;arr.len(), &amp;<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="str（字符串切片）"><a href="#str（字符串切片）" class="headerlink" title="str（字符串切片）"></a>str（字符串切片）</h2><p>字符串常量是&amp;’static str。str字符串是固定长度的，String字符串是可变长度的。</p>
<p><code>let hello_world = &quot;Hello, World!&quot;;</code> 声明了一个 <code>&amp;str</code>类型；</p>
<p><code>let hello_world: &amp;&#39;static str = &quot;Hello, world!&quot;;</code> hello_world 与 字符串常量一样。</p>
<h3 id="utf8"><a href="#utf8" class="headerlink" title="utf8"></a>utf8</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &amp;a[3..7]表示螃蟹</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;hi 🦀&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chars[3]表示螃蟹，chars[i]表示一个字符，每个char占4字节</span></span><br><span class="line"><span class="keyword">let</span> chars = <span class="string">&quot;hi 🦀&quot;</span>.chars().collect::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">char</span>&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String不能用index访问的原因：</p>
<ul>
<li>避免根据UTF-8编码得到的长度与期望的不一致；</li>
<li>根据index访问需要从头遍历（在Rust中需要判断有效字符数量），所以访问的时间复杂度不为<code>O(1)</code>。</li>
</ul>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> haiku: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">        I write, erase, rewrite</span></span><br><span class="line"><span class="string">        - Katsushika Hokusai&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, haiku);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;hello \</span></span><br><span class="line"><span class="string">world&quot;</span>) <span class="comment">// notice that the spacing before w is ignored</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始字符串（raw），使反斜杠转义无效</span></span><br><span class="line"><span class="comment">// 如果需要包含双引号，需要加&#x27;#&#x27;对，如果要包含#，则需要多加一对&#x27;#&#x27;</span></span><br><span class="line"><span class="keyword">let</span> a: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = r#<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>advice<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            Raw strings are useful for some situations.</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &quot;</span>#;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件读取大量字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="number">00_</span>html = <span class="built_in">include_str!</span>(<span class="string">&quot;00_en.html&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>单引号无须转义，双引号需要。</p>
<h3 id="在内存中的存储"><a href="#在内存中的存储" class="headerlink" title="在内存中的存储"></a>在内存中的存储</h3><p>字符串是Unicode字符序列，但是在内存中不是以char数组形式存储的，是使用utf-8可变宽度编码存储的。<br>String有一个在堆上的可伸缩缓冲区存储utf-8文本。&amp;str是包含实际数据的地址及其长度的胖指针。字符串字面量就是一个引用预分配文本的&amp;str，通常和程序的机器码一起存储在只读内存中。</p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>对于==和!=，如果两个字符串包含的字符相同、顺序也相同，那么它们就是相等的，无论指向地址是否相同。</p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">HashMap::new();</span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = keys.iter().zip(values.iter()).collect(); </span><br></pre></td></tr></table></figure>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> value = ss.get(&amp;key); </span><br></pre></td></tr></table></figure>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><code>for (key, value) in &amp;ss</code></p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">ss.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">20</span>);<span class="comment">//会将之前Blue对应的值覆盖掉</span></span><br><span class="line">ss.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">20</span>); <span class="comment">// 没有实体时插入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据旧值更新</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h1><p>所有权是Rust的特性。所有权解决了堆栈分配与回收问题。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><div class="table-container">
<table>
<thead>
<tr>
<th>语言</th>
<th>内存回收机制</th>
</tr>
</thead>
<tbody>
<tr>
<td>其他语言</td>
<td>GC会跟踪声明的变量，当它不再被使用时，自动清除。如果没有GC，程序员负责在恰当的时候释放这段申请的内存。</td>
</tr>
<tr>
<td>Rust</td>
<td>使用RAII(“资源获取即初始化”)，在变量<code>invalid</code>时，调用<code>drop</code>回收。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Move，Copy，Clone"><a href="#Move，Copy，Clone" class="headerlink" title="Move，Copy，Clone"></a>Move，Copy，Clone</h2><h3 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure>
<p><code>s1</code>移动到了<code>s2</code>，不仅仅是<code>shallow copy</code>，<code>s1</code>还被置为<code>invalid</code>了。栈上的s1对象和s2对象进行按位浅拷贝，堆上数据不变。</p>
<p>将所有者作为参数传递给函数时，其所有权将移交至该函数的参数。 在一次<strong>移动</strong>后，原函数中的变量将无法再被使用。在<strong>移动</strong>期间，所有者的堆栈值将会被复制到函数调用的参数堆栈中。</p>
<p>Rust不会自动创建“深拷贝”，需要自己用<code>Clone()</code>。但是，如果实现了<code>Copy</code>的<code>trait</code>，那么值会被复制入栈。</p>
<h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><p>实现Copy的类型在堆上没有资源，值完全处于栈上。浅拷贝后，源与目标对象都可以访问，是独立的数据。为了<code>#[derive(Copy, Clone)]</code>工作，成员也必须实现<code>Copy</code>。</p>
<blockquote>
<p>在派生语句中的Clone是需要的，因为Copy的定义类似这样:pub trait Copy:Clone {}，即要实现Copy需要先实现Clone</p>
</blockquote>
<p>Copy与Drop不能同时存在。</p>
<h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h3><p>变量在离开作用范围时，编译器会自动销毁变量，如果变量类型有<code>Drop</code> trait，就先调用<code>Drop::drop</code>方法，做资源清理，一般会回收heap内存等资源，然后再收回变量所占用的stack内存。如果变量没有<code>Drop</code> trait，那就只收回stack内存。</p>
<p>如果类型实现了<code>Copy</code> trait，在copy语义中并不会调用<code>Clone::clone</code>方法，不会做deep copy，那就会出现两个变量同时拥有一个资源（比如说是heap内存等），在这两个变量离开作用范围时，会分别调用<code>Drop::drop</code>方法释放资源，这就会出现double free错误。</p>
<h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h3><p>帮助实现“深拷贝”。</p>
<h2 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h2><p>释放是分级进行的。删除一个结构体时，结构体本身会先被释放，紧接着才分别释放相应的子结构体并以此类推。</p>
<p>内存细节：</p>
<ul>
<li>Rust 通过自动释放内存来帮助确保减少内存泄漏。</li>
<li>每个内存资源仅会被释放一次。</li>
</ul>
<h2 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h2><p>引用默认也是不可变的。可变引用才可以修改被引用的值。已经被引用的变量，其所有权不可以被移动。</p>
<h3 id="可变引用-amp-mut"><a href="#可变引用-amp-mut" class="headerlink" title="可变引用(&amp;mut)"></a>可变引用(&amp;mut)</h3><ul>
<li>可变引用只能出现一次，避免数据竞争。</li>
<li>已有不可变引用，可变引用就不能再出现。</li>
</ul>
<p>共享不可变引用和可变引用互斥，从根基上就不会存在数据争用，让并发更加安全。</p>
<h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><p>使用 <code>&amp;mut</code> 引用时, 你可以通过 <code>*</code> 操作符来修改其指向的值。 你也可以使用 <code>*</code> 操作符来对所拥有的值进行拷贝（前提是该值可以被拷贝）。</p>
<p>操作符”<code>.</code>“可以自动解引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = Foo &#123; value: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> ref_ref_ref_f = &amp;&amp;&amp;f;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ref_ref_ref_f.value);</span><br></pre></td></tr></table></figure>
<h3 id="解引用多态与可变性交互"><a href="#解引用多态与可变性交互" class="headerlink" title="解引用多态与可变性交互"></a>解引用多态与可变性交互</h3><p>解引用多态有如下三种情况：</p>
<ul>
<li>当 T: Deref<Target=U> 时从 &amp;T 到 &amp;U。</Target=U></li>
<li>当 T: DerefMut<Target=U> 时从 &amp;mut T 到 &amp;mut U。</Target=U></li>
<li>当 T: Deref<Target=U> 时从 &amp;mut T 到 &amp;U。（注意：此处反之是不可能的）</Target=U></li>
</ul>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期的主要目标是避免悬垂引用，大部分时候是可以隐含并且被推断的。</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ol>
<li>引用的生命期最长的限制：&amp;x不能比x本身还“长寿”，即x的生命期必须涵盖其引用的生命期，在x销毁前，&amp;x必须已经销毁；</li>
<li>引用的生命期最短的约束：<code>let r = &amp;x</code>，&amp;x的生命期要涵盖r的生命期；<br>这是Rust评判所有代码的流程的本质。由于生命周期的存在，Rust中不可能写出与函数签名意图不匹配的函数来，例如想把引用保存到全局变量中是不可能的，所以Rust函数签名始终反映函数体的行为。<h2 id="显式生命周期"><a href="#显式生命周期" class="headerlink" title="显式生命周期"></a>显式生命周期</h2></li>
</ol>
<p>尽管 Rust 不总是在代码中将它展示出来，但编译器会理解每一个变量的生命周期并进行验证以确保一个引用不会有长于其所有者的存在时间。 同时，函数可以通过使用一些符号来参数化函数签名，以帮助界定哪些参数和返回值共享同一生命周期。 生命周期注解总是以 <code>&#39;</code> 开头，例如 <code>&#39;a</code>，<code>&#39;b</code> 以及 <code>&#39;c</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 foo 和返回值共享同一生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_something</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(foo: &amp;<span class="symbol">&#x27;a</span> Foo) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;foo.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo_b 和返回值共享同一生命周期</span></span><br><span class="line"><span class="comment">// foo_a 则拥有另一个不相关联的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_something</span></span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(foo_a: &amp;<span class="symbol">&#x27;a</span> Foo, foo_b: &amp;<span class="symbol">&#x27;b</span> Foo) -&gt; &amp;<span class="symbol">&#x27;b</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, foo_a.x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, foo_b.x);</span><br><span class="line">    <span class="keyword">return</span> &amp;foo_b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量的范围也可以被限制在一个函数内</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> SECRET: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;swordfish&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串字面值拥有 &#x27;static 生命周期</span></span><br><span class="line"><span class="keyword">let</span> msg: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="隐式生命周期"><a href="#隐式生命周期" class="headerlink" title="隐式生命周期"></a>隐式生命周期</h2><p>三条规则确定不需要生命周期注解：</p>
<ul>
<li>第一条规则是：每一个是引用的参数都有它自己的生命周期参数。</li>
<li>第二条规则是：如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code>。 </li>
<li>第三条规则是：在struct的impl语句中，如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数。第三条规则使得方法更容易读写，因为只需更少的符号。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="built_in">str</span>::FromStr;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; FromStr <span class="keyword">for</span> Wrapper&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Err</span></span> = ();</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from_str</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>, Self::<span class="literal">Err</span>&gt; &#123;</span><br><span class="line">        <span class="literal">Ok</span>(Wrapper(s))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，fn from_str函数显然是符合第二条规则，也就是说入参s: &amp;str的生命周期被赋予为输出的生命周期。但是，输出参数中的Self对应的类型为结构体Wrapper，而Wrapper是有生命周期的限制的，此时编译器不知道如何判断，因此报错。</p>
<h2 id="结构体生命周期"><a href="#结构体生命周期" class="headerlink" title="结构体生命周期"></a>结构体生命周期</h2><p>如果结构体成员含有引用类型，则需要显式指定生命周期。如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StuA</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的，在方法中，也需要声明结构体的生命周期：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;b</span>&gt; StuA&lt;<span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 隐式生命周期第二条规则</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">do_something</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">do_something2</span></span>(&amp;<span class="keyword">self</span>, s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span>&#123;</span><br><span class="line">      <span class="comment">// 隐式生命周期第三条规则</span></span><br><span class="line">    <span class="comment">//相当于fn do_something2&lt;&#x27;b&gt;(&amp;&#x27;b self, s: &amp;str) -&gt; &amp;&#x27;b str&#123;</span></span><br><span class="line">      <span class="comment">// self.name与self生命周期相同，✅</span></span><br><span class="line">        <span class="keyword">self</span>.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回值生命周期与s相同，而不是self，所以需要显式指定</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">do_something3</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&#123;</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Trait（多态）"><a href="#Trait（多态）" class="headerlink" title="Trait（多态）"></a>Trait（多态）</h1><p>在Rust中，trait是唯一的接口抽象方式。Rust中没有继承，贯彻的是组合优于继承和面向接口编程的思想。</p>
<p><a href="https://munan.tech/2019/09/05/Rust-trait/">trait相关详情</a></p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><p>内部支持Markdown标记，也支持对文档中的示例代码进行测试，可以用rustdoc生成HTML文档。</p>
<ul>
<li>/// ：生成库文档，用于函数或结构体的说明；</li>
<li>//! ：生成库文档，用于说明整个模块的功能；</li>
</ul>
<h1 id="println-宏"><a href="#println-宏" class="headerlink" title="println!宏"></a>println!宏</h1><ul>
<li><code>println!(&quot;&#123;&#125;&quot;, 2)</code>，nothing表示Display；</li>
<li><code>println!(&quot;&#123;:?&#125;&quot;, 2)</code>，？表示Debug；</li>
<li>o代表八进制，x/X表示十六进制，b表示二进制；</li>
<li>p代表指针；</li>
<li>e/E表示指数；</li>
</ul>
<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><p>Rust 程序有 3 个存放数据的内存区域：</p>
<ul>
<li><strong>数据内存</strong> - 对于固定大小和<strong>静态</strong>（即在整个程序声明周期中都存在）的数据。 例如 “Hello World”字面值常量，该文本的字节只能读取，因此它们位于该区域中。 编译器对这类数据做了很多优化，由于位置已知且固定，因此通常认为编译器使用起来非常快。</li>
<li><strong>栈内存</strong> - 对于在函数中声明为变量的数据。 在函数调用期间，内存的位置不会改变，因为编译器可以优化代码，所以栈数据使用起来非常快。</li>
<li><strong>堆内存</strong> - 对于在程序运行时创建的数据。 此区域中的数据可以添加、移动、删除、调整大小等。由于它的动态特性，通常认为它使用起来比较慢， 但是它允许更多创造性的内存使用。当数据添加到该区域时，我们称其为<strong>分配</strong>。 从本区域中删除 数据后，我们将其称为<strong>释放</strong>。</li>
</ul>
<h2 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h2><p>对齐规则：</p>
<ul>
<li>每种类型都有一个数据对齐属性。在X86平台上u64和f64都是按照32位对齐的。</li>
<li>一种类型的大小是它对齐属性的整数倍，这保证了这种类型的值在数组中的偏移量都是其类型尺寸的整数倍，可以按照偏移量进行索引。需要注意的是，动态尺寸类型的大小和对齐可能无法静态获取。</li>
<li>结构体的对齐属性等于它所有成员的对齐属性中最大的那个。Rust会在必要的位置填充空白数据，以保证每一个成员都正确地对齐，同时整个类型的尺寸是对齐属性的整数倍。</li>
<li>不保证数据填充和成员顺序，编译器可能进行优化。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">u8</span>,</span><br><span class="line">    b: <span class="built_in">u32</span>,</span><br><span class="line">    c: <span class="built_in">u16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照前3条规则，A的大小应该为12字节，而实际上编译后可能只有8字节。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>原生指针：</p>
<ul>
<li><code>*const T</code> - 指针常量。</li>
<li><code>*mut T</code> - 可变指针。</li>
</ul>
<p>取得指针所指地址内的数据，需要在<code>unsafe&#123;...&#125;</code>中，因为不能保证该原生指针指向有效数据。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特征在于其实现了Deref和Drop trait。</p>
<ul>
<li>Deref trait允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用，又用于智能指针的代码。</li>
<li>Drop trait允许我们自定义当智能指针离开作用域时执行的代码。</li>
</ul>
<h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h3><p><code>Box</code>将数据从栈上移动到堆，栈上存放指向堆数据的指针。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ocean</span></span> &#123;</span><br><span class="line">    animals: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> NoiseMaker&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ocean = Ocean &#123;</span><br><span class="line">        animals: <span class="built_in">vec!</span>[<span class="built_in">Box</span>::new(ferris), <span class="built_in">Box</span>::new(sarah)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>适用于：</p>
<ul>
<li>当有一个在编译时未知大小的类型，而又需要在确切大小的上下文中使用这个类型值的时候；（举例子：在一个list环境下，存放数据，但是每个元素的大小在编译时又不确定）；</li>
<li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候；</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定trait而不是其具体类型时。</li>
</ul>
<h3 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc</h3><p>引用计数指针，将数据从栈上移动到堆。允许其他<code>Rc</code>指针<strong>不可变引用</strong>同一个数据。单线程。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> heap_pie = Rc::new(Pie);</span><br><span class="line"><span class="keyword">let</span> heap_pie2 = heap_pie.clone();</span><br><span class="line"></span><br><span class="line">heap_pie2.eat();</span><br><span class="line">heap_pie.eat();</span><br><span class="line"><span class="comment">// all reference count smart pointers are dropped now</span></span><br><span class="line"><span class="comment">// the heap data Pie finally deallocates</span></span><br></pre></td></tr></table></figure>
<h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h3><p>一个智能指针容器。可变与不可变引用都可以，引用规则与之前一样。单线程。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// RefCell validates memory safety at runtime</span></span><br><span class="line">    <span class="comment">// notice: pie_cell is not mut!</span></span><br><span class="line">    <span class="keyword">let</span> pie_cell = RefCell::new(Pie&#123;slices:<span class="number">8</span>&#125;);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// but we can borrow mutable references!</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> mut_ref_pie = pie_cell.borrow_mut();</span><br><span class="line">        mut_ref_pie.eat();</span><br><span class="line">        mut_ref_pie.eat();</span><br><span class="line">        <span class="comment">// mut_ref_pie is dropped at end of scope</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// now we can borrow immutably once our mutable reference drops</span></span><br><span class="line">     <span class="keyword">let</span> ref_pie = pie_cell.borrow();</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; slices left&quot;</span>,ref_pie.slices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以拥有一个表面上不可变的List，但是通过<code>RefCell&lt;T&gt;</code>中提供内部可变性方法来在需要时修改数据的方式。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, RefCell::new(Weak::new())));</span><br><span class="line">  <span class="comment">// 1, a strong count = 1, weak count = 0</span></span><br><span class="line">	<span class="comment">// 1, a tail = Some(RefCell &#123; value: (Weak) &#125;)</span></span><br><span class="line">    <span class="keyword">let</span> b = Rc::new(Cons(<span class="number">10</span>, RefCell::new(Weak::new())));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(link) = b.tail() &#123;</span><br><span class="line">        *link.borrow_mut() = Rc::downgrade(&amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 2, a strong count = 1, weak count = 1</span></span><br><span class="line">	<span class="comment">// 2, b strong count = 1, weak count = 0</span></span><br><span class="line">	<span class="comment">// 2, b tail = Some(RefCell &#123; value: (Weak) &#125;)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(link) = a.tail() &#123;</span><br><span class="line">        *link.borrow_mut() = Rc::downgrade(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3, a strong count = 1, weak count = 1</span></span><br><span class="line">	<span class="comment">// 3, b strong count = 1, weak count = 1</span></span><br><span class="line">	<span class="comment">// 3, a tail = Some(RefCell &#123; value: (Weak) &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：<br>（1）弱引用通过<code>Rc::downgrade</code>传递Rc实例的引用，调用<code>Rc::downgrade</code>会得到<code>Weak&lt;T&gt;</code>类型的智能指针，同时将weak_count加1（不是将strong_count加1）。<br>（2）区别在于 <code>weak_count</code> 无需计数为 0 就能使 Rc 实例被清理。只要<code>strong_count</code>为0就可以了。<br>（3）可以通过<code>Rc::upgrade</code>方法返回<code>Option&lt;Rc&lt;T&gt;&gt;</code>对象。</p>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>智能指针容器，可变与不可变引用都可以。可以用来编排多核CPU线程任务。</p>
<h2 id="内部可变性-1"><a href="#内部可变性-1" class="headerlink" title="内部可变性"></a>内部可变性</h2><p>组合智能指针：<code>Rc&lt;Vec&lt;Foo&gt;&gt;</code>，<code>Rc&lt;RefCell&lt;Foo&gt;&gt;</code>, <code>Arc&lt;Mutex&lt;Foo&gt;&gt;</code>。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> 与 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code>的相似性</p>
<p>（1）<code>Mutex&lt;T&gt;</code>提供内部可变性，类似于RefCell；</p>
<p>（2）<code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code>是非线程安全的，而<code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code>是线程安全的。</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>结构体、枚举。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在Rust中，使用pub关键字来标记模块、类型、函数和方法是公有的，默认情况下一切都是私有的。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Rust不支持继承。但是Rust可以通过trait进行行为共享。</p>
<h2 id="trait对象"><a href="#trait对象" class="headerlink" title="trait对象"></a>trait对象</h2><p>1、trait对象动态分发<br>（1）对泛型类型使用trait bound编译器进行的方式是单态化处理，单态化的代码进行的是静态分发（就是说编译器在编译的时候就知道调用了什么方法）。<br>（2）使用 trait 对象时，Rust 必须使用动态分发。编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。</p>
<p>2、trait对象要求对象安全<br>只有 对象安全（object safe）的 trait 才可以组成 trait 对象。trait的方法满足以下两条要求才是对象安全的：</p>
<ul>
<li>返回值类型不为 Self（例如<code>Clone</code>不能作为对象安全的trait对象）</li>
<li>方法没有任何泛型类型参数</li>
</ul>
<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名的主要用途是减少重复。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = std::result::<span class="built_in">Result</span>&lt;T, std::io::Error&gt;;<span class="comment">//result&lt;T, E&gt; 中 E 放入了 std::io::Error</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Write</span></span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">usize</span>&gt;; </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">flush</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从不返回的never-type"><a href="#从不返回的never-type" class="headerlink" title="从不返回的never type"></a>从不返回的never type</h2><p>Rust 有一个叫做 <code>!</code> 的特殊类型。在类型理论术语中，它被称为 empty type，因为它没有值。我们更倾向于称之为 never type。在函数不返回的时候充当返回值。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123; </span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new(); </span><br><span class="line">        io::stdin().read_line(&amp;<span class="keyword">mut</span> guess) .expect(<span class="string">&quot;Failed to read line&quot;</span>); </span><br><span class="line">        <span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123; </span><br><span class="line">            <span class="literal">Ok</span>(num) =&gt; num, </span><br><span class="line">            <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>, <span class="comment">//continue 的值是 !。</span></span><br><span class="line">            <span class="comment">//当 Rust 要计算 guess 的类型时，它查看这两个分支。</span></span><br><span class="line">            <span class="comment">//前者是 u32 值，而后者是 ! 值。</span></span><br><span class="line">            <span class="comment">//因为 ! 并没有一个值，Rust 决定 guess 的类型是 u32</span></span><br><span class="line">            &#125;;         </span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess); </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p>说明：never type 可以强转为任何其他类型。允许 match 的分支以 continue 结束是因为 continue 并不真正返回一个值；相反它把控制权交回上层循环，所以在 Err 的情况，事实上并未对 guess 赋值。</p>
<h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>动态大小类型（dynamically sized types），有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。</p>
<h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误代码</span></span><br><span class="line"><span class="comment">// let s1: str = &quot;Hello there!&quot;; </span></span><br><span class="line"><span class="comment">// let s2: str = &quot;How&#x27;s it going?&quot;;</span></span><br><span class="line"><span class="comment">// 正确代码为：</span></span><br><span class="line"><span class="keyword">let</span> s1: &amp;<span class="built_in">str</span> = <span class="string">&quot;Hello there!&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s2: &amp;<span class="built_in">str</span> = <span class="string">&quot;How&#x27;s it going?&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>&amp;str 则是 两个 值：str 的地址和其长度。这样，&amp;str 就有了一个在编译时可以知道的大小：它是 usize 长度的两倍。也就是说，无论字符串是多大，&amp;str的大小我们总是知道的。<br>因此，引出动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。如：Box 或 Rc、&amp;str等。</p>
<h3 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h3><p>每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 &amp;Trait 或 Box（Rc 也可以）。</p>
<h3 id="Sized-trait"><a href="#Sized-trait" class="headerlink" title="Sized trait"></a>Sized trait</h3><p>为了处理 DST，Rust 用Sized trait 来决定一个类型的大小是否在编译时可知。这个 trait 自动为编译器在编译时就知道大小的类型实现。</p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust基础</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadPool</title>
    <url>/blog/2c84c81.html</url>
    <content><![CDATA[<h1 id="线程池-ThreadPoolExecutor"><a href="#线程池-ThreadPoolExecutor" class="headerlink" title="线程池 ( ThreadPoolExecutor)"></a>线程池 ( ThreadPoolExecutor)</h1><ul>
<li>线程池是为了避免线程频繁的创建和销毁带来的性能消耗，而建立的一种池化技术，它是把已创建的线程放入“池”中，当有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度。<a id="more"></a>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110704.png" alt="api"></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>corePoolSize</code>表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值</p>
</li>
<li><p><code>maximumPoolSize</code>表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 <code>corePoolSize</code>，此值只有在任务比较多，且不能存放在任务队列时，才会用到</p>
</li>
<li><p><code>keepAliveTime</code> 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁到等于<code>corePoolSize</code> 为止，如果 <code>maximumPoolSize</code> 等于 <code>corePoolSize</code>，那么线程池在空闲的时候也不会销毁任何线程</p>
</li>
<li><p><code>unit</code>表示存活时间的单位，它是配合 <code>keepAliveTime</code>参数共同使用的</p>
</li>
<li><p><code>workQueue</code>表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行</p>
</li>
<li><p><code>threadFactory</code> 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的线程创建工厂，需要实现 ThreadFactory 接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon()) </span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>); <span class="comment">// 创建一个非守护线程</span></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY); <span class="comment">// 线程优先级设置为默认值</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RejectedExecutionHandler</code> 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列<code>workQueue</code> 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制</p>
</li>
<li><p><code>ctl</code>：控制状态的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用一个 AtomicInteger 包装两个字段:</p>
<ul>
<li>高 3 位保存 runState，低 29 位保存 workerCount</li>
</ul>
<ul>
<li><p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源</p>
</li>
<li><p>workerCount: 有效线程数</p>
</li>
<li><p>runState: 线程池的运行状态</p>
<ul>
<li>定义<ul>
<li><strong>RUNNING</strong>: 接受新任务并处理排队的任务</li>
<li><strong>SHUTDOWN</strong>: 拒绝接受新任务, 但是会处理还在排队的任务</li>
<li><strong>STOP</strong>: 拒绝接受新任务, 也不处理排队中任务, 并且会中断正在执行的任务</li>
<li><strong>TIDYING</strong>: 所有任务都已经停止, workerCount 为 0, 转换为状态 <strong>TIDYING</strong> 的线程将运行 terminated() 方法</li>
<li><strong>TERMINATED</strong>: terminated() 执行完毕</li>
</ul>
</li>
</ul>
<ul>
<li><p>这些值之间的数字顺序很重要，可以进行有序的比较</p>
</li>
<li><p>runState 随着时间逐步增加，但不一定达到每个状态, 过渡的顺序为:</p>
</li>
<li><ul>
<li><strong>RUNNING</strong> -&gt; <strong>SHUTDOWN</strong>, 在调用<code>shutdown()</code> 时，可能隐藏在<code>finalize()</code> 中调用</li>
<li>(<strong>RUNNING</strong> or <strong>SHUTDOWN</strong>) -&gt; <strong>STOP</strong>, 在调用 <code>shutdownNow()</code>时</li>
<li><strong>SHUTDOWN</strong> -&gt; <strong>TIDYING</strong>, 当队列和池子内的任务都为空时</li>
<li><strong>STOP</strong> -&gt; <strong>TIDYING</strong>, 当池子内的任务为空时</li>
<li><strong>TIDYING</strong> -&gt; <strong>TERMINATED</strong>, 当 terminated() 执行完毕时</li>
</ul>
</li>
<li><p>线程在 <code>awaitTermination()</code>中等待, 将在状态变为 <strong>TERMINATED</strong> 时返回</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h1><p>线程不是越多越好！</p>
<ol>
<li>线程在java中是一个对象，更是操作系统的资源，创建、销毁需要消耗资源；</li>
<li>线程过多，会消耗很多的内存；</li>
<li>操作系统需要频繁切换线程上下文，影响性能。</li>
</ol>
<h2 id="如何确定数量"><a href="#如何确定数量" class="headerlink" title="如何确定数量"></a>如何确定数量</h2><p>计算型任务：cpu数量的1-2倍；<br>IO型任务：根据具体的IO阻塞时长考虑</p>
<h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110710.png" alt="workorder"></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul>
<li>接口Executor：定义了执行任务的<code>execute()</code>；</li>
<li>接口ExecutorService：继承了接口Executor，拓展了Callable、Future、关闭方法；</li>
<li>接口ScheduledExecutorService：继承了接口ExecutorService，增加了定时任务相关方法；</li>
<li>实现类ThreadPoolExecutor：基础、标准的线程池实现；</li>
<li>实现类ScheduledThreadPoolExecutor：继承了实现类ThreadPoolExecutor，实现了ScheduledExecutorService中相关定时任务的方法。</li>
</ul>
<p>创建一个核心线程数量5，最大数量10，加开线程存活5秒，等待队列3的线程池，最大容纳13个任务：<code>new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(3));</code></p>
<h2 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前工作的线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 创建新的线程执行此任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查线程池是否处于运行状态，如果是则把任务添加到队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次检查线程池是否处于运行状态，防止在第一次校验通过后线程池关闭</span></span><br><span class="line">        <span class="comment">// 如果是非运行状态，则将刚加入队列的任务移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池的线程数为 0 时（当 corePoolSize 设置为 0 时会发生）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 新建线程执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心线程都在忙且队列都已爆满，尝试新启动一个线程执行失败</span></span><br><span class="line">    <span class="comment">// addWorker(Runnable firstTask, boolean core),core为false时比较maximumPoolSize</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) </span><br><span class="line">        <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>是否达到核心线程数量？没达到，创建一个工作线程来执行任务；</li>
<li>工作队列是否已经满？没满，则将新提交的任务存储到队列；</li>
<li>是否达到线程池最大数量？没达到，则创建一个新的工作线程来执行任务（加开的线程如果没有任务会自动销毁）；</li>
<li>最后，拒绝执行。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110738.png" alt="execute"></p>
<h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><ul>
<li><p><code>firstTask</code>，线程应首先运行的任务，如果没有则可以设置为 null</p>
</li>
<li><p><code>core</code>，判断是否可以创建线程的阀值（最大值），如果等于 true 则表示使用 corePoolSize 作为阀值，false 则表示使用 maximumPoolSize 作为阀值</p>
</li>
<li><p>```java<br>private boolean addWorker(Runnable firstTask, boolean core) {<br>  retry:<br>  for (;;) {</p>
<pre><code>int c = ctl.get();
int rs = runStateOf(c);

if (rs &gt;= SHUTDOWN &amp;&amp; // 线程池是否已停止
    ! (rs == SHUTDOWN &amp;&amp; // 线程池是否正在停止
       firstTask == null &amp;&amp; ! workQueue.isEmpty()) // 线程是否用于执行剩余任务
   )
  return false;

for (;;) &#123;
  int wc = workerCountOf(c);
  if (wc &gt;= CAPACITY || // 线程数是否超过容量
      wc &gt;= (core ? corePoolSize : maximumPoolSize)) // 是否超过判断的阀值
    return false;
  if (compareAndIncrementWorkerCount(c)) // CAS 尝试登记线程数
    break retry; // 登记成功
  c = ctl.get();  // Re-read ctl
  if (runStateOf(c) != rs) // 判断线程池状态运行过程中是否有改变
    continue retry;
  // else CAS failed due to workerCount change; retry inner loop
&#125;
</code></pre><p>  }</p>
<p>  boolean workerStarted = false;<br>  boolean workerAdded = false;<br>  Worker w = null;<br>  try {</p>
<pre><code>w = new Worker(firstTask);
final Thread t = w.thread;
if (t != null) &#123;
  final ReentrantLock mainLock = this.mainLock;
  mainLock.lock();
  try &#123;
    // Recheck while holding lock.
    // Back out on ThreadFactory failure or if
    // shut down before lock acquired.
    int rs = runStateOf(ctl.get());

    if (rs &lt; SHUTDOWN ||
        (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;
      if (t.isAlive()) // precheck that t is startable
        throw new IllegalThreadStateException();
      workers.add(w); // 持有引用
      int s = workers.size();
      if (s &gt; largestPoolSize)
        largestPoolSize = s; // 更新创建过的最大线程数
      workerAdded = true;
    &#125;
  &#125; finally &#123;
    mainLock.unlock();
  &#125;
  if (workerAdded) &#123;
    t.start(); // 启动线程, 而线程的 run 方法就是执行 runWorker()
    workerStarted = true;
  &#125;
&#125;
</code></pre><p>  } finally {</p>
<pre><code>if (! workerStarted)
  addWorkerFailed(w);
</code></pre><p>  }<br>  return workerStarted;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![addworker](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;JNhua&#x2F;blog_images@master&#x2F;img&#x2F;20201029110745.png)</span><br><span class="line"></span><br><span class="line">## Worker</span><br><span class="line"></span><br><span class="line">### 构造函数</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123;</span><br><span class="line">    final Thread thread; &#x2F;&#x2F; Worker 持有的线程</span><br><span class="line">    Runnable firstTask; &#x2F;&#x2F; 初始化的任务，可以为 null</span><br><span class="line">  </span><br><span class="line">  Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-1); &#x2F;&#x2F; inhibit interrupts until runWorker</span><br><span class="line">    this.firstTask &#x3D; firstTask;</span><br><span class="line">    this.thread &#x3D; getThreadFactory().newThread(this);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 允许中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果task为空，则通过getTask来获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110754.png" alt="runworkerflow"></p>
<p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images@master/img/20201029110802.png" alt="runworker"></p>
<h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// timeOut 表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. 线程池已经 stop</span></span><br><span class="line"><span class="comment">         * 2. 线程池处于 shutdown 并且队列为空</span></span><br><span class="line"><span class="comment">         * 如果以上任何条件满足，则将 workerCount 减 1 并返回 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed 用于判断是否需要进行超时控制</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut 默认是 false，也就是核心线程不允许进行超时</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * wc &gt; maximumPoolSize 是因为可能通过 setMaximumPoolSize 修改过 maximumPoolSize</span></span><br><span class="line"><span class="comment">         * timed &amp;&amp; timedOut 如果为 true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">         * 接下来判断，如果有效线程数量大于 1，或者阻塞队列是空的，那么尝试将 workerCount 减 1</span></span><br><span class="line"><span class="comment">         * 如果减 1 失败，则返回重试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 根据 timed 来判断，如果为 true，则通过阻塞队列的 poll 方法进行超时控制</span></span><br><span class="line"><span class="comment">             * 如果在 keepAliveTime 时间内没有获取到任务，则返回 null</span></span><br><span class="line"><span class="comment">             * 否则通过 take 方法，如果这时队列为空，则 take 方法会阻塞直到队列不为空。</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 如果 r == null，说明已经超时，timedOut 设置为 true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置 timedOut 为 false 并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承-AQS-原因分析"><a href="#继承-AQS-原因分析" class="headerlink" title="继承 AQS 原因分析"></a><strong>继承 AQS 原因分析</strong></h3><p>Worker 是通过继承 AQS，使用 AQS 来实现独占锁这个功能。没有使用可重入锁 ReentrantLock，而是使用 AQS，为的就是实现<strong>不可重入</strong>的特性去反应线程现在的执行状态</p>
<ol>
<li>lock 方法一旦获取了独占锁，表示当前线程正在执行任务中</li>
<li>如果正在执行任务，则不应该中断线程</li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断</li>
<li>线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程，interruptIdleWorkers 方法会使用 tryLock 方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收</li>
<li>之所以设置为不可重入，是因为我们不希望任务在调用像 setCorePoolSize 这样的线程池控制方法时重新获取锁。如果使用 ReentrantLock，它是可重入的，这样如果在任务中调用了如 setCorePoolSize 这类线程池控制的方法，会中断正在运行的线程。</li>
</ol>
<ul>
<li>setCorePoolSize方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t really know how many new threads are &quot;needed&quot;.</span></span><br><span class="line">        <span class="comment">// As a heuristic, prestart enough new workers (up to new</span></span><br><span class="line">        <span class="comment">// core size) to handle the current number of tasks in</span></span><br><span class="line">        <span class="comment">// queue, but stop if queue becomes empty while doing so.</span></span><br><span class="line">        <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>interruptIdleWorkers</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果允许重入，<code>w.tryLock()</code>为<code>true</code>，线程就把自己打断了。</p>
<ul>
<li><p>此外，在构造方法中执行了setState(-1);，把 state 变量设置为 -1，是因为 AQS 默认的 state 是0，如果刚创建了一个 Worker 对象，还没有执行任务时，这时就不应该被中断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">  setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  setState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>tryAcquire 方法是根据 state 是否是 0 来判断的，所以，<code>setState(-1);</code>将 state 设置为 -1 是为了禁止在执行任务前对线程进行中断</li>
<li>在 runWorker 方法中会先调用 Worker 对象的 unlock 方法将 state 设置为 0, 允许中断和 lock</li>
</ul>
</li>
</ul>
<h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于操作 workers </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持有线程的引用, 管理线程的生命周期</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于通知线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池曾经创建过的最大线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池已经执行的和未执行的任务总数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么workers使用HashSet和ReentraintLock而不使用并发的set ?<ul>
<li>简化了统计数据，比如说将 worker 添加到 workers 后还需要判断是否需要更新 largestPoolSize 等，workers 只在获取到 mainLock 的情况下才会进行读写</li>
<li>mainLock 也用于在中断线程<code>interruptIdleWorkers</code>的时候串行执行，否则可能会并发进行线程中断，引起不必要的中断高峰。否则退出中的线程会并发地中断那些还没有被中断的线程。</li>
</ul>
</li>
</ul>
<h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>shutdown：不接收新任务，等待任务执行结束；<br>shutdownNow：立即结束所有线程，队列中线程不再执行，不接收新任务，返回未结束任务列表（队列中的）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 安全策略判断</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 切换状态为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置状态为 STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有工作线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 取出队列中没有被执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h2><h3 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h3><ul>
<li>线程池中线程的销毁依赖 JVM 的垃圾回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可</li>
<li>Worker 被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务</li>
<li>当 Worker 无法获取到任务，也就是获取的任务为空时，循环会结束，Worker 会主动消除自身在线程池内的引用</li>
<li>线程回收的工作在 processWorkerExit 方法内完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 completedAbruptly 值为 true，则说明线程执行时出现了异常，需要将 workerCount 减 1</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在 getTask() 方法中已经已经对 workerCount 进行了减 1 操作</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从 workers 中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当线程池是 RUNNING 或 SHUTDOWN 状态时，如果 worker 是异常结束，那么会直接 addWorker；</span></span><br><span class="line"><span class="comment">     * 如果 allowCoreThreadTimeOut 为 true，并且等待队列有任务，至少保留一个 worker；</span></span><br><span class="line"><span class="comment">     * 如果 allowCoreThreadTimeOut 为 false，workerCount 不少于 corePoolSize。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">              min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tryTerminate-根据状态判断是否结束"><a href="#tryTerminate-根据状态判断是否结束" class="headerlink" title="tryTerminate : 根据状态判断是否结束"></a>tryTerminate : 根据状态判断是否结束</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当前线程池的状态为以下几种情况时，直接返回：</span></span><br><span class="line"><span class="comment">         * 1. RUNNING，因为还在运行中，不能停止</span></span><br><span class="line"><span class="comment">         * 2. TIDYING 或 TERMINATED，因为线程池中已经没有正在运行的线程了</span></span><br><span class="line"><span class="comment">         * 3. SHUTDOWN 并且等待队列非空，这时要执行完 workQueue 中的 task；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果线程数量不为 0，则中断一个空闲的工作线程，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断到这个位置则说明线程数量为 0 并且等待队列为空</span></span><br><span class="line">            <span class="comment">// 尝试设置状态为 TIDYING，如果成功则调用 terminated 方法</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// terminated 方法默认什么都不做，留给子类实现</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置状态为 TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">        <span class="comment">// 没设置成功则继续 CAS 尝试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h2><ul>
<li>scheduleAtFixedRate：如果执行时间大于周期时间，在上一个任务执行完毕后，立即执行下一个；</li>
<li>scheduleWithFixedDelay：如果执行时间大于周期时间，在上一次完毕后，再重新计时。</li>
</ul>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="ThreadPoolExecutor-的执行方法有几种？它们有什么区别？"><a href="#ThreadPoolExecutor-的执行方法有几种？它们有什么区别？" class="headerlink" title="ThreadPoolExecutor 的执行方法有几种？它们有什么区别？"></a><strong>ThreadPoolExecutor 的执行方法有几种？它们有什么区别？</strong></h3><ul>
<li><p><code>execute()</code> VS <code>submit()</code></p>
<ul>
<li><p>都是用来执行线程池任务，它们最主要的区别是 <code>submit()</code>方法可以接收线程池执行的返回值，而 <code>execute()</code> 不能接收返回值</p>
</li>
<li><p>```java<br>ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 10, 10L,</p>
<pre><code>    TimeUnit.SECONDS, new LinkedBlockingQueue(20));
</code></pre><p>// execute 使用<br>executor.execute(new Runnable() {</p>
<pre><code>@Override
public void run() &#123;
    System.out.println(&quot;Hello, execute.&quot;);
&#125;
</code></pre><p>});<br>// submit 使用<br>Future<String> future = executor.submit(new Callable<String>() {</String></String></p>
<pre><code>@Override
public String call() throws Exception &#123;
    System.out.println(&quot;Hello, submit.&quot;);
    return &quot;Success&quot;;
&#125;
</code></pre><p>});<br>System.out.println(future.get());</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * &#96;execute()&#96; 方法属于 &#96;Executor&#96; 接口的方法，而 &#96;submit() &#96;方法则是属于 &#96;ExecutorService&#96; 接口的方法</span><br><span class="line"></span><br><span class="line">  * 在 &#96;submit() &#96;中处理的任务如果抛出异常, 只有在调用返回的 &#96;Future &#96;对象 &#96;get &#96;方法时才会抛出</span><br><span class="line"></span><br><span class="line">### **拒绝策略的分类有哪些? 如何自定义拒绝策略？**</span><br><span class="line"></span><br><span class="line">* 自带的拒绝策略有 4 种:</span><br><span class="line"></span><br><span class="line">  * **AbortPolicy**，终止策略，线程池会抛出异常并终止执行，它是**默认**的拒绝策略</span><br><span class="line">  * **CallerRunsPolicy**，把任务交给当前线程来执行</span><br><span class="line">  * **DiscardPolicy**，忽略此任务（最新的任务）</span><br><span class="line">  * **DiscardOldestPolicy**，忽略最早的任务（最先加入队列的任务）</span><br><span class="line"></span><br><span class="line">* 自定义拒绝策略</span><br><span class="line"></span><br><span class="line">  * 自定义拒绝策略只需要新建一个&#96; RejectedExecutionHandler&#96; 对象，然后重写它的 &#96;rejectedExecution() &#96;方法即可</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(1, 3, 10,</span><br><span class="line">          TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(2),</span><br><span class="line">          new RejectedExecutionHandler() &#123;  &#x2F;&#x2F; 添加自定义拒绝策略</span><br><span class="line">              @Override</span><br><span class="line">              public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">                  &#x2F;&#x2F; 业务处理方法</span><br><span class="line">                  System.out.println(&quot;执行自定义拒绝策略&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">  for (int i &#x3D; 0; i &lt; 6; i++) &#123;</span><br><span class="line">      executor.execute(() -&gt; &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName());</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="线程池的工作队列有哪些"><a href="#线程池的工作队列有哪些" class="headerlink" title="线程池的工作队列有哪些?"></a><strong>线程池的工作队列有哪些?</strong></h3><ul>
<li>ArrayBlockingQueue, 是一个用数组实现的<strong>有界</strong>阻塞队列，按 FIFO 排序任务, 支持公平锁和非公平锁</li>
<li>LinkedBlockingQueue, 基于链表结构的阻塞队列，按 FIFO 排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为 Integer.MAX_VALUE，吞吐量通常要高于 ArrayBlockingQuene</li>
<li>DelayQueue, 是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序</li>
<li>PriorityBlockingQueue, 是具有优先级的<strong>无界</strong>阻塞队列, 不能保证同优先级元素的顺序</li>
<li>SynchronousQueue, 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue</li>
<li>SynchronousQueue, 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue</li>
<li>LinkedBlockingDeque, 一个由链表结构组成的双向阻塞队列，队列头尾都可以插入和移除元素, 多线程并发时, 可以将锁的竞争最多 降到一半</li>
</ul>
<h3 id="ThreadPoolExecutor-如何实现扩展？"><a href="#ThreadPoolExecutor-如何实现扩展？" class="headerlink" title="ThreadPoolExecutor 如何实现扩展？"></a><strong>ThreadPoolExecutor 如何实现扩展？</strong></h3><ul>
<li>通过重写<code>beforeExecute()</code>和 <code>afterExecute()</code>方法，我们可以在扩展方法中添加日志或者实现数据统计，比如统计线程的执行时间</li>
</ul>
<h3 id="关于-Executors-内的线程池对象"><a href="#关于-Executors-内的线程池对象" class="headerlink" title="关于 Executors 内的线程池对象"></a><strong>关于 Executors 内的线程池对象</strong></h3><ul>
<li>Executors 源码中<code>Executors.newFixedThreadPool()</code>、<code>Executors.newSingleThreadExecutor()</code>和 <code>Executors.newCachedThreadPool()</code>等方法的底层都是通过 <code>ThreadPoolExecutor</code>实现的<ul>
<li><code>FixedThreadPool</code> (固定数目线程的线程池)<ul>
<li>适用于处理 CPU 密集型的任务，确保 CPU 在长期被工作线程使用的情况下，尽可能的少的分配线程</li>
<li>特点<ul>
<li>核心线程数和最大线程数大小一样</li>
<li>keepAliveTime 为 0</li>
<li>阻塞队列为 LinkedBlockingQueue</li>
</ul>
</li>
</ul>
</li>
<li>CachedThreadPool (可缓存线程的线程池)<ul>
<li>适用于并发执行大量短期的小任务</li>
<li>特点<ul>
<li>核心线程数为 0</li>
<li>最大线程数为 Integer.MAX_VALUE</li>
<li>阻塞队列为 SynchronousQueue</li>
<li>非核心线程空闲存活时间为 60 秒</li>
</ul>
</li>
</ul>
</li>
<li>SingleThreadExecutor (单线程的线程池)<ul>
<li>适用于串行执行任务的场景，一个任务一个任务地执行</li>
<li>特点<ul>
<li>核心线程数为 1</li>
<li>最大线程数也为 1</li>
<li>阻塞队列是 LinkedBlockingQueue</li>
<li>keepAliveTime 为 0</li>
</ul>
</li>
</ul>
</li>
<li>ScheduledThreadPool (定时及周期执行的线程池)<ul>
<li>周期性执行任务的场景，需要限制线程数量的场景</li>
<li>特点<ul>
<li>最大线程数为 Integer.MAX_VALUE</li>
<li>阻塞队列是 DelayedWorkQueue</li>
<li>keepAliveTime 为 0</li>
<li>scheduleAtFixedRate() 按某种速率周期执行</li>
<li>scheduleWithFixedDelay() 在某个延迟后执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在阿里巴巴的《 Java 开发手册 》中是这样规定的：<ul>
<li>线程池不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</li>
<li><code>Executors</code> 返回的线程池对象的弊端如下：<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>：允许的请求队列长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM</li>
<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>：允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致 OOM</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://chansonchan.cn/2020/05/20/Java-线程与线程池/#more">Chanson’s blog：Java-线程与线程池</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>给初学者的学习文档</title>
    <url>/blog/a2ffe8c8.html</url>
    <content><![CDATA[<h1 id="羽毛球训练热身"><a href="#羽毛球训练热身" class="headerlink" title="羽毛球训练热身"></a>羽毛球训练热身</h1><p>略。<br><a id="more"></a></p>
<h1 id="握拍"><a href="#握拍" class="headerlink" title="握拍"></a>握拍</h1><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol>
<li>虎口范围可调整（不一定完全对准拍框），因人而异，但是拍面应该垂直于地面<br>原因是挥拍击打头顶球时，做完内旋，拍面不会左右倾斜。</li>
<li>要放松，食指与中指是分开的，下面三个手指是比较贴近的，掌心留空，指肚贴拍柄（检查方法：用另一只手可以把拍子抽出）。需要放松的原因是，击球瞬间再把拍子握紧，可以有一个鞭打力。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="细节讲解（好好看视频里的提示点）"><a href="#细节讲解（好好看视频里的提示点）" class="headerlink" title="细节讲解（好好看视频里的提示点）"></a>细节讲解（好好看视频里的提示点）</h3><p><a href="https://www.bilibili.com/video/BV16E411w7B3?from=search&amp;seid=831297106869582416">https://www.bilibili.com/video/BV16E411w7B3?from=search&amp;seid=831297106869582416</a></p>
<h3 id="通俗讲解"><a href="#通俗讲解" class="headerlink" title="通俗讲解"></a>通俗讲解</h3><h4 id="正手握拍"><a href="#正手握拍" class="headerlink" title="正手握拍"></a>正手握拍</h4><p><a href="https://www.bilibili.com/video/BV1i7411W76p?from=search&amp;seid=10647622084485127280">https://www.bilibili.com/video/BV1i7411W76p?from=search&amp;seid=10647622084485127280</a></p>
<h4 id="反手握拍"><a href="#反手握拍" class="headerlink" title="反手握拍"></a>反手握拍</h4><p><a href="https://www.bilibili.com/video/BV187411s7iw?from=search&amp;seid=10647622084485127280">https://www.bilibili.com/video/BV187411s7iw?from=search&amp;seid=10647622084485127280</a></p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>练习《参考视频1》5:50 中提到的握拍练习</p>
<h1 id="高远球"><a href="#高远球" class="headerlink" title="高远球"></a>高远球</h1><h2 id="心得-1"><a href="#心得-1" class="headerlink" title="心得"></a>心得</h2><p><strong>内旋，内旋，内旋！</strong><br>击球点的不同会把球分为高远球，平高球，杀球。先练习高远球，动动腿把击球点控制在持拍侧上方。</p>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="静态动作（里面有3个视频，p2-p3顺序反了）"><a href="#静态动作（里面有3个视频，p2-p3顺序反了）" class="headerlink" title="静态动作（里面有3个视频，p2 p3顺序反了）"></a>静态动作（里面有3个视频，p2 p3顺序反了）</h3><p><a href="https://www.bilibili.com/video/BV1bk4y127tE?t=431">https://www.bilibili.com/video/BV1bk4y127tE?t=431</a></p>
<h2 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h2><p>对照镜子练习原地挥拍动作。先练分步的各个动作，每个动作保持到手酸为止，形成肌肉记忆，放松一下继续固定动作。再练连贯的动作，有条件就在高处挂一个物体（比如毛巾），体会挥拍时击打的感觉。</p>
<h3 id="场地训练"><a href="#场地训练" class="headerlink" title="场地训练"></a>场地训练</h3><ol>
<li>原地击打高远球（他人协助喂球/抛球）</li>
<li>移动击打高远球（他人喂球到后场左右两点）</li>
<li>高远球对拉。</li>
</ol>
<blockquote>
<p>固定住握拍和高远球动作前，尽量不要去打比赛哦，可以和朋友在半个场地内拉高远！避免动作变形！！！忍不住要上场的，每次要击打球前想想动作，不要只想着把球快点打过去，冷静！刚开始打不过去也没关系，先把动作做正确，错误动作做多了，就白练了。</p>
</blockquote>
<h1 id="发球"><a href="#发球" class="headerlink" title="发球"></a>发球</h1><h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="反手发球"><a href="#反手发球" class="headerlink" title="反手发球"></a>反手发球</h3><p>发球规则已经修改为不超过1.15米，所以拍子可以放平一些，没必要垂那么低<br>注意，偷发后场（3号,4号位）需要弧度高，否则容易被对方下压。<br><a href="https://www.bilibili.com/video/BV1Ss411n7rC?from=search&amp;seid=16226256394036641976">https://www.bilibili.com/video/BV1Ss411n7rC?from=search&amp;seid=16226256394036641976</a></p>
<h3 id="正手发球"><a href="#正手发球" class="headerlink" title="正手发球"></a>正手发球</h3><p>不要勾手腕，把动作挥完整，拍子放到左肩才停，应该可以避免勾手腕这个坏习惯。引拍动作有多种，找一个自己舒服的就可以，因为正手挥打力量足够大，基本都可以打到底线。拍面向下或偏内均可，但不可以朝身体外侧</p>
<p>在场地上多练习发球，没有轮到你上场时，在球网附近也可以偷偷练习，别把球打进场地就好了。</p>
<h1 id="步伐"><a href="#步伐" class="headerlink" title="步伐"></a>步伐</h1><h2 id="心得-2"><a href="#心得-2" class="headerlink" title="心得"></a>心得</h2><p>去没人的场地偷偷练习，偷偷变强。<br>场上的时候前期以并步为主，保证自己的安全，不要崴脚，不要把网冲断了。<br>跑起来，即使接不到，也跑过去意思下，顺便练习了步伐。</p>
<h2 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="无场地训练，增加步伐熟练度"><a href="#无场地训练，增加步伐熟练度" class="headerlink" title="无场地训练，增加步伐熟练度"></a>无场地训练，增加步伐熟练度</h3><p><a href="https://www.bilibili.com/video/BV1M44y1k7ut?from=search&amp;seid=5735119430400008596">https://www.bilibili.com/video/BV1M44y1k7ut?from=search&amp;seid=5735119430400008596</a></p>
<h3 id="场地训练，熟悉距离"><a href="#场地训练，熟悉距离" class="headerlink" title="场地训练，熟悉距离"></a>场地训练，熟悉距离</h3><p><a href="https://www.bilibili.com/video/BV1uz4y1Q7Ap?from=search&amp;seid=5735119430400008596">https://www.bilibili.com/video/BV1uz4y1Q7Ap?from=search&amp;seid=5735119430400008596</a></p>
<h2 id="作业-2"><a href="#作业-2" class="headerlink" title="作业"></a>作业</h2><p>训练参考资料1中的步伐，熟悉步伐的动作。<br>有机会到场地时，提前到球馆，有空余场地就去练，锻炼距离感，知道跨几步，每步跨多远。</p>
<h1 id="网前球"><a href="#网前球" class="headerlink" title="网前球"></a>网前球</h1><h2 id="心得-3"><a href="#心得-3" class="headerlink" title="心得"></a>心得</h2><p>训练网前球之前，练习颠球，掌握球感。同时把步伐练好，跑到位才有机会打网前球，跑得快才能抢高点！</p>
<h2 id="参考资料-4"><a href="#参考资料-4" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="正手搓球"><a href="#正手搓球" class="headerlink" title="正手搓球"></a>正手搓球</h3><p><a href="https://www.bilibili.com/video/BV1CK4y1s75C?from=search&amp;seid=646222718049103430">https://www.bilibili.com/video/BV1CK4y1s75C?from=search&amp;seid=646222718049103430</a></p>
<h3 id="反拍网前球"><a href="#反拍网前球" class="headerlink" title="反拍网前球"></a>反拍网前球</h3><p>这个系列的其他视频也可以看看，有助于双打： <a href="https://www.bilibili.com/video/BV1xQ4y1d7Hy">https://www.bilibili.com/video/BV1xQ4y1d7Hy</a><br>反拍勾球<br><a href="https://www.bilibili.com/video/BV1i64y1R7Yp">https://www.bilibili.com/video/BV1i64y1R7Yp</a></p>
<h1 id="杀球"><a href="#杀球" class="headerlink" title="杀球"></a>杀球</h1><h2 id="心得-4"><a href="#心得-4" class="headerlink" title="心得"></a>心得</h2><p>先练高远球。</p>
<h2 id="参考资料-5"><a href="#参考资料-5" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="高远球、杀球、平高球的击球点"><a href="#高远球、杀球、平高球的击球点" class="headerlink" title="高远球、杀球、平高球的击球点"></a>高远球、杀球、平高球的击球点</h3><p><a href="https://www.bilibili.com/video/BV1C54y1V7BA?t=158">https://www.bilibili.com/video/BV1C54y1V7BA?t=158</a></p>
<h3 id="纠正基础动作"><a href="#纠正基础动作" class="headerlink" title="纠正基础动作"></a>纠正基础动作</h3><p><a href="https://www.bilibili.com/video/BV1Hv41117wQ?from=search&amp;seid=15621131422957839623">https://www.bilibili.com/video/BV1Hv41117wQ?from=search&amp;seid=15621131422957839623</a></p>
<h1 id="双打"><a href="#双打" class="headerlink" title="双打"></a>双打</h1><h2 id="参考资料-6"><a href="#参考资料-6" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><a href="https://www.bilibili.com/video/BV1Jf4y187ni?from=search&amp;seid=6658664433716311723">https://www.bilibili.com/video/BV1Jf4y187ni?from=search&amp;seid=6658664433716311723</a></p>
<h3 id="站位（基本原则：守平行，攻前后）"><a href="#站位（基本原则：守平行，攻前后）" class="headerlink" title="站位（基本原则：守平行，攻前后）"></a>站位（基本原则：守平行，攻前后）</h3><p><a href="https://www.bilibili.com/video/BV1UD4y1X7Kj?from=search&amp;seid=6882988231310076761">https://www.bilibili.com/video/BV1UD4y1X7Kj?from=search&amp;seid=6882988231310076761</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>学到了这里，接杀、拉吊等等技术，在平常比赛中应该有了自己的体会，再上网查查资料，应该可以自学了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>羽毛球</category>
      </categories>
  </entry>
  <entry>
    <title>Navicat连接MySQL出现1251错误</title>
    <url>/blog/224524ad.html</url>
    <content><![CDATA[<h1 id="1251错误"><a href="#1251错误" class="headerlink" title="1251错误"></a>1251错误</h1><p><img src="https://cdn.jsdelivr.net/gh/JNhua/blog_images/img/20210918112513.png" alt="1251error"><br><a id="more"></a></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password, 解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password. </p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>采用第二种方式</p>
<p>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘password’; #修改加密规则 </p>
<p>ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘password’ PASSWORD EXPIRE NEVER; #更新一下用户的密码 </p>
<p>FLUSH PRIVILEGES; #刷新权限 </p>
<blockquote>
<p>‘root’   为你自己定义的用户名<br>‘localhost’ 指的是用户开放的IP<br>‘password’ 是你想使用的用户密码</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
        <category>database</category>
      </categories>
  </entry>
</search>
