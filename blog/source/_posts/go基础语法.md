---
title: go基础语法
date: '2020/8/03 19:43:13'
updated: '2020/8/07 18:30:20'
tags: []
category:
  - go
  - Go
mathjax: true
abbrlink: f700becf
---
# 语言结构
* 包声明
<!--more-->
* 引入包
* 函数
* 变量
* 语句 & 表达式
* 注释

**注意**：`{ `不能单独放在一行。go编译器会按行为语句加分隔符，如果`{`单独一行，上一行末尾会被分隔。
# 变量
变量：`var v_name v_type`
根据值自行判定类型： `var v_name  = value`
省略var，但是左侧必须有待新声明的变量：`v_name := value` 。只能使用在函数体内。
在相同代码块中，不可以重复声明同名变量，只能重新赋值。
## 多个变量
同时定义多个变量：
```go
var a,b = b,a
```
可以用组的方式：
```go
var(
    x,y int
    a,s=100,"abc"
)
```
## 常量
* 不曾使用的常量不会编译错误
* 右值不能超过常量类型取值范围
* 右值也可以是某些编译器能够计算出结果的表达式
* 在常量组中如果不指定类型和初始化值，则与上一行非空常量右值相同
* 在预处理阶段展开，不分配内存，不能内存寻址来取值

## 类型转换
除常量、别名类型以及未命名类型外，Go强制要求使用显式类型转换。
如果转换的目标是指针、单向通道或没有返回值的函数类型，那么必须使用括号，以避免造成语法分解错误。
### 自定义类型
即便指定了基础类型，也只表明它们有相同底层数据结构，两者间不存在任何关系，属完全不同的两种类型。除操作符外，自定义类型不会继承基础类型的其他信息（包括方法）。不能视作别名，不能隐式转换，不能直接用于比较表达式。
### 未命名类型
与有明确标识符的bool、int、string等类型相比，数组、切片、字典、通道等类型与具体元素类型或长度等属性有关，故称作未命名类型（unnamed type）。当然，可用type为其提供具体名称，将其改变为命名类型（named type）。
具有相同声明的未命名类型被视作同一类型。
* 具有相同基类型的指针。
* 具有相同元素类型和长度的数组（array）。
* 具有相同元素类型的切片（slice）。
* 具有相同键值类型的字典（map）。
* 具有相同数据类型及操作方向的通道（channel）。
* 具有相同字段序列（字段名、字段类型、标签，以及字段顺序）的结构体（struct）。
* 具有相同签名（参数和返回值列表，不包括参数名）的函数（func）。
* 具有相同方法集（方法名、方法签名，不包括顺序）的接口（interface）。
容易被忽视的是struct tag，它也属于类型组成部分，而不仅仅是元数据描述。
同样，函数的参数顺序也属签名组成部分。

未命名类型转换规则：

* 所属类型相同。
* 基础类型相同，且其中一个是未命名类型。
* 数据类型相同，将双向通道赋值给单向通道，且其中一个为未命名类型。
* 将默认值nil赋值给切片、字典、通道、指针、函数或接口。
* 对象实现了目标接口。

# 表达式
## 运算符
### 位运算
位清除（AND NOT）和位亦或（XOR）是不同的。它将右操作数对应二进制位都为1的重置为0（有些类似位图），以达到一次清除多个标记位的目的。
```go
x := 0b0101&^0b0011
// x=0100
```
### ++、--
自增、自减不再是运算符。只能作为独立语句，不能用于表达式，不能前置。
### 指针
指针类型支持相等运算符，但不能做加减法运算和类型转换。
指针没有专门指向成员的“->”运算符，统一使用“.”选择表达式。
## 流控制
### switch
相邻的空case不构成多条件匹配。无须显式执行break语句，case执行完毕后自动中断。如须贯通后续case（源码顺序），须执行fallthrough，但不再匹配后续条件表达式。注意，fallthrough必须放在case块结尾，可使用break语句阻止。
# 枚举
使用`iota`关键字实现枚举。如果中断`iota`自增，需要显示恢复。
```go
const(
    _,_ = iota*10    //0*10
    a               //1*10
    b               //2*10
    c = 100
    d               //100
    e = iota        //5*10
```

# 函数
```go
func function_name( [parameter list] ) [return_types] {
   函数体    
}
```
## 变参
变参本质上就是一个切片。只能接收一到多个同类型参数，且必须放在列表尾部。
## 命名返回值
命名返回值和参数一样，可当作函数局部变量使用，最后由return隐式返回。
```go
func div(x,y int) (z int,err error) { 
   if y==0{ 
       err=errors.New("division by zero") 
       return
   }
   z=x/y
   return         // 相当于"return z,err" 
}
```
这些特殊的“局部变量”会被不同层级的同名变量遮蔽。好在编译器能检查到此类状况，只要改为显式return返回即可。
除遮蔽外，我们还必须对全部返回值命名，否则编译器会搞不清状况。如果返回值类型能明确表明其含义，就尽量不要对其命名。
## 闭包
闭包是匿名函数和引用的环境变量指针的组合体。
正因为闭包通过指针引用环境变量，那么可能会导致其生命周期延长，甚至被分配到堆内存。另外，还有所谓“延迟求值”的特性。
```go
func getSequence() func() int {
   i:=0
   return func() int {
      i+=1
     return i  
   }
}

func main(){
   /* nextNumber 为一个函数，i 为 0 */
   nextNumber := getSequence()  

   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
   fmt.Println(nextNumber())
   fmt.Println(nextNumber())
   fmt.Println(nextNumber())
   
   /* 创建新的函数 nextNumber1，并查看结果 */
   nextNumber1 := getSequence()  
   fmt.Println(nextNumber1())
   fmt.Println(nextNumber1())}
```
```
执行结果：
1 
2 
3 
1 
2
```
## 延迟调用defer
注意，延迟调用注册的是调用，必须提供执行所需参数（哪怕为空）。参数值在注册时被复制并缓存起来。如对状态敏感，可改用指针或闭包。
延迟调用可修改当前函数命名返回值，但其自身返回值被抛弃。
多个延迟注册按FILO次序执行。
相比直接用CALL汇编指令调用函数，延迟调用则须花费更大代价。这其中包括注册、调用等操作，还有额外的缓存开销。
# 数据
## 字符串
以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组。
```go
func main() { 
   s:= "abcdefg" 
   s1:=s[:3]          // 从头开始，仅指定结束索引位置
   s2:=s[1:4]         // 指定开始和结束位置，返回[start,end) 
   s3:=s[2:]          // 指定开始位置，返回后面全部内容
   println(s1,s2,s3) 
    //  reflect.StringHeader和string头结构相同
    //  unsafe.Pointer用于指针类型转换
   fmt.Printf("%#v\n", (*reflect.StringHeader)(unsafe.Pointer(&s))) 
   fmt.Printf("%#v\n", (*reflect.StringHeader)(unsafe.Pointer(&s1))) 
}
```
输出
```
abc bcd cdefg
  
&StringHeader{Data:0xfb838,Len:7} 
&StringHeader{Data:0xfb838,Len:3}
```
使用for遍历字符串时，分byte和rune两种方式。rune:返回（数组索引号，Unicode字符）。
### 转换
要修改字符串，须将其转换为可变类型（[]rune或[]byte），待完成后再转换回来。但不管如何转换，都须重新分配内存，并复制数据。
## 数组
初始化
```go
func main() { 
   var a[4]int    // 元素自动初始化为零
   b:= [4]int{2,5}    // 未提供初始值的元素自动初始化为0
   c:= [4]int{5,3:10}     // 可指定索引位置初始化
   d:= [...]int{1,2,3}        // 编译器按初始化值数量确定数组长度
   e:= [...]int{10,3:100}      // 支持索引初始化，但注意数组长度与此有关
}
```
对于结构等复合类型，可省略元素初始化类型标签。
在定义多维数组时，仅第一维度允许使用“...”。
内置函数len和cap都返回第一维度长度。
## 切片
定义：`var identifier []type` 或者 `var slice1 []type = make([]type, len)`
初始化：`s :=[] int {1,2,3 }`  或者 `s := arr[startIndex:endIndex]`
属性cap表示切片所引用数组片段的真实长度，len用于限定可读的写元素数量。另外，数组必须addressable，否则会引发错误。比如数组是map的value值，仅仅是一个值，没有地址。
新建切片对象依旧指向原底层数组，也就是说修改对所有关联切片可见。
### append
向切片尾部（slice[len]）添加数据，返回新的切片对象。不会修改原slice属性，但是数据被追加到原底层数组。如超出cap限制，则为新切片对象重新分配数组。
### copy
在两个切片对象间复制数据，允许指向同一底层数组，允许目标区间重叠。最终所复制长度以较短的切片长度（len）为准。
```go
func main() { 
   s:= []int{0,1,2,3,4,5,6,7,8,9} 
   s1:=s[5:8] 
   n:=copy(s[4:],s1)      // 在同一底层数组的不同区间复制
   s2:=make([]int,6)      // 在不同数组间复制
   n=copy(s2,s) 
}
```
如果切片长时间引用大数组中很小的片段，那么建议新建独立切片，复制出所需数据，以便原数组内存可被及时回收。
## 字典
map： `var v_name map[key_type]data_type` 或者 `v_name = make(map[key_type]data_type)`或者
```go
m:=map[int]struct{        // 值为匿名结构类型
       x int
}{ 
   1:  {x:100},          
   2:  {x:200}, 
} 
```
运行时会对字典并发操作做出检测。如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典执行并发操作（读、写、删除），否则会导致进程崩溃。
## 结构体
### 匿名字段
所谓匿名字段（anonymous field），是指没有名字，仅有类型的字段，也被称作嵌入字段或嵌入类型。
从编译器角度看，这只是隐式地以类型名作为字段名字。可直接引用匿名字段的成员，但初始化时须当作独立字段。
如嵌入其他包中的类型，则隐式字段名字不包括包名。
不仅仅是结构体，除接口指针和多级指针以外的任何命名类型都可作为匿名字段。
因未命名类型没有名字标识，自然无法作为匿名字段。
不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同。
### 字段标签
字段标签（tag）并不是注释，而是用来对字段进行描述的元数据。尽管它不属于数据成员，但却是类型的组成部分。
在运行期，可用反射获取标签信息。它常被用作格式校验，数据库关系映射等。
# 方法
```go
func (type_name type) function_name(variable_name variable_data_type) [return_type]{
   /* 函数体*/}
/* 定义结构体 */
type Circle struct {
  radius float64
}
func main() {
  var c1 Circle
  c1.radius = 10.00
  fmt.Println("圆的面积 = ", c1.getArea())
}
//该 method 属于 Circle 类型对象中的方法
func (c Circle) getArea() float64 {
  //c.radius 即为 Circle 类型对象中的属性
  return 3.14 * c.radius * c.radius
}
```
方法同样不支持重载（overload）。如方法内部并不引用实例，可省略参数名，仅保留类型。
方法可看作特殊的函数，那么receiver的类型自然可以是基础类型或指针类型。这会关系到调用时对象实例是否被复制。
可使用实例值或指针调用方法，编译器会根据方法receiver类型自动在基础类型和指针类型间转换。
不能用多级指针调用方法。
指针类型的receiver必须是合法指针（包括nil），或能获取实例地址。

## 如何选择方法的receiver类型？
* 要修改实例状态，用`*T`。
* 无须修改状态的小对象或固定值，建议用T。
* 大对象建议用`*T`，以减少复制成本。
* 引用类型、字符串、函数等指针包装对象，直接用T。
* 若包含Mutex等同步字段，用`*T`，避免因复制造成锁操作无效。
* 其他无法确定的情况，都用`*T`。
# 错误处理
```
type error interface {
    Error() string
}
```
使用`error.New(“xxx”)`生成错误信息。

# 并发
`goroutine`：go 函数名( 参数列表 )
通道：
`ch <- v`    // 把 v 发送到通道 ch
`v := <-ch`  // 从 ch 接收数据
           // 并把值赋给 v
声明通道： `ch := make(chan int)`


# context上下文
context 包在与 API 和慢处理交互时可以派上用场，特别是在生产级的 Web 服务中。在这些场景中，您可能想要通知所有的 goroutine 停止运行并返回。
https://studygolang.com/articles/13866?fr=sidebar
